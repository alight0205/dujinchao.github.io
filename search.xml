<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>jquery常用方法</title>
      <link href="2020/10/01/jquery%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"/>
      <url>2020/10/01/jquery%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="全局核心函数"><a href="#全局核心函数" class="headerlink" title="全局核心函数"></a>全局核心函数</h1><p>$(jQuery)</p><p>jQuery.fn=jQuery.prototype</p><h2 id="创建元素"><a href="#创建元素" class="headerlink" title="创建元素"></a>创建元素</h2><p>$(‘<code>&lt;div&gt;&lt;/div&gt;</code>‘);创建 jq 对象。</p><a id="more"></a><h2 id="选择元素"><a href="#选择元素" class="headerlink" title="选择元素"></a>选择元素</h2><p>$();此函数可以传递多种参数，返回值是对象（jq 对象）</p><h2 id="参数规则"><a href="#参数规则" class="headerlink" title="参数规则"></a>参数规则</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">      css selector、 jquery unique selector</span><br><span class="line">null、undefined、dom</span><br><span class="line"></span><br><span class="line">$(function()&#123;&#125;)&#x3D;&#x3D;$(document).ready(function())&#x2F;&#x2F;解析完成后执行</span><br><span class="line"></span><br><span class="line">css selector和context</span><br></pre></td></tr></table></figure><h2 id="css-规则"><a href="#css-规则" class="headerlink" title="css 规则"></a>css 规则</h2><ul><li>$(‘div span’); 可以直接用 css 属性获取到</li><li>$(‘div span’).css({width:100,height:100}); 可以直接传 css 属性</li></ul><h2 id="jqurey-特有规则"><a href="#jqurey-特有规则" class="headerlink" title="jqurey 特有规则"></a>jqurey 特有规则</h2><ul><li>$(‘span:first’);//代表所选 span 中的第一个 span</li><li>$(‘span:odd’);//奇数个的 span</li><li>$(‘span:even’);//偶数个的 span</li><li>$(‘span:eq(3)’);//索引为 3 的 span</li><li>$(‘span[title]’);//含有 title 属性的 span 元素</li><li>$(‘span[data=”duyi”]’);//元素为 span 并且属性 data=duyi 的 span 元素</li><li>$(‘span[data!=”Duyi”]’);//属性不为 data=duyi 的 span 元素</li><li>$(‘span[data$=”Duyi”]’);//结尾属性为 data=duyi 的 span 元素</li><li>$(‘span[data^=”Duyi”]’);//开头属性为 data=duyi 的 span 元素</li><li>$(‘span[data*=”Duyi”]’);//属性 data 包含 duyi 的 span 元素</li><li>$(“span:contains(is)”);//内容包含”is”字符串的 span 元素</li><li>$(‘span:parent’);//子元素包含 span 标签的元素</li><li>$(‘span:visible’);//所有可见的 span 元素</li><li>$(‘span:hidden’);//所有隐藏的 span 元素</li></ul><h2 id="还可以传的参数"><a href="#还可以传的参数" class="headerlink" title="还可以传的参数"></a>还可以传的参数</h2><ul><li>null undefined ‘’ 有容错机制</li><li>$(dom)：把元素 dom 包装成 jqurey 对象（不然不能用人家方法啊）</li><li>$(function(){})</li><li><strong>==$(‘li’,’ul’)：上下文，前面是确定的元素，后面是上下文==</strong></li></ul><h1 id="jqurey-实例方法-DOM-操作"><a href="#jqurey-实例方法-DOM-操作" class="headerlink" title="jqurey 实例方法-DOM 操作"></a>jqurey 实例方法-DOM 操作</h1><h2 id="选择元素相关方法"><a href="#选择元素相关方法" class="headerlink" title="选择元素相关方法"></a>选择元素相关方法</h2><ul><li>.==get==();把 jqurey 对象变为原生 dom（注：get()里面可以加索引）</li><li>.==eq==();返回 jqurey 的索引对象。（注：eq()里面可以加索引，默认 0，灵活应用：$(‘p’).css().eq(0).css()，先给全部 css，然后还能再给索引位 css）</li><li>.==find==();在原有基础上查找任意子元素（注：==非常常用==。如：$(‘div’).find(‘p’).find(‘span’)）</li><li>.children();直接子元素集</li><li>.==filter==();过滤，只能在前面元素中查找。（注：是在前面 jq 对象中筛选，不能找子元素）<ul><li>可以放 function,返回 true 此元素通过，反之此元素不获取。</li></ul></li><li>.not();反选，不是。。。</li><li>.has();过滤，判断它的下面是否有某元素。（注：$(‘p’).has(‘span’)：找到下面有 span 的 p 元素，是一个类数组，若找不到，返回一个 length 为 0 的类数组）</li><li>.is();判断是否有交集。（注：可以判断 if($(e.target).is(‘li’))，或者$(‘.demo’).is(‘li’)）</li><li>.==add==();绑定多个 jq 对象。（注：如$(‘p’).add(‘a’).css()，绑定多个元素进行操作）</li><li>.end();回退。回到元素最开始位置。</li></ul><h2 id="取赋值相关方法"><a href="#取赋值相关方法" class="headerlink" title="取赋值相关方法"></a>取赋值相关方法</h2><ul><li>.html();相当于.innerHTML() （注：取值取第一个元素，赋值赋全部元素，可以放 function(index,ele)处理）</li><li>.text();相当于.innerText()(注：取赋值都会给全部元素，不可以建标签，可以放 function(index,ele)处理)</li><li>.size();相当于.length,既然用 jq，就尽量一致吧。</li><li>.addClass();给元素加 class。（注：可以加 function）</li><li>.removeClass();给元素删除 class。（注：若为空，就全部删除，若为多个，贪婪匹配。可传 function(index,ele){return xx}进行灵活应用）</li><li>.hasClass();判断前面的对象有没有()里面的属性。</li><li>.css();可以读写 css 属性。（注：可以写单个属性，也可以传多个属性。可以操作数值,如 +=100px）</li><li>.attr();基于 setAttbute 和 getAttbute，读写元素自定义属性。（注：像 class、chacked、selected、disablad 这种属性推荐用 prop）<ul><li>可以操作任何属性，设置属性值会映射到 dom 行间样式</li></ul></li><li>.prop();用于读写元素的特性属性。(注：()里面填属性值，第二个参数可修改属性，如.prop(‘checked’,true);）<ul><li>只可以操作特性，设置特性值会映射到 dom 行间样式</li></ul></li><li>.==data()==<ul><li>可以往 jQuery 对象中存取信息，会与 dom 信息形成映射（即给某个元素设置 data 属性后，就可以通过这个元素获取到这个属性）</li><li>可以获取到 dom 元素行间样式上以<code>data-</code>开头的数据</li><li>==设置的数据会与 dom 信息形成映射，但是不会映射到 dom 的行间样式上（即信息会形成映射，但不会操作 dom）==</li><li>如果设置特性，如 class，只会形成一个为 data 属性的 class，并不会改变 dom 元素的 class</li><li>clone()也会克隆到 data 的属性值</li></ul></li><li>.val();读取表单元素的 value 值。（注：input 使用，可用 function(index,oldValue){}）</li></ul><h2 id="data-、prop-、attr-三者区别"><a href="#data-、prop-、attr-三者区别" class="headerlink" title="data()、prop()、attr() 三者区别"></a>data()、prop()、attr() 三者区别</h2><ul><li>prop()是读取元素的特性（原来的 dom.特性 不可使用），映射到行间样式</li><li>attr()读取元素属性（包括特性），映射到行间样式</li><li>data()读取自定义属性<ul><li>读取元素上以<code>data-</code>开头的属性</li><li>读取自定义的 data 属性</li><li>不会映射到行间，但与 dom 信息形成映射</li></ul></li></ul><h2 id="基于-jQuery-对象增删改查相关方法"><a href="#基于-jQuery-对象增删改查相关方法" class="headerlink" title="基于 jQuery 对象增删改查相关方法"></a>基于 jQuery 对象增删改查相关方法</h2><ul><li>==$(selector).load(URL,data,callback)==;<ul><li>load() 方法从服务器加载数据，并把返回的数据放入被选元素中。</li><li>如果是本地 url，路径是 index.html 为起始的路径</li></ul></li><li>.==next==();//下一个兄弟元素（注：可以加限定条件。如：.next(‘p’)。若不符合则无效果。若使用.next()的元素是一个，则 next 选中一个，若使用元素多个，则选中多个）</li><li>.prev();//上一个兄弟元素（注：同上）</li><li>.nextAll();//下一群兄弟节点（注：可通过传参过滤。如：input[type=”checkbox”]）</li><li>.prevAll();//上一群兄弟节点（注：同上）</li><li>.==nextUntil==();//下一群兄弟节点，到什么为止。（注：从当前元素开始，第一个参数是到哪个元素为止，第二个参数，只找范围内的哪种元素。如：.nextUntil(‘p’,’a’);找到当前元素到 p 元素中间的所有 a 元素。）</li><li>.prevUntil();//上一群兄弟节点。（注：同上）</li><li>.siblings();所有兄弟节点。(注：可以传参数过滤,弱不符合无效果)</li><li>.parent();//上一级父级元素。(注：可以传参数过滤,弱不符合无效果)</li><li>.parents();//多层父级元素。（注：默认获取所有父级，可传参进行精准过滤）</li><li>.closest();//找到距离元素最近的符合条件的父级元素。（注：必须传参，从自己开始往上找）</li><li>.offsetParent();//找到距离元素最近的有定位的父级元素。</li><li>.slice();//截取。（注：左闭右开）</li><li>.insertBefore();插入插入到 xx 前面。$(‘a’).insertBefore(‘b’)。(注：把 a 插入到 b 元素前面，继续操作 a)</li><li>.before();插入到 xx 前面。$(‘a’).before($(‘b’))。（注：把 b 插入到 a 元素之前,继续操作 a）</li><li>.insertAfter();插入到 xx 后面（注：把 a 插入到 b 后）</li><li>.after();插入到 xx 后面（注：把 b 插入到 a 后）</li><li>.append();在尾部添加元素，相当于 appendChild。$(‘.div’).append($(‘.p’));(注：父元素在前)</li><li>.appendTo();元素添加到 xx 尾部，相当于 appendChild。$(‘.p’).append($(‘.div’));(注：子元素在前)</li><li>.prepend();在头部添加元素（注：同上）</li><li>.prependTo();元素添加到 xx 头部（注：同上）</li><li>.remove();删除自己这个元素。（注：$(‘p’).remove().appendTo($(‘body’)),这样就相当于删除然后加入，页面无变化，但是绑定的事件会消失）</li><li>.datach();删除自己这个元素。（注：删除然后加入，页面无变化，绑定的事件不会消失）</li><li>.empty();清空所有子元素，没有参数。</li><li>$(‘<code>&lt;div&gt;&lt;/div&gt;</code>‘);创建 jq 对象。（注：写法如$(‘<code>&lt;div/&gt;</code>‘),可以写的更复杂）</li><li>.wrap();//加一个包装层，$(‘p’).wrap(‘<code>&lt;div&gt;&lt;/div&gt;</code>‘)（注：可以原生，也可以 jq 对象，如果是已有元素，则会复制。也可以用 function(index){return xx}）</li><li>.wrapInner();//给内部元素加一个父级(也就是中间层),（注：使用方法同上）</li><li>.wrapAll();//给所有匹配到的 jq 对象加一个统一的父级。（注：给第一个匹配到的元素加父级，然后后面再匹配到的都 push 到这个父级里面，如果匹配元素不在一个层级，会出现改变结构的情况）</li><li>.unwrap();//干掉一层父级。（注：到 body 干不动了）</li><li>.clone();//克隆，$(‘.demo’).clone().appendTo(‘body’);（注：可以传参数 true,若传参数，可克隆事件，反之只克隆元素。）</li></ul><h2 id="事件操作"><a href="#事件操作" class="headerlink" title="事件操作"></a>事件操作</h2><p>事件绑定</p><ul><li>.on();//可传参数 1.==type== 2.selector 3.data 4.==handle==。（注：多次绑定多次执行）<ul><li>绑定多个事件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(&#39;div&#39;).on(&#123;click:function()&#123;&#125;,mouseenter:function()&#123;&#125;&#125;)</span><br></pre></td></tr></table></figure></li><li>第二个参数是事件委托对象</li><li>第三个参数是可传入的数据，是对象形式，可在 e.data 中找到<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(&#39;div&#39;).on(&#39;click&#39;,&#123;name:&quot;du&quot;&#125;,function(e)&#123;</span><br><span class="line">    console.log(e.data);&#x2F;&#x2F;&#123;name:&quot;du&quot;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul></li><li>.one();//只执行一次的绑定事件，使用一次后失效。最后加 return false;</li><li>.off();//解除绑定事件。（注：默认解除全部事件，传参解除某项事件，第二个参数可传事件方法，指定某种事件类型的某个方法。）</li><li>.trigger();//触发自定义事件方法。（注：第二个参数可传函数参数，为数组形式）</li><li>.hover();//移入移出事件。$(‘div’).hover(function(){移入事件},function(){移出事件});</li><li>.click/keydown/mouseenter/mousewheel(滚轮事件)…</li></ul><h1 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&#x27;ul&#x27;</span>).on(<span class="string">&#x27;click&#x27;</span>,<span class="string">&#x27;li&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;alert($(e.target).text());</span><br></pre></td></tr></table></figure><h1 id="兼容事件对象"><a href="#兼容事件对象" class="headerlink" title="兼容事件对象"></a>兼容事件对象</h1><ul><li>e.pageX、e.clienX、e.which、e.button</li><li>e.parventDefault()</li><li>e.stopPropagation();</li></ul><h2 id="小知识：阻止默认事件："><a href="#小知识：阻止默认事件：" class="headerlink" title="小知识：阻止默认事件："></a>小知识：阻止默认事件：</h2><p>直接 return false;或者 e.preventDefault();</p><h2 id="小知识：jQuery-对象都有一个属性，prevObject"><a href="#小知识：jQuery-对象都有一个属性，prevObject" class="headerlink" title="小知识：jQuery 对象都有一个属性，prevObject"></a>小知识：jQuery 对象都有一个属性，prevObject</h2><p>进行这一步操作的前一个 jQuery 对象。（注：最高指向 document）</p><h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><ul><li>.show();显示隐藏的元素。改变宽高和透明度（注：可以加毫秒数，决定显示的速度，第二个参数可以填运动速度，如’swing’）</li><li>.hide();隐藏元素。改变宽高和透明度（注：可以加毫秒数，决定显示的速度，第二个参数可以填运动速度，如’swing’）</li><li>.toggle();隐藏时显示，显示时隐藏。改变宽高和透明度（注：同上）</li><li>.fadeIn/fadeOut/fadeToggle 作用同上（注：只改变透明度，透明度为 0 时隐藏。其他属性同上）</li><li>.fadeTo(1000,0.6,’swing’,function(){});（注：只有 to 可以有这第二个参数，到什么时候指向）</li><li>.slideDown()、slideUp()、slideToggle();上下卷入卷出，用法同上。<br>重点来了</li><li>.==animate==(target,duration,easing,callback);动画({width:100},100,’swing(速率)’,function(){})(注：有内置队列，可以叠加.animate(),不是必须用回调）</li><li>.is(‘:animated’);判断是否在执行动画</li><li>.stop();让元素运动停止。(注：默认阻止当前运动，若有多个运动，则执行下一个运动。传 true，所有运动停止。传 true,true，停止运动，并直接跳到当前运动的目标点)</li><li>.finish();直接跳到最终目标点</li><li>==delay==(1000);延迟 xx 毫秒</li><li>jQuery.fx.off=true;所有运动的开关（小知识）<br></li></ul><h1 id="队列方法，先进先出"><a href="#队列方法，先进先出" class="headerlink" title="队列方法，先进先出"></a>队列方法，先进先出</h1><ul><li>.queue(‘chain’,function(){});入队方法。（注：function 可以传 next 参数并在函数最后调用 next() ，这样就会执行完当前函数时再去执行下一个队列里的函数。</li><li>.dequeue(‘chain’);出队方法,执行并出队;</li><li>.clearQueue();清空队列方法。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var FUNC&#x3D;[</span><br><span class="line">    function() &#123;$(&quot;#block1&quot;).animate(&#123;left:&quot;+&#x3D;100&quot;&#125;,aniCB);&#125;,</span><br><span class="line">    function() &#123;$(&quot;#block2&quot;).animate(&#123;left:&quot;+&#x3D;100&quot;&#125;,aniCB);&#125;,</span><br><span class="line">    function() &#123;$(&quot;#block1&quot;).animate(&#123;left:&quot;+&#x3D;100&quot;&#125;,aniCB);&#125;,</span><br><span class="line">    function() &#123;$(&quot;#block2&quot;).animate(&#123;left:&quot;+&#x3D;100&quot;&#125;,aniCB);&#125;,</span><br><span class="line">    function() &#123;$(&quot;#block1&quot;).animate(&#123;left:&quot;+&#x3D;100&quot;&#125;,aniCB);&#125;,</span><br><span class="line">    function()&#123;alert(&quot;动画结束&quot;)&#125;</span><br><span class="line">];</span><br><span class="line">var aniCB&#x3D;function() &#123;</span><br><span class="line">    $(document).dequeue(&quot;myAnimation&quot;);</span><br><span class="line">&#125;</span><br><span class="line">$(document).queue(&quot;myAnimation&quot;,FUNC);</span><br><span class="line">aniCB();</span><br><span class="line">1，我首先建议建立了一个函数数组，里边是一些列需要依次执行的动画</span><br><span class="line">2，然后我定义了一个回调函数，用dequeue方法用来执行队列中的下一个函数</span><br><span class="line">3，接着把这个函数数组放到document上的myAnimation的队列中（可以选择任何元素，我只是为了方便而把这个队列放在document上）</span><br><span class="line">4，最后我开始执行队列中的第一个函数</span><br><span class="line">5，小知识点：$(document).clearQueue();清空栈也可以通过将函数数组换成[]来实现。</span><br></pre></td></tr></table></figure><h2 id="位置图形"><a href="#位置图形" class="headerlink" title="位置图形"></a>位置图形</h2><ul><li>.offset();到文档边框的距离。{left:10,top:10}（注：可以取赋值，都是对象赋值{…};</li><li>.position();到有定位父级边框的距离。（注：不可赋值）</li><li>.scrollTop() .scrollLeft() 滚动条距离。（注：可以取赋值）</li><li>.width() .height();获取元素 content 区域宽高（注：数值）</li><li>.innerWidth() .innerHeight(); content + padding</li><li>.outerWidth() .outerHeight(); content + padding + border + margin (全部宽高)</li><li>.==each==(function(index,ele));把选中的一堆元素放到函数里面去执行。 (注：ele 为原生元素，效率非常高)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(&#39;li&#39;).each(function(index,ele)&#123;</span><br><span class="line">    $(ele).text(index).add(&#39;demo&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>.index();获取在兄弟元素间的索引值。（注：加参数可进行过滤，加元素直接返回所在索引）</li></ul><h2 id="jQuery-工具方法"><a href="#jQuery-工具方法" class="headerlink" title="jQuery 工具方法"></a>jQuery 工具方法</h2><ul><li>$.==type==(); 返回元素类型。（注：可以判断 null,数组，date 等类型）</li><li>$.isArray()/isFunction/isWindow;判断是否是数组/function/window</li><li>$.trim();去掉前后的空格。</li><li>$.proxy();改变 this 指向，类似 bind。<ul><li>var newFn=$.proxy(fn,obj);不改变原来函数的 this 指向，复制一个新的函数，this 指向改变成 obj.</li><li>简单来说就是用别人的方法，改成自己的 this，供自己来使用。</li></ul></li><li>$.noConflict();防止冲突，防止变量命名冲突($)。var $c=$.onConflict();从此$c就变成了$，可以当作$使用。</li><li>$.each(arr,function(index,ele){}); 和 forEach 作用相同。</li><li>$.map(arr,function(index,ele){return ele*index});不改变原数组，返回新的数组。</li><li>$.parseJSON();和原生 JSON.parse()相同。</li><li>$.==makeArray==(obj);可以类数组转数组。(注：第一个参数传数据，第二个参数为类数组，则将前面数据添加到类数组，若第二个参数为数组，则将前面数据添加到数组)</li></ul><h2 id="插件扩展（工具方法）"><a href="#插件扩展（工具方法）" class="headerlink" title="插件扩展（工具方法）"></a>插件扩展（工具方法）</h2><ul><li>$.extend({xx:function(){},xx:function(){});<ul><li>用法 1：往 jQuery 工具方法里面加功能函数。调用$.xxx();</li><li>用法 2：$.extend(obj1,obj2,..);把从第二个参数往后的属性全部放电管 obj1 里面，注意是浅层克隆，引用值都是一个。</li><li>用法 3：$.extend(true,obj1,obj2);用法同上，深度克隆，引用值都克隆过来。</li></ul></li><li>$.fn.extend();用法同上，往jQuery实例方法里面加功能函数。调用$(‘.demo’).drag();<br></li></ul><h2 id="两者区别"><a href="#两者区别" class="headerlink" title="两者区别"></a>两者区别</h2><p>$.extend相当于给jQuery对象加属性和方法。所以调用方法为：jQuery.func()<br>$.fn.extend：相当于在 jQuery 原型链上加方法。<br>$.fn==jquery.prototype，所以调用方法为$(‘demo’).func()</p><h2 id="插件扩展实战经验"><a href="#插件扩展实战经验" class="headerlink" title="插件扩展实战经验"></a>插件扩展实战经验</h2><ul><li>封装插件</li></ul><ol><li>封装插件一般用立即执行函数，节省资源。</li><li>在立即执行函数里面给$.fn 加函数，形成闭包。外界依然可以调用。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(function($)&#123;</span><br><span class="line">    $.fn.extend(&#123;</span><br><span class="line">        &quot;tool&quot;:function()&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;(jQuery))</span><br></pre></td></tr></table></figure><ul><li>$(function(){})的意义。</li></ul><ol><li>$(function(){})==$(document).ready(function(){})</li><li>意思是在 document 页面解析完成后执行，比 load 快。</li></ol><h1 id="jQuery-工具方法-高级方法"><a href="#jQuery-工具方法-高级方法" class="headerlink" title="jQuery 工具方法-高级方法"></a>jQuery 工具方法-高级方法</h1><h2 id="ajax"><a href="#ajax" class="headerlink" title="$.ajax();"></a>$.ajax();</h2><p>属性：</p><ul><li>url:’https://…’</li><li>type:请求方式</li><li>data:{}参数信息</li><li>dataType:’json’ 想要得到的数据格式（默认字符串）<ul><li>‘jsonp’ 跨域，如果是 jsonp 格式，则用不到下面的回调，会用在外部设置的回调</li></ul></li><li>contentType:’’ 数据在传递的过程当中数据的编码格式<ul><li>‘application/x-www-form-urlencoded’（默认，key=value&amp;key1=value1）</li><li>‘application/json’ （格式为 json 格式字符串）</li></ul></li><li>async:true/false 是否异步</li><li>beforeSend:function(xhr,data){} 数据发出之前的拦截器，return true/ false;校验所传数据（传递对象，传递数据）</li><li>success:function(){}请求成功后的处理函数。</li><li>error:function(e){} 请求失败后的处理函数<ul><li>e.status 状态码</li><li>e.statusText 错误提示 （注：后面不太常用）</li></ul></li><li>complete:function(){} 请求完成的处理函数 最后执行。</li><li>context:$(‘.wrapper’) 改变函数上下文</li><li>timeout:800 超过 800 毫秒就不请求了。</li></ul><p>==注意：==<br>不起服务直接用 ajax 请求本地文件也会出现跨域问题</p><p>因为直接打开域名为空，浏览器认为两个空域名是不想等的，也就不是同源地址</p><h1 id="同源请求"><a href="#同源请求" class="headerlink" title="同源请求"></a>同源请求</h1><p>ajax 使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    url:<span class="string">&#x27;https://......&#x27;</span>,</span><br><span class="line">    type:<span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">    dataType:<span class="string">&#x27;json&#x27;</span>,</span><br><span class="line">    success: <span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">        $.each(res.data,<span class="function"><span class="keyword">function</span>(<span class="params">index,ele</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(ele);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    error:<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(e.status,e.statusText);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">返回数据</span><br><span class="line"><span class="built_in">Object</span></span><br><span class="line">code:<span class="number">0</span></span><br><span class="line">data:[&#123;...&#125;,&#123;...&#125;]</span><br><span class="line">msg:<span class="string">&#x27;OK&#x27;</span></span><br><span class="line">__proto__:<span class="built_in">Object</span></span><br></pre></td></tr></table></figure><h1 id="跨域请求-jsonp"><a href="#跨域请求-jsonp" class="headerlink" title="跨域请求 jsonp"></a>跨域请求 jsonp</h1><p>jsonp 全称 ：json and padding 数据和包裹层<br>跨域请求原理：</p><p>在做 ajax 请求的时候，浏览器会有个安全机制，叫同源策略。</p><p>同源策略：只有同源地址，数据才可以进行交互，如果不是同源地址就，就会出现跨域的问题。</p><p>jq 中出现了一种叫 jsonp 的跨域解决方案。</p><p>jsonp 这种方式不是通过 ajax 去请求数据，而是通过动态的去一个 script 标签去请求数据。</p><p>script 标签的请求不会受到同源策略的限制</p><p>所以 jsonp 就是把数据放在 script 标签里面，但是直接放在 script 标签中是获取不到数据的</p><p>所以后台需要将数据包裹在一个对象中，然后前端需要创建一个函数来接收这个对象</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var oScript &#x3D; document.createElement(&#39;script&#39;);</span><br><span class="line">oScript.src&#x3D;&quot;.&#x2F;text.txt?callback&#x3D;aa&quot;</span><br></pre></td></tr></table></figure></code></pre><p>这个函数名作为一个请求参数传递给后台，后台拿到这个函数名后进行一个拼接，把数据对象拼接都函数里面：函数名({……})</p><p>这个时候 script 标签中就有了数据</p><p>将 script 标签插入到页面中，就可以拿到数据了。</p><p>一定要有所传递的函数，来接收数据，并且此函数放在全局。</p><p>jq 跨域请求使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        type: <span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">        url: <span class="string">&#x27;https://suggest.taobao.com/sug&#x27;</span>,</span><br><span class="line">        <span class="comment">// https://suggest.taobao.com/sug?code=utf-8&amp;q=x&amp;callback=jsonp533&amp;k=1&amp;area=c2c&amp;bucketid=18</span></span><br><span class="line">        data: &#123; <span class="comment">//jq中？后面的请求数据可以放在data中</span></span><br><span class="line">            callback: <span class="string">&#x27;aa&#x27;</span> <span class="comment">//属性名是由后台决定的，值是前端的回调函数</span></span><br><span class="line">        &#125;,</span><br><span class="line">        dataType: <span class="string">&#x27;jsonp&#x27;</span></span><br><span class="line">        <span class="comment">//另一种callback的写法，两种都可以</span></span><br><span class="line">        jsonp:<span class="string">&#x27;callback&#x27;</span>,</span><br><span class="line">        jsonpCallback:<span class="string">&#x27;aa&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//处理返回的数据</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">searchDataList</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Callbacks-回调管理者，异步编程离不开回调机制。"><a href="#Callbacks-回调管理者，异步编程离不开回调机制。" class="headerlink" title="$.==Callbacks==()回调管理者，异步编程离不开回调机制。"></a>$.==Callbacks==()回调管理者，异步编程离不开回调机制。</h2><p>作用：Callbacks 的作用就是把回调函数放在一起，当满足某种条件时，去调用 fire(),就会执行里面的回调函数。</p><ul><li>传参数’once’,回调只执行一次，执行完了就没有了。</li><li>传参数’memory’,具有记忆功能，如果没有这个参数，fire 时只执行 fire 前面 add 的回函数，加上这个属性后，在 fire 后面加的回调函数也会跟着一起执行。</li><li>传参数’unique’,去重</li><li>传参数’stopOnFalse’,遇到 return false;就不往下执行了。<br><img src="http://47.97.6.61/%E6%9C%89%E9%81%93%E4%BA%91%E5%9B%BE%E7%89%87/1.jpg" alt="回调机制"></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; callbacks</span><br><span class="line"> var cb &#x3D; $.Callbacks();</span><br><span class="line"></span><br><span class="line"> function a(x, y) &#123;</span><br><span class="line">     console.log(&#39;a&#39;, x, y);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> function b(x, y) &#123;</span><br><span class="line">     console.log(&#39;b&#39;, x, y);</span><br><span class="line"> &#125;</span><br><span class="line"> cb.add(a, b);</span><br><span class="line"></span><br><span class="line"> cb.fire(&#39;10&#39;, &#39;20&#39;);&#x2F;&#x2F; a 10 20  b 10 20</span><br></pre></td></tr></table></figure><pre><code>回调机制很好用——&gt;js单线程-&gt;异步编程优化体验 防止阻塞页面-&gt;回调函数运动函数  animate 当你满足某个状态 接下来要去做另外一件事。</code></pre><h1 id="小知识：使用多重-ajax-嵌套会导致回调地狱，危害多多。使用-Deferred-解决。"><a href="#小知识：使用多重-ajax-嵌套会导致回调地狱，危害多多。使用-Deferred-解决。" class="headerlink" title="小知识：使用多重$.ajax()嵌套会导致回调地狱，危害多多。使用$.Deferred()解决。"></a>小知识：使用多重$.ajax()嵌套会导致回调地狱，危害多多。使用$.Deferred()解决。</h1><h2 id="Deferred-有状态的回调。也叫延迟对象。"><a href="#Deferred-有状态的回调。也叫延迟对象。" class="headerlink" title="$.Deferred();有状态的回调。也叫延迟对象。"></a>$.Deferred();有状态的回调。也叫延迟对象。</h2><p>作用：回调成功了或者失败了或者未完成，都可以进行回调。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">延迟对象</span><br><span class="line">var df &#x3D; $.Deferred(); 返回一个延迟对象</span><br><span class="line">三种状态的回调函数，比如注册成功了，就会执行done的回调函数。</span><br><span class="line">               df.done() 成功 df.fail()失败 df.progress() 正在进行</span><br><span class="line">三种触发函数    df.resolve()   df.reject()   df.notify()</span><br><span class="line">注意：当成功或者失败的时候都会立即回调，正在执行时会回调然后继续执行异步的函数。</span><br><span class="line">df.promise();阉割版的延迟对象，只有状态没有触发，也就是说触发的函数只能在内部触发。</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F; 做一件异步的事情</span><br><span class="line">       function createScore() &#123;</span><br><span class="line">           var df &#x3D; $.Deferred();&#x2F;&#x2F;创建一个延迟对象</span><br><span class="line">           setInterval(function() &#123;</span><br><span class="line">               var score &#x3D; Math.random() * 100;</span><br><span class="line">               if (score &gt; 60) &#123;</span><br><span class="line">                   df.resolve(&#39;成功&#39;);</span><br><span class="line">               &#125; else if (score &lt; 40) &#123;</span><br><span class="line">                   df.reject(&#39;失败&#39;);</span><br><span class="line">               &#125; else &#123;</span><br><span class="line">                   df.notify(&#39;执行中&#39;);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;, 2000);</span><br><span class="line"></span><br><span class="line">           return df.promise();&#x2F;&#x2F; 返回阉割版延迟对象</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       var df &#x3D; createScore();</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F;延迟对象的回调函数</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F; 注册成功的回调函数</span><br><span class="line">       df.done(function(msg) &#123;</span><br><span class="line">               console.log(&#39; yes&#39; + msg)</span><br><span class="line">           &#125;)</span><br><span class="line">           &#x2F;&#x2F; 注册失败的回调函数</span><br><span class="line">       df.fail(function(msg) &#123;</span><br><span class="line">               console.log(&#39;no&#39; + msg)</span><br><span class="line">           &#125;)</span><br><span class="line">           &#x2F;&#x2F; 注册正在进行的回调函数</span><br><span class="line">       df.progress(function(msg) &#123;</span><br><span class="line">           console.log(&#39;emm..&#39; + msg)</span><br><span class="line">       &#125;)</span><br></pre></td></tr></table></figure><h2 id="Deferred-的核心方法-then-（注：then-翻译过来就是然后）"><a href="#Deferred-的核心方法-then-（注：then-翻译过来就是然后）" class="headerlink" title="$.Deferred()的核心方法.==then==();（注：then 翻译过来就是然后）"></a>$.Deferred()的核心方法.==then==();（注：then 翻译过来就是然后）</h2><p>.then()默认的三个参数就是 done,fail,progress，<br>可就是说<code>df.then(function()&#123;&#125;,function()&#123;&#125;,function()&#123;&#125;)</code>依次是上面三个。<br>作用：</p><ol><li>可以简化 回调函数的注册。</li><li>也可以做普通函数的传递。</li><li>可以把 ajax 的每一步行动都拆分出来，一件事一件事的处理。</li></ol><p>注意：如果回调函数中还有回调函数，需要新创建一个延迟对象并返回这个对象的阉割版，才能在后面继续.then。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"> &#x2F;&#x2F; 简化注册回调的写法</span><br><span class="line">       df.then(function() &#123;</span><br><span class="line">           console.log(&#39;done1&#39;);</span><br><span class="line">       &#125;, function() &#123;</span><br><span class="line">           console.log(&#39;fail1&#39;);</span><br><span class="line">       &#125;, function() &#123;</span><br><span class="line">           console.log(&#39;progress1&#39;);</span><br><span class="line">       &#125;)</span><br><span class="line">-------------------------------------------------</span><br><span class="line">&#x2F;&#x2F; 做一件异步的事情</span><br><span class="line">       function createScore() &#123;</span><br><span class="line">           var df &#x3D; $.Deferred();</span><br><span class="line">           setInterval(function() &#123;</span><br><span class="line">               var score &#x3D; Math.random() * 100;</span><br><span class="line">               if (score &gt; 60) &#123;</span><br><span class="line">                   df.resolve(&#39;恭喜你成功了&#39;);</span><br><span class="line">               &#125; else if (score &lt; 40) &#123;</span><br><span class="line">                   df.reject(&#39;很遗憾失败了\n&#39;);</span><br><span class="line">               &#125; else &#123;</span><br><span class="line">                   df.notify(&#39;淡定不要慌\n&#39;);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;, 2000);</span><br><span class="line">           &#x2F;&#x2F; done 成功 fail失败 progress 正在执行</span><br><span class="line">           &#x2F;&#x2F; promise()是一个阉割版的对象，只有注册，没有触发。</span><br><span class="line">           return df.promise();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       var df &#x3D; createScore();&#x2F;&#x2F;创建一个异步对象</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F;then简化注册回调函数，可以传</span><br><span class="line">       df.then(function(ms) &#123; &#x2F;&#x2F;请求成功执行这个</span><br><span class="line">           console.log(&#39;胜利&#39; + ms);</span><br><span class="line">           return &#39;ok&#39;;</span><br><span class="line">       &#125;, function(ms) &#123;</span><br><span class="line">           console.log(&#39;失败\n&#39; + ms);</span><br><span class="line">           return &#39;no\n&#39;</span><br><span class="line">       &#125;, function(ms) &#123;</span><br><span class="line">           console.log(&#39;没完事\n&#39; + ms);</span><br><span class="line">           return &#39;go on&#39;</span><br><span class="line">       &#125;)</span><br><span class="line">       .then(function(param) &#123; &#x2F;&#x2F;done,fail,progress</span><br><span class="line">           console.log(&#39;我胜利了&#39; + param);</span><br><span class="line">       &#125;, function(param) &#123;</span><br><span class="line">           console.log(&#39;我失败了&#39; + param);</span><br><span class="line">       &#125;, function(param) &#123;</span><br><span class="line">           console.log(&#39;我还不知道成绩&#39; + param);</span><br><span class="line">       &#125;)</span><br></pre></td></tr></table></figure><h2 id="when"><a href="#when" class="headerlink" title="$.when()"></a>$.when()</h2><p>（翻译：当）$.when(df1,df2,df3).then(function(){},function(){});</p><ol><li>可以传一到多个延迟对象。</li><li>返回值是 promise 对象。</li><li>然后就可以.then(){function(){}…};</li></ol><p>怎么用：<br>当 when 里面的延迟对象全部成功时触发 done(第一个)回调函数,有一个失败就会触发 fail（第二个）<br>什么时候使用呢，比如请求多个 Ajax 请求，统一处理数据时可以用到。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 前端 </tag>
            
            <tag> jQuery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络基础知识</title>
      <link href="2020/10/01/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>2020/10/01/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="互联网"><a href="#互联网" class="headerlink" title="互联网"></a>互联网</h1><p>互联网——Internet（音译：因特网、英特网），学名：网际网路</p><h1 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h1><p>1989 年，欧洲粒子物理实验所——协议（格式）<br>WWW (World Wide Web)</p><a id="more"></a><h1 id="必会基础"><a href="#必会基础" class="headerlink" title="必会基础"></a>必会基础</h1><p>计算机包含电脑。不是相等关系<br>台式机、笔记本——&gt;计算机<br>手机、平板、智能手表、智能音箱..——&gt;冯诺依曼式计算机<br>小知识：图灵是计算机科学之父（理论）</p><h2 id="冯诺依曼式计算机五大组成部分"><a href="#冯诺依曼式计算机五大组成部分" class="headerlink" title="冯诺依曼式计算机五大组成部分"></a>冯诺依曼式计算机五大组成部分</h2><ul><li>冯诺依曼式计算机——冯诺依曼（计算机之父）</li><li>运算器:<br>CPU（中央处理器）：主要用来做逻辑运算，整数运算。<br>GPU（显卡）：做浮点数运算，精确运算。</li><li>存储器：<br>内存（断电数据清空, 读写速度快）， 硬盘（辅存）：（数据可以持久化，读写速度，相对较慢）</li><li>控制器：主板上的⼀一些器器件</li><li>输⼊设备：键盘，鼠标，⻨克风，⽹网⼝</li><li>输出设备：显示器，耳机，⽹口</li></ul><h2 id="IP-地址"><a href="#IP-地址" class="headerlink" title="IP 地址"></a>IP 地址</h2><p><strong>IP 地址的格式</strong>：<br>IP 地址分为四个段：<br>xxx.xxx.xxx.xxx，每个段 0~255，每个段，都是由 8 个 0、1 组成的。<br><strong>IP 地址的分类</strong>：<br>一个 IP 地址分为两个部分：⽹络 ID，主机 ID</p><p>A 类：0.0.0.0 ~ 127.255.255.255（⼀一个⽹网络能有 1600+万台）<br>B 类：128.0.0.0 ~ 191.255.255.255（172.16.0.0 ~ 172.31.255.255）<br>C 类：192.0.0.0 ~ 223.255.255.255（192.168.xxx.xxx）<br>D 类：（多播地址）<br>E 类：</p><h2 id="域名与-DNS-解析"><a href="#域名与-DNS-解析" class="headerlink" title="域名与 DNS 解析"></a>域名与 DNS 解析</h2><p><a href="http://www.baidu.com-&gt;域名/">www.baidu.com-&gt;域名</a><br>问：能通过域名直接访问到⼀台机器吗？<br>答：不可以的。只能访问一个 ip 地址，而不是某台机器</p><p>域名和 IP 形成对应关系。</p><p>首先，计算机是不不知道域名对应的 IP 的。 问路由器，如果路由器认识这个域名，就返回⼀个 IP，然后计算机访问这个 IP。</p><p>如果路由器不认识，他就问上⼀层路由器。 如果问到了城市这个级别的路由器还没有，就会问城市级 DNS 服务器。</p><p>如果 DNS 服务器不认识这个域名，继续向上级 DNS 服务器查找。 互联网建立的时候，13 台总的 DNS 服务器。</p><h2 id="当向浏览器的地址栏中输⼊一个-url-按回车之后，⽹络中都会发⽣生什么？"><a href="#当向浏览器的地址栏中输⼊一个-url-按回车之后，⽹络中都会发⽣生什么？" class="headerlink" title="当向浏览器的地址栏中输⼊一个 url 按回车之后，⽹络中都会发⽣生什么？"></a>当向浏览器的地址栏中输⼊一个 url 按回车之后，⽹络中都会发⽣生什么？</h2><p>如果输⼊的是域名：123.xyz<br>则会先去域名所映射的 ip 地址。</p><p>看浏览器器的缓存。没有继续往下找<br>本机 host。 C:windows/system32/drivers/etc/host<br>127.0.0.1 localhost （代表本机 ip）<br>0.0.0.0（代表不知道域名，然后默认访问本机 ip）<br>家里路由器 上级路由、城市的 LDNS 服务器 +<br>继续向上级的 DNS 服务器找。<br>gDNS 服务器。</p><p>找到映射后返回浏览器，然后再重新访问这个 ip 地址</p><h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><p><strong>三次握手：（建立连接的过程）</strong>：为了确定客户端和服务器端均有接收和发送信息的能力 1. 我要给你写情书了 你能收到吗 （确定客户端有发送信息的能力） 2. 我知道你要给我写情书了 我能收到 （确定服务器端有接收和发送信息的能力） 3. 我知道你能收到信息了 我也能收到信息 那我现在开始发给你我的心意<br><strong>四次挥手： （断开连接）</strong> 1. 客户端向服务器端发出 我这边的情书已经发完了 我要断开了 2. 服务器端向客户端发出 我知道你已经发完了 但是我这边还没有接收完 也没有给你写完回信 3. 服务器端向客户端发出 我这边已经写完回信并发完了 可以断开了 4. 客户端向服务器端发出 我知道你已经发送完了 我断开了</p><h2 id="五层网络模型"><a href="#五层网络模型" class="headerlink" title="五层网络模型"></a>五层网络模型</h2><p><img src="http://47.97.6.61/%E6%9C%89%E9%81%93%E4%BA%91%E5%9B%BE%E7%89%87/1%20(2).png" alt="五层网络模型"></p><h2 id="HTTP-协议-两个部分"><a href="#HTTP-协议-两个部分" class="headerlink" title="HTTP 协议-两个部分"></a>HTTP 协议-两个部分</h2><p><strong>请求</strong>：Request<br><strong>响应</strong>：Response</p><p>请求：请求头+数据体<br>http 请求源码：请求方式 路径 协议版本<br>请求方式：get，post…</p><p><strong>发送一个请求</strong>:<br>TCP/IP 协议（对方的 IP，自己的 IP，对方的端口）HTTP 协议（请求头）hello<br><img src="http://47.97.6.61/%E6%9C%89%E9%81%93%E4%BA%91%E5%9B%BE%E7%89%87/2%20(2).png" alt="五层网络模型"></p><p><strong>响应：</strong> 响应头+数据体<br>协议版本 状态码 message</p><h2 id="GET-和-POST-的区别"><a href="#GET-和-POST-的区别" class="headerlink" title="GET 和 POST 的区别"></a>GET 和 POST 的区别</h2><ol><li>是基于什么前提的?如果什么前提都没有，不使用任何规范，只考虑语法和理论上的 HTTP 协议。</li></ol><ul><li>GET 和 POST 几乎没有什么区别，只有名字不一样。</li></ul><ol start="2"><li>如果是基于 RFC 规范的。</li></ol><ul><li>理论上的(Specification) : GET 和 POST 具有相同语法的，但是有不同的语义。get 是用来获取数据的，post 是用来发送数据的，其他方面没有区别。;</li><li>实现上的(Implementation) :各种浏览器，就是这个规范的实现者。</li></ul><ol start="3"><li>常见的那些不同:</li></ol><ul><li>GET 的数据在 URL 是可见的。POST 请求不显示在 URL 中。2) GET 对长度是有限制的，POST 长度是无限的。</li><li>GET 请求的数据可以收藏为书签，post 请求 到的数据不可收藏为书签。</li><li>GET 请求后，按后退按钮、刷新按钮无影响，post 数据会被重新提交。</li><li>GET 编码类型: aplication/x-ww-form-url, post 的编码类型: 有很多种。encodeapplication/x-www-form-urlencoded、multipart/form-data</li><li>GET 历史参数会被保留在浏览器里，psot 不会保存在浏览器中的。</li><li>GET 只允许 ASCII.post 没有编码限制，允许发二进制的。</li><li>GET 与 POST 相比，GET 安全性较差，因为所发的数据是 URL 的部分。</li></ul><h2 id="Cookie-和-Sesstion-的区别"><a href="#Cookie-和-Sesstion-的区别" class="headerlink" title="Cookie 和 Sesstion 的区别"></a>Cookie 和 Sesstion 的区别</h2><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><ol><li>如果我们用 JS 的变量来存数据，那么在页面关闭的时候，数据就消失了。</li><li>保持登录状态是怎么做到的呢?</li></ol><ul><li>按照正常的 HTTP 协议来说，是做不到的。因为 HTTP 协议，上下文无关协议。</li></ul><ol start="3"><li>所以说前端页面上，有可以持久化存储数据的东西。一旦登录成功，我就记载在这个里面。</li></ol><p><strong>Cookie 是有限制的。</strong></p><p>Cookie 是存在浏览器里的，不是存在某个页面上的。是可以长期存储的。Cookie 即使是保存在浏览器里，也是存放在不同的域名下的。</p><ol><li><p>初始状态:没有登录</p></li><li><p>访问百度的登录，输入用户名，密码。</p></li><li><p>如果用户名和密码是正确的。百度的后端会向这个域名下，设置一个 Cookie。写入用户的基本信息! (加密的) .</p></li><li><p>以后每一次向百度发送请求，浏览器都会自动带上这些 Cookie,</p></li><li><p>服务端(后端)看到了带有 ID 的 cookie,就可以解析这个加密的 ID,来获取到这个用户本身的 ID，</p></li><li><p>如果能获取到本身的 ID,那么就证明这个用户已经登录过了。所以后端可以继续保留用户的信息。</p></li></ol><p>缺点:如果某个坏人，复制了我浏览器里的 cookie,他就可以在他的电脑上登录我的账号了。</p><h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><p>和 cookie 的区别：登录信息存在服务器端。</p><p>缺点：如果用户量非常大，上亿的用户，在用户量很大的时候，服务器端会很耗资源。</p><p>原因：因为后端可能不止一台服务器，用户的登录信息，一般只存在一台服务器上，因为用户的登录操作，在哪台机器上执行的，就一般存在那台机器上，需要通过反向代理。（轮询，IP 哈希等）</p><h3 id="B-S-结构-C-S-结构"><a href="#B-S-结构-C-S-结构" class="headerlink" title="B/S 结构 C/S 结构"></a>B/S 结构 C/S 结构</h3><p>B/S 结构指：web 页面和服务器。</p><p>C/S 结构指：app 和服务器</p><h3 id="发送网络请求几种方式"><a href="#发送网络请求几种方式" class="headerlink" title="发送网络请求几种方式"></a>发送网络请求几种方式</h3><ol><li>在浏览器中直接输入网址（无法用代码控制）</li><li>location.href=”url”,可以发出网络请求，但是页面会发生跳转。(页面会跳转)</li><li>带有 src 属性的标签。请求是可以发出的，服务端是可以处理的也是可以返回的。但是返回之后，能否被应用，还要看浏览器。(页面无法处理返回结果)</li><li>带有 href 属性的标签。请求是可以发出的，服务端是可以处理的也是可以返回的。但是返回之后，能否被应用，还要看浏览器。（页面无法处理返回结果）</li><li>带有 action 属性的标签。例如 form 表单，也可以向后端发出请求// 希望有一种方式，可以用代码控制，页面不会跳转，服务端返回的结果我可以用 js 继续处理。</li><li>ajax（页面不跳转，可以用代码控制，但是不支持跨域，上面都支持跨域）</li></ol><h3 id="跨越"><a href="#跨越" class="headerlink" title="跨越"></a>跨越</h3><p><strong>定义：协议、域名、端口号，有一个不同就算跨域。</strong></p><p><strong>允许跨域的资源：</strong>.js .css .jpg 等。src 属性的资源都是可以被跨域请求的。href 属性的资源大部分都是可以被跨域请求的。</p><p><strong>不被允许跨域的资源：</strong></p><ol><li>后端接口的数据。</li><li>其他域的 cookie。</li><li>其他域的缓存。</li></ol><p><strong>跨域这个行为，发生在哪里?</strong></p><ol><li>即使跨域了(协议，域名，端口号有不一-样的)，请求也可以发出</li><li>务器端也是可以接收的。</li><li>服务器端也是可以正常处理的。</li><li>服务器端也是可以正常返回据。</li><li>浏览器也能接收到这些数据。</li><li>接收到之后，发现当前页面的域和请求的域不同，所以判定为域。</li><li>我们的代码在这等着结果呢，但是因为浏览器判定跨域了，不会结传递给我们的代码。</li></ol><p><strong>虽然跨域了,但是我们依然需要这个数据，怎么解决?</strong></p><ol><li>后端(别人家的)配合我们进行跨域。<br>pan.baidu.com ——&gt; zhidao.baidu.com</li></ol><ul><li>JSONP （正常的情况，返回的数据都是 JSON 格式。JSONP 是一种特殊的格式。）</li><li>后端设置 Access-Control-Allow-Origin 属性支持域。</li></ul><ol start="2"><li>后端不配合我们进行跨域。</li></ol><ul><li>iframe (只能显示，不能控制)</li><li>通过后端代理(自己的后端)</li></ul><h3 id="原生-js-发送-ajax"><a href="#原生-js-发送-ajax" class="headerlink" title="原生 js 发送 ajax"></a>原生 js 发送 ajax</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">       &#x2F;&#x2F;前提：后端设置Access-Control-Allow-Origin属性以支持跨域</span><br><span class="line">       var xhr &#x3D; null;</span><br><span class="line">       if (window.XMLHttpRequest) &#123;</span><br><span class="line">           xhr &#x3D; new XMLHttpRequest();</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           xhr &#x3D; new ActiveXObject(&#39;Microsoft.XMLHttp&#39;);</span><br><span class="line">       &#125;</span><br><span class="line">       console.log(xhr.readyState); &#x2F;&#x2F;未请求时状态为0,代表请求的状态码。</span><br><span class="line">       xhr.open(&quot;get&quot;, &quot;http:&#x2F;&#x2F;developer.duyiedu.com&#x2F;edu&#x2F;testAjaxCrossOrigin&quot;); &#x2F;&#x2F;初始化一个请求,第三个参数代表是否异步，默认为true</span><br><span class="line">       console.log(xhr.readyState); &#x2F;&#x2F;请求后状态变为1</span><br><span class="line">       &#x2F;&#x2F; 当状态变化时触发</span><br><span class="line">       xhr.onreadystatechange &#x3D; function() &#123;</span><br><span class="line">           &#x2F;&#x2F;readyState &#x3D;&#x3D; 4表示请求完成，已经接收到数据。</span><br><span class="line">           &#x2F;&#x2F;status &#x3D;&#x3D; 200  网络请求，结果都会有一个状态码。来表示这个请求是否正常</span><br><span class="line">           &#x2F;&#x2F;200表示请求成功</span><br><span class="line">           &#x2F;&#x2F; http状态码</span><br><span class="line">           &#x2F;&#x2F;2**表示成功</span><br><span class="line">           &#x2F;&#x2F;3**表示重定向</span><br><span class="line">           &#x2F;&#x2F;4**表示客户端错误,404页面没找到。</span><br><span class="line">           &#x2F;&#x2F;5**表示服务端错误</span><br><span class="line">           if (xhr.readyState &#x3D;&#x3D; 4 &amp;&amp; xhr.status &#x3D;&#x3D; 200) &#123;</span><br><span class="line">               var data &#x3D; JSON.parse(xhr.responseText); &#x2F;&#x2F;请求的响应</span><br><span class="line">               console.log(data);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       xhr.send(); &#x2F;&#x2F;发送http请求</span><br><span class="line">   &lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h3 id="JSONP-的使用和原理"><a href="#JSONP-的使用和原理" class="headerlink" title="JSONP 的使用和原理"></a>JSONP 的使用和原理</h3><ul><li>jsonp 跨域，只能使用 get 方法，如果我们设置的是 post 方法，jquery 会自动转为 get 方法。</li><li>是不是在 jsonp 里面我只能使用 get 方法？是不是我设置的 post 方法都会转为 get 方法？不是。</li><li>jquery 会先判断是否同源，如果同源，那么设置的是 get 就是 get，设置的 post 就是 post。如果不是同源，无论设置的什么，都改为 get。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    &#x2F;&#x2F;jsonp格式哪里特殊？</span><br><span class="line">    &#x2F;&#x2F;发送的时候，会带上一个参数callback</span><br><span class="line">    &#x2F;&#x2F;返回的结果不是json</span><br><span class="line">    &#x2F;&#x2F;callback的名 + ( + json + );</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        url: &quot;http:&#x2F;&#x2F;developer.duyiedu.com&#x2F;edu&#x2F;testJsonp&quot;,</span><br><span class="line">        type: &quot;post&quot;,</span><br><span class="line">        dataType: &quot;jsonp&quot;,</span><br><span class="line">        success: function (data) &#123;</span><br><span class="line">            console.log(data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p><strong>原理：</strong></p><ol><li>script 标签，有 src 属性，所以可以发出网络请求</li><li>script 标签，虽然可以引用其他域的资源，浏览器不限制。</li><li>但是，浏览器会将返回的内容，作为 js 代码执行。</li><li>fn({“status”:”ok”,”msg”:”Hello! There is DuYi education!”})相当于调用了 fn 函数，传入了一个 json 对象作为参数。</li></ol><p><strong>JSONP 过程：</strong></p><ol><li>判断请求与当前页面的域，是否同源，如果同源则发送正常的 ajax，就没有跨域的事情了。</li><li>如果不同源，生成一个 script 标签</li><li>生成一个随机的 callback 名字，还得创建一个名为这个的方法。</li><li>设置 script 标签的 src，设置为要请求的接口。</li><li>将 callback 作为参数拼接在后面。</li></ol><p>以上是前端部分</p><ol start="6"><li>后端接收到请求后，开始准备要返回的数据</li><li>后端拼接数据，将要返回的数据用 callback 的值和括号包裹起来<br>例如：callback=asd123456，要返回的数据为{“a “b”:2},<br>就要拼接为：asd123456({“a”:1, “b”:2});</li><li>将内容返回。</li></ol><p>以上是后端部分</p><ol start="9"><li>浏览器接收到内容，会当做 js 代码来执行。</li><li>从而执行名为 asd123456 的方法。这样我们就接收到了后端返回给我们的对象。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">        <span class="keyword">var</span> $ = &#123;</span><br><span class="line">            ajax: <span class="function"><span class="keyword">function</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">var</span> url = options.url;</span><br><span class="line">                <span class="keyword">var</span> type = options.type;</span><br><span class="line">                <span class="keyword">var</span> dataType = options.dataType;</span><br><span class="line">                <span class="comment">//判断是否同源（协议，域名，端口号）</span></span><br><span class="line">                <span class="comment">//获取目标url的域</span></span><br><span class="line">                <span class="keyword">var</span> targetProtocol = <span class="string">&quot;&quot;</span>; <span class="comment">//目标接口的协议</span></span><br><span class="line">                <span class="keyword">var</span> targetHost = <span class="string">&quot;&quot;</span>; <span class="comment">//目标接口的host，host是包涵域名和端口的</span></span><br><span class="line">                <span class="comment">//如果url不带http，那么访问的一定是相对路径，相对路径一定是同源的。</span></span><br><span class="line">              <span class="keyword">if</span> (url.indexOf(<span class="string">&quot;http://&quot;</span>) == <span class="number">0</span> || url.indexOf(<span class="string">&quot;https://&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">var</span> targetUrl = <span class="keyword">new</span> URL(url);</span><br><span class="line">                    targetProtocol = targetUrl.protocol;</span><br><span class="line">                    targetHost = targetUrl.host;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    targetProtocol = location.protocol;</span><br><span class="line">                    targetHost = location.host;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//首先判断是否为jsonp，因为不是jsonp不用做其他的判断，直接发送ajax</span></span><br><span class="line">                <span class="keyword">if</span> (dataType == <span class="string">&quot;jsonp&quot;</span>) &#123;</span><br><span class="line">                    <span class="comment">//要看是否同源</span></span><br><span class="line">                    <span class="keyword">if</span> (location.protocol == targetProtocol &amp;&amp; location.host == targetHost) &#123; <span class="comment">//表示同源</span></span><br><span class="line">                        <span class="comment">//此处省略。因为同源，jsonp会当做普通的ajax做请求</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123; <span class="comment">//不同源，跨域</span></span><br><span class="line">                        <span class="comment">//随机生成一个callback</span></span><br><span class="line">                        <span class="keyword">var</span> callback = <span class="string">&quot;cb&quot;</span> + <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">1000000</span>);</span><br><span class="line">                        <span class="comment">//给window上添加一个方法</span></span><br><span class="line">                        <span class="built_in">window</span>[callback] = options.success;</span><br><span class="line">                        <span class="comment">//生成script标签。</span></span><br><span class="line">                        <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">&quot;script&quot;</span>);</span><br><span class="line">                        <span class="keyword">if</span> (url.indexOf(<span class="string">&quot;?&quot;</span>) &gt; <span class="number">0</span>) &#123; <span class="comment">//表示已经有参数了</span></span><br><span class="line">                            script.src = url + <span class="string">&quot;&amp;callback=&quot;</span> + callback;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123; <span class="comment">//表示没有参数</span></span><br><span class="line">                            script.src = url + <span class="string">&quot;?callback=&quot;</span> + callback;</span><br><span class="line">                        &#125;</span><br><span class="line">                        script.id = callback;</span><br><span class="line">                        <span class="built_in">document</span>.head.appendChild(script);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// function cb(res)&#123;console.log(res)&#125;</span></span><br><span class="line">        <span class="comment">//http://developer.duyiedu.com/edu/testJsonp?callback=cb</span></span><br><span class="line"></span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            url: <span class="string">&quot;http://developer.duyiedu.com/edu/testJsonp&quot;</span>,</span><br><span class="line">            type: <span class="string">&quot;get&quot;</span>,</span><br><span class="line">            dataType: <span class="string">&quot;jsonp&quot;</span>,</span><br><span class="line">            success: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="json-和-jsonp-的区别？"><a href="#json-和-jsonp-的区别？" class="headerlink" title="json 和 jsonp 的区别？"></a>json 和 jsonp 的区别？</h3><p>简单的说 JSON 是一种数据交换格式，而 JSONP 是一种非官方跨域数据交互协议。 JSON 是“暗号”，而 JSONP 则是接头方式。 一个是描述信息的格式，一个是信息传递双方约定的方法。</p><h2 id="跨域详解"><a href="#跨域详解" class="headerlink" title="跨域详解"></a>跨域详解</h2><p>产生原因：浏览器的同源策略</p><p>同源策略：协议域名端口号均相同才能进行正常的数据交互</p><p>ajax 会受到同源策略的限制</p><p><strong>客户端和服务器端的跨域：</strong></p><ol><li>JSONP</li></ol><ul><li>用 script 标签来获取数据<code>&lt;script src=&quot;http://……&quot;&gt;&lt;/script&gt;</code>。</li><li>script 标签的 src 属性，引入外部文件时，不管访问的文件是什么后缀名，都当作 js 的文件来执行。</li><li>应用条件：需要后台配合，设置好回调函数与返回的对象进行对应</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function aa(res)&#123;……&#125;</span><br><span class="line">src&#x3D;&quot;http:&#x2F;&#x2F;……?callback&#x3D;aa&quot;</span><br></pre></td></tr></table></figure><ol start="2"><li>服务器端代理</li></ol><ul><li>简述：客户端发送给同源的服务器，服务器去请求不同源的服务器，在通过同源服务器返回给客户端</li><li>服务器代理：ngix webpack&gt;devServer</li></ul><ol start="3"><li>CORS 跨域：cross origin resource sharing 跨域资源共享</li></ol><ul><li>简述：本身是跨域资源，但可以通过服务器给指定客户端通道</li><li>简单请求：<ol><li>请求方式只能是 get，post，head</li><li>请求头字段只能设置：<ul><li>Access</li><li>Access-Language</li><li>Content-Type:的值只能是：<ol><li>application/x-www-form-urlencoded</li><li>mutipart/form-data</li><li>text/plain</li></ol></li><li>服务器端只关心第一个设置</li></ul></li></ol></li><li>非简单请求<ul><li>不满足简单请求就是非简单请求</li></ul></li><li>服务器端设置<ul><li>Access-Control-Allow-Origin:”<a href="http://127.0.0.1:5500&quot;，允许前端xxx进行跨域请求（如果让所有域都可以访问改为*）">http://127.0.0.1:5500&quot;，允许前端xxx进行跨域请求（如果让所有域都可以访问改为*）</a></li><li>Access-Control-Allow-Headers:”Content-Type”,允许前端发送 Content-Type 的请求头</li><li>Access-Control-Allow-Methods:”PUT”，允许前端进行 PUT 请求方式</li></ul></li></ul><p><strong>客户端和客户端的跨域（iframe 之间的跨域）：</strong></p><p>父窗口获取子窗口数据（过时了）：</p><ol><li>在一个窗口中，设置了 window.name 属性后，切换页面，name 属性还会存在</li><li>子窗口将数据设置在 window.name 上</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;子窗口</span><br><span class="line">let obj&#x3D;&#123;……&#125;</span><br><span class="line">window.name &#x3D; JSON.stringify(obj)&#x2F;&#x2F;转成字符串</span><br><span class="line">&#x2F;&#x2F;父窗口</span><br><span class="line">&lt;iframe src&#x3D;&quot;跨域子窗口链接&quot; frameborder&#x3D;&quot;0&quot; id&#x3D;&quot;oIfr&quot;&gt;&lt;&#x2F;iframe&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    let oIfr &#x3D; document.getElementById(&#39;oIfr&#39;);</span><br><span class="line">    let allowOrigin &#x3D; false;&#x2F;&#x2F;是否同源</span><br><span class="line">    oIfr.onload &#x3D; function()&#123;</span><br><span class="line">        if(!allowOrigin)&#123;</span><br><span class="line">            oIfr.src &#x3D; &#39;.&#x2F;demo.html&#39;;&#x2F;&#x2F;改为同源路径,demo.html不重要</span><br><span class="line">            allowOrigin &#x3D; true;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            console.log(oIfr.contentWindow.name)&#x2F;&#x2F;打印子窗口的window.name</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>子窗口获取父窗口数据（过时了）：</p><ul><li>同源：使用 window.parent.xxx 就可以获取数据了</li><li>不同源：<ol><li>父窗口将数据拼接到 oIfr.src 属性上</li><li>子窗口通过 window.location.hash 就可以获取到了</li></ol></li></ul><p><strong>postMessage（常用）：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">父窗口获取子窗口数据：</span><br><span class="line">父窗口：</span><br><span class="line">let oIfr &#x3D; doucment.getElementById(&#39;oIfr&#39;);</span><br><span class="line">window.onmessage &#x3D; function(e)&#123;</span><br><span class="line">    console.log(e.data);&#x2F;&#x2F;打印获取的数据</span><br><span class="line">&#125;</span><br><span class="line">子窗口：</span><br><span class="line">window.parent.postMessage(obj, &quot;父窗口协议域名端口号&quot;);&#x2F;&#x2F;用父窗口上的postMessage方法（数据，允许访问这个数据的域）</span><br><span class="line"></span><br><span class="line">子窗口获取父窗口数据：</span><br><span class="line">父窗口：</span><br><span class="line">oIfr.onload &#x3D; function()&#123;</span><br><span class="line">    &#x2F;&#x2F;等到子窗口加载完成后才能传送数据</span><br><span class="line">    oIfr.contentWindow.postMessage(obj,&quot;子窗口协议域名端口号&quot;);&#x2F;&#x2F;调用子窗口上的postMessage方法</span><br><span class="line">&#125;</span><br><span class="line">子窗口：</span><br><span class="line">window.onmessage &#x3D; function(e)&#123;</span><br><span class="line">    console.log(e.data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="网络面试必备"><a href="#网络面试必备" class="headerlink" title="网络面试必备"></a>网络面试必备</h1><h2 id="ajax"><a href="#ajax" class="headerlink" title="ajax"></a>ajax</h2><p>封装 ajax 函数 ajax 用来请求资源 可以使页面局部刷新</p><h2 id="网络的基础知识"><a href="#网络的基础知识" class="headerlink" title="网络的基础知识"></a>网络的基础知识</h2><ul><li><p>五层网络模型： 物理层 —》 数据链路层 —-》网络层—》 传输层—》 应用层</p></li><li><p>七层网络模型：</p><ul><li>应用层: 网络服务与最终用户的一个接口。协议有：HTTP FTP TFTP SMTP SNMP DNS TELNET HTTPS POP3 DHCP</li><li>表示层: 数据的表示、安全、压缩。（在五层模型里面已经合并到了应用层）格式有，JPEG、ASCll、DECOIC、加密格式等</li><li>会话层: 建立、管理、终止会话。（在五层模型里面已经合并到了应用层） 对应主机进程，指本地主机与远程主机正在进行的会话</li></ul></li></ul><h2 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h2><ul><li>浏览器提出的安全机制 规定 协议域名端口号均相同的资源 可以相互之间通信</li><li>如果在不同源的位置去交互的话需要认证</li><li>源： 协议+域名+端口号</li></ul><h2 id="三次握手-和-四次挥手（发生在传输层）"><a href="#三次握手-和-四次挥手（发生在传输层）" class="headerlink" title="三次握手 和 四次挥手（发生在传输层）"></a>三次握手 和 四次挥手（发生在传输层）</h2><ul><li>三次握手： 为了确认双方可以正常的沟通 建立连接</li><li>四次挥手： 为了确认双方都已经发送完信息了 并且都有回应了 双方都可以断开连接</li></ul><h2 id="请求方式："><a href="#请求方式：" class="headerlink" title="请求方式："></a>请求方式：</h2><ul><li>GET(获取数据的时候会用到)</li><li>POST（新建数据保存的时候用到）</li><li>HEAD PUT（修改数据的时候会用到）</li><li>DELETE（删除数据的时候会用到）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.GET请求指定的页面信息，并返回实体主体。</span><br><span class="line">2.HEAD类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头</span><br><span class="line">3.POST向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和&#x2F;或已有资源的修改。</span><br><span class="line">4.PUT从客户端向服务器传送的数据取代指定的文档的内容。</span><br><span class="line">5.DELETE请求服务器删除指定的页面。</span><br><span class="line">6.CONNECTHTTP&#x2F;1.1 协议中预留给能够将连接改为管道方式的代理服务器。</span><br><span class="line">7.OPTIONS允许客户端查看服务器的性能。</span><br><span class="line">8.TRACE回显服务器收到的请求，主要用于测试或诊断。</span><br><span class="line">9.PATCH是对 PUT 方法的补充，用来对已知资源进行局部更新 。</span><br></pre></td></tr></table></figure><h2 id="GET-POST-区别："><a href="#GET-POST-区别：" class="headerlink" title="GET POST 区别："></a>GET POST 区别：</h2><ul><li>get 请求把参数拼接在了地址上， post 请求放在了请求体里</li><li>get 请求方式传递数据量较少， post 请求传递数据量较大</li><li>post 相对于 get 而言较安全</li></ul><h2 id="状态码："><a href="#状态码：" class="headerlink" title="状态码："></a>状态码：</h2><ul><li>2xx 请求成功返回</li><li>3xx 重定向 301 永久性重定向 302 临时性重定向 304 资源未修改</li><li>4xx 客户端错误 404 没有找到（检查地址） 403 没有权限 400 错误的请求（参数有错误）</li><li>5xx 服务器端错误 500 服务器内部错误</li></ul><h2 id="http-和-https-的区别"><a href="#http-和-https-的区别" class="headerlink" title="http 和 https 的区别"></a>http 和 https 的区别</h2><ul><li>https 是在 http 的基础上运用了 ssl 加密 运用的加密算法 rsa 默认端口号 443</li><li>http: 超文本传输协议 端口号 80</li></ul><h2 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h2><h3 id="jsonp"><a href="#jsonp" class="headerlink" title="jsonp"></a>jsonp</h3><p>不是 w3c 标准里的，原理： script 标签身上的 src 属性是不受同源策略的限制的</p><h3 id="服务器代理"><a href="#服务器代理" class="headerlink" title="服务器代理"></a>服务器代理</h3><h3 id="iframe："><a href="#iframe：" class="headerlink" title="iframe："></a>iframe：</h3><ul><li>iframe + window.name —》 父页面请求子页面的数据 儿子给父亲数据</li><li>iframe + location.hash —-》 子页面请求父页面的数据 父亲给儿子数据</li><li>iframe + window.postMessage —》 双向请求</li></ul><h3 id="CORS-cross-origin-resource-sharing-跨域资源共享"><a href="#CORS-cross-origin-resource-sharing-跨域资源共享" class="headerlink" title="CORS(cross-origin resource sharing) 跨域资源共享"></a>CORS(cross-origin resource sharing) 跨域资源共享</h3><ol><li>后端来设置一个响应头 access-control-allow-origin: ‘<a href="http://www.duyiedu.com&/#39;">http://www.duyiedu.com&#39;</a></li><li>浏览器先发出请求到服务器 返回的过程中 判断是否是同源的</li><li>如果不是同源的会去看响应报文的响应头是否有 access-control-allow-origin: * / 当前页面的域名</li></ol><p><strong>浏览器将 CORS 请求分成两类：简单请求和非简单请求</strong></p><p>简单请求：只需要设置 Allow-Control-Access-Origin 相应头就可以</p><p>非简单请求：</p><ul><li>非简单请求指的是对服务器有特殊要求，比如请求方法为 PUT 或 DELETE，或者 Content-Type 字段的类型是 application/json。</li><li>非简单请求的 CORS 请求会在通信之前，增减一次 HTTP 查询的请求，成为 “预检”。</li><li>浏览器会先询问服务器，当前网页所在的域名是否在服务器许可的名单之中，以及可以使用哪些 HTTP 请求和头部字段。如果通过服务器的校验，才会发起正式的 XMLHttpRequest 请求，否则就报错</li></ul><p><strong>非简单请求的响应头里面必须含有以下字段：</strong></p><ul><li>Allow-Control-Access-Origin 必需，表示可以请求的源。</li><li>Access-Control-Allow-Methods 必需，表示支持的所有方法，以逗号分隔</li><li>Access-Control-Allow-Headers 如果浏览器请求包括 Access-Control-Req 方法，以逗号分隔</li><li>Access-Control-Allow-Headers 如果浏览器请求包括 Access-Control-Request-Headers 字段，则 Access-Control-Allow-Headers 字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段。</li></ul><h3 id="document-domain-—》-基础域名相同的页面-可以跨域"><a href="#document-domain-—》-基础域名相同的页面-可以跨域" class="headerlink" title="document.domain —》 基础域名相同的页面 可以跨域"></a>document.domain —》 基础域名相同的页面 可以跨域</h3><h2 id="HTTP-请求的发出经历了什么？"><a href="#HTTP-请求的发出经历了什么？" class="headerlink" title="HTTP 请求的发出经历了什么？"></a>HTTP 请求的发出经历了什么？</h2>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML5详解</title>
      <link href="2020/10/01/HTML5%E8%AF%A6%E8%A7%A3/"/>
      <url>2020/10/01/HTML5%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="新增属性"><a href="#新增属性" class="headerlink" title="新增属性"></a>新增属性</h1><h2 id="placeholder（文本框提示信息，无兼容性问题）"><a href="#placeholder（文本框提示信息，无兼容性问题）" class="headerlink" title="placeholder（文本框提示信息，无兼容性问题）"></a>placeholder（文本框提示信息，无兼容性问题）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type&#x3D; &quot;text&quot; placeholder&#x3D;&quot;请输入用户名&quot;&gt;&lt;&#x2F;input&gt;</span><br></pre></td></tr></table></figure><h2 id="input-新-Type"><a href="#input-新-Type" class="headerlink" title="input 新 Type"></a>input 新 Type</h2><blockquote><p>ps:基本没卵用，兼容性很不好</p></blockquote><a id="more"></a><p>时间相关（不常用） 缺点：1.丑。2.兼容性很不好(基本只有 Chrome 支持)</p><ul><li>date 日期选择</li><li>time 时间</li><li>week 第几年第几周</li><li>datetime-local 年月日时间组合<br></li></ul><p>还有一些属性<br></p><ul><li>number 只能填数字的文本框（Chrome 支持）</li><li>email 邮箱格式（Chrome、火狐支持）</li><li>color 颜色选择器（Chrome 支持）</li><li>range 一个可滑动的条，使用的时候填上 min=”1” max=”100” ,这样就能获取到 value 值（Chrome、safari 支持）</li><li>search 文本框能提示以前填过值，还能点 x 删除已输入的内容（Chrome 支持）</li><li>url 必须是网址（Chrome、火狐支持）</li></ul><h2 id="contentEditable-文本可编辑-（无兼容问题）"><a href="#contentEditable-文本可编辑-（无兼容问题）" class="headerlink" title="contentEditable 文本可编辑 （无兼容问题）"></a>contentEditable 文本可编辑 （无兼容问题）</h2><ul><li>默认是 false</li><li>为 true 时，点击后文本会变成一个超长的文本框</li><li>属性可继承，父级设置了子元素可以编辑</li><li>一般用于 table</li><li>不要嵌套来使用，会出现一些问题。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div contentEditable&#x3D;&quot;true&quot;&gt;hahaha&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><h2 id="draggable-拖拽（Chrome、Safari-支持）"><a href="#draggable-拖拽（Chrome、Safari-支持）" class="headerlink" title="draggable 拖拽（Chrome、Safari 支持）"></a>draggable 拖拽（Chrome、Safari 支持）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style&#x3D;&quot;width: 100px;height: 100px;background-color: red;&quot; draggable&#x3D;&quot;true&quot;&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><ul><li>a 标签、img 标签默认可拖拽</li></ul><h2 id="拖拽的生命周期，拖拽的组成"><a href="#拖拽的生命周期，拖拽的组成" class="headerlink" title="拖拽的生命周期，拖拽的组成"></a>拖拽的生命周期，拖拽的组成</h2><p>1.周期：拖拽开始 -》 拖拽进行中 -》 拖拽结束 2.组成：被拖拽物体，目标区域</p><h2 id="拖拽触发事件"><a href="#拖拽触发事件" class="headerlink" title="拖拽触发事件"></a>拖拽触发事件</h2><ul><li>dragstart 开始拖拽时触发事件</li><li>drag 在移动时触发</li><li>dragend 拖拽结束时触发事件</li><li>作用：可以时刻关注着拖拽的位置</li><li>可以配合 js 来实现拖拽松手后，位置改变</li><li>所有标签元素，当拖拽周期结束时，默认事件是回到原处</li></ul><h2 id="拖拽区域"><a href="#拖拽区域" class="headerlink" title="拖拽区域"></a>拖拽区域</h2><p>事件</p><ul><li>draginner 拖拽元素进入自己区域触发（注意触发点是鼠标，不是拖拽元素边界）</li><li>dragover 拖拽元素在自己区域内移动就不停触发</li><li>dragleave 拖拽元素离开自己区域时触发事件</li><li>drop 放下（拖拽元素在自己区域内松手），触发需要取消 dragover 默认事件 e.preventDefault()</li></ul><h2 id="改变拖拽时的光标（基本只有-chrome-支持）"><a href="#改变拖拽时的光标（基本只有-chrome-支持）" class="headerlink" title="改变拖拽时的光标（基本只有 chrome 支持）"></a>改变拖拽时的光标（基本只有 chrome 支持）</h2><ul><li>e.dataTransfer.effectAllowed =”link” 推拽的时候改变鼠标样式。只能在 dragstart 事件中设置</li><li>e.dataTransfer.dropEffect =”link” 推拽的时候改变鼠标样式。只能在 drop 事件中设置</li><li>link、copy、move、copyMove、linkMove、all</li></ul><h2 id="Hidden"><a href="#Hidden" class="headerlink" title="Hidden"></a>Hidden</h2><h2 id="Context-menu"><a href="#Context-menu" class="headerlink" title="Context-menu"></a>Context-menu</h2><h2 id="Date-Val-》-自定义属性"><a href="#Date-Val-》-自定义属性" class="headerlink" title="Date-Val -》 自定义属性"></a>Date-Val -》 自定义属性</h2><h1 id="新增标签"><a href="#新增标签" class="headerlink" title="新增标签"></a>新增标签</h1><h2 id="语义化标签（一群语义化的-div）"><a href="#语义化标签（一群语义化的-div）" class="headerlink" title="语义化标签（一群语义化的 div）"></a>语义化标签（一群语义化的 div）</h2><ul><li>header</li><li>footer</li><li>nav （导航）</li><li>section（段落）</li><li>article（文章，可以直接被引用拿走的，完整的。比如整篇文章之类）</li><li>aside（侧边栏）</li></ul><h2 id="canvas（画布）"><a href="#canvas（画布）" class="headerlink" title="canvas（画布）"></a>canvas（画布）</h2><ul><li>css 设置大小不是画布的大小</li><li>在行间样式上设置宽高才是画布的大小</li><li>画布方法：</li><li>getContext(“2d”);获取内容区，相当于他的画笔</li><li>moveTo() 一笔的起点</li><li>lineTo() 画到哪</li><li>stroke() 执行</li><li>lineWidth=1px; 线条宽度，写在哪都相当于写在最前面</li><li>fill(); 填充黑色</li><li>beginPath(); 重新开始一条线<br></li><li>closePath(); 闭合到开始的点,只针对一笔画的图形。</li><li>clearRect(0,0,500,500); 橡皮擦，a,b 起始位置 c,d 宽高</li><li>开发小规范：在画线前尽量写上 beginPath()，循环的时候不会出错。<br>图形：</li></ul><h2 id="矩形"><a href="#矩形" class="headerlink" title="矩形"></a>矩形</h2><ul><li>rect(100,100,150,100) 画矩形，起始位置 a,b 长宽 c,d</li><li>strokeRect(100,100,150,100) 直接生成矩形，省略 stroke()这一步</li><li>fillRect(100,100,150,100) 直接生成填充的 矩形</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;canvas id&#x3D;&quot;can&quot; width&#x3D;&quot;500px&quot; height&#x3D;&quot;300px&quot;&gt;&lt;&#x2F;canvas&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        var canvas &#x3D; document.getElementById(&#39;can&#39;);</span><br><span class="line">        var ctx &#x3D; canvas.getContext(&quot;2d&quot;); &#x2F;&#x2F;获取内容区，相当于他的画笔</span><br><span class="line">        ctx.moveTo(100, 100); &#x2F;&#x2F; 起点</span><br><span class="line">        ctx.lineTo(200, 100); &#x2F;&#x2F;画到哪</span><br><span class="line">        ctx.stroke();</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h2 id="圆形"><a href="#圆形" class="headerlink" title="圆形"></a>圆形</h2><ul><li>arc(100, 100, 50, 0, Math.PI / 2, 0); 画圆<ol><li>起始位置(a,b)，半径（c），起始弧度（d），结束弧度（e），方向（f）</li><li>弧度表示：0 = 0 度， Math.PI = 180 度</li><li>方向表示：0 - 顺时针，1 - 逆时针</li></ol></li></ul><h2 id="圆角矩形"><a href="#圆角矩形" class="headerlink" title="圆角矩形"></a>圆角矩形</h2><ul><li>arcTo(a,b,c,d,e) -&gt; B(a,b),C(c,d),圆角大小(e)</li><li>Math.PI == 180 度</li><li>C 点的 x 坐标主要是提供方向用<br><img src="http://47.97.6.61/%E6%9C%89%E9%81%93%E4%BA%91%E5%9B%BE%E7%89%87/%E5%9C%86%E8%A7%92%E7%9F%A9%E5%BD%A2.png" alt="圆角矩形"></li></ul><h2 id="贝塞尔曲线"><a href="#贝塞尔曲线" class="headerlink" title="贝塞尔曲线"></a>贝塞尔曲线</h2><ul><li>quadraticCurveTo(200,200,300,100);二次贝塞尔曲线 - 先到(200,200)点，再到(300,100)点</li><li>bezierCurveTo(200,200,300,100,400,200);三次贝塞尔曲线 - 传三个点</li><li>波浪效果看 demo</li></ul><h2 id="坐标系变换"><a href="#坐标系变换" class="headerlink" title="坐标系变换"></a>坐标系变换</h2><ul><li>rotate(Math.PI); 坐标系旋转，是根据画布原点进行旋转</li><li>translate(x,y);坐标系位置平移</li><li>scale(2,2);坐标系缩放。横纵坐标长度乘 2，坐标轴乘 2，不只是画的线乘 2</li><li>save(); 保存当前状态的坐标系状态 （平移数据，缩放数据，旋转数据）</li><li>restore(); 回复坐标系状态 -》 一般用于坐标旋转后，归正继续操作其他图形</li></ul><h2 id="背景填充"><a href="#背景填充" class="headerlink" title="背景填充"></a>背景填充</h2><ul><li>fillStyle=”red”; 颜色填充</li><li>createPattern(img, ‘no-repeat’);纹理填充。（纹理的坐标是从(0,0)开始的）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">填充图片练习</span><br><span class="line"> var img &#x3D; new Image();</span><br><span class="line">        img.src &#x3D; &#39;.&#x2F;img.jpg&#39;;</span><br><span class="line">        img.onload &#x3D; function() &#123;</span><br><span class="line">            ctx.beginPath();</span><br><span class="line">            ctx.save();&#x2F;&#x2F;保存当前坐标系</span><br><span class="line">            ctx.translate(100, 100)&#x2F;&#x2F;偏移坐标用以防止图片</span><br><span class="line">            var bg &#x3D; ctx.createPattern(img, &#39;no-repeat&#39;);</span><br><span class="line">            ctx.fillStyle &#x3D; bg;</span><br><span class="line">            ctx.fillRect(0, 0, 150, 50);</span><br><span class="line">            ctx.restore();&#x2F;&#x2F;恢复坐标系</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><ul><li>createLinearGradient(0, 0, 200, 200);线性渐变。a,b 坐标。c,d 宽高。<ul><li>addColorStop(0, “white”);</li><li>addColorStop(1, “black”);</li><li>注意：数字只能是从零到一之间的。</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">填充渐变色-线性渐变</span><br><span class="line">        var bg &#x3D; ctx.createLinearGradient(0, 0, 200, 200);</span><br><span class="line">        bg.addColorStop(0, &quot;white&quot;);</span><br><span class="line">        bg.addColorStop(1, &quot;black&quot;);</span><br><span class="line">        ctx.fillStyle &#x3D; bg;</span><br><span class="line">        ctx.fillRect(0, 0, 200, 200);</span><br></pre></td></tr></table></figure><ul><li>createRadialGradient(x1,y1,r1,x2,y2,r2) 辐射渐变,起始圆和结束圆的坐标和半径<ul><li>若起始圆的半径为零，两个圆组合像圆锥形。</li><li>若起始圆的半径不为零，则形状像圆柱形</li></ul></li></ul><ol><li>起始圆和结束圆坐标完全重合的情况，像一个正面的圆锥形或圆柱形</li><li>起始圆在结束圆的里面且圆心不重合，像一个变形的圆锥形或圆柱形</li><li>结束圆在起始圆的里面且圆心不重合，反向的圆锥形或圆柱形</li><li>起始圆与结束圆相离且两个圆大小不相等，会形成一个尖</li><li>起始圆与结束圆相离且两个圆大小相等，会形成一个平行带</li></ol><h2 id="阴影"><a href="#阴影" class="headerlink" title="阴影"></a>阴影</h2><ul><li>shadowColor = “red” 阴影颜色</li><li>shadowBlur = 10; 阴影宽度</li><li>shadowOffsetX/Y 阴影纵横偏移量</li></ul><h2 id="文字"><a href="#文字" class="headerlink" title="文字"></a>文字</h2><ul><li>font=”30px 宋体”;</li><li>strokeText(“文本”,100,100); 文字描边（空心）</li><li>fillText(“文本”,100,100); 文字填充（实心）</li></ul><h2 id="线端样式"><a href="#线端样式" class="headerlink" title="线端样式"></a>线端样式</h2><ul><li>lineCap = ”butt” 线端样式为原来样式<ul><li>butt 原来样子</li><li>square 两端加一个方块</li><li>round 两端加加半圆</li></ul></li><li>lineJoin 两个线交撞部分样式<ul><li>miter（默认，比较锋锐的尖）<ul><li>miterLimit = 5; 给这个尖设置最大长度，放置尖过长</li></ul></li><li>round 半圆</li><li>bevel 砍掉</li></ul></li></ul><h2 id="svg（画布）"><a href="#svg（画布）" class="headerlink" title="svg（画布）"></a>svg（画布）</h2><h2 id="和-canvas-的区别"><a href="#和-canvas-的区别" class="headerlink" title="和 canvas 的区别"></a>和 canvas 的区别</h2><ul><li>首先两个都是画图工具。</li><li>有各自适用的范围<ul><li>svg：矢量图，放大不会失真，适合大面积的贴图，通常动画较少或者较简单，用标签和 css 来画。</li><li>canvas：通常适合用于小面积的绘图，适合动画。用 js 来画。</li></ul></li></ul><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><ul><li>标签属性<ul><li>svg：<ul><li>width/height/style</li><li>viewBox = “0,0,250,150” (坐标,更改比例后的宽高) 比例尺<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;svg width&#x3D;&quot;500px&quot; height&#x3D;&quot;300px&quot; style&#x3D;&quot;border:1px solid&quot; viewBox&#x3D;&quot;0,0,250,150&quot;&gt;</span><br><span class="line">    &lt;rect height&#x3D;&quot;100px&quot; width&#x3D;&quot;100px&quot; x&#x3D;&quot;0&quot; y&#x3D;&quot;0&quot; &gt;&lt;&#x2F;rect&gt;</span><br><span class="line">&lt;&#x2F;svg&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li>line：x1,x2,y1,y2 （线段起点坐标，终点坐标）</li><li>rect：height\width\x\y\rx\ry (矩形长宽，坐标，弧度)</li><li>circle：r\cx\cy（圆半径，坐标）</li><li>ellipse：rx\ry\cx\cy（半径宽高，坐标）</li><li>polyline：折线<ul><li>points=”0 0,50 0,50 50”;三个点相连,默认填充内容</li></ul></li><li>polygon：多边形，用法同上（和折线区别：多边形会将首尾相连）</li><li>text：x\y(坐标) 文本</li></ul></li><li>css 属性<ul><li>stroke:red; 线条（颜色红色）</li><li>stroke-opacity:.5;线条透明度</li><li>stroke-width:2px;线的宽度</li><li>stroke-linecap:butt;线端样式</li><li>stroke-linejoin:round;线段相交</li><li>stroke-dasharray:10px 10px…;线条虚线(a 填充区宽度，b 间隔宽度,再往后填参数则按照所填的宽度继续数)</li><li>stroke-dashaoffset:10px 线条偏移，虚线的小方块向左偏移（线条偏移，线条位置不动）</li><li>fill:transparent;填充（不填充图形）</li><li>fill-opacity:.5;填充透明度</li><li></li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">画线</span><br><span class="line">&lt;style&gt;</span><br><span class="line">    line &#123;</span><br><span class="line">        stroke: red;</span><br><span class="line">        stroke-width: 2px;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;svg width&#x3D;&quot;500px&quot; height&#x3D;&quot;300px&quot; style&#x3D;&quot;border:1px solid&quot;&gt;</span><br><span class="line">    &lt;line x1&#x3D;&quot;100&quot; y1&#x3D;&quot;100&quot; x2&#x3D;&quot;200&quot; y2&#x3D;&quot;100&quot;&gt;&lt;&#x2F;line&gt;</span><br><span class="line">    &lt;line x1&#x3D;&quot;200&quot; y1&#x3D;&quot;100&quot; x2&#x3D;&quot;200&quot; y2&#x3D;&quot;200&quot;&gt;&lt;&#x2F;line&gt;</span><br><span class="line">    &lt;rect height&#x3D;&quot;100px&quot; width&#x3D;&quot;100px&quot; x&#x3D;&quot;0&quot; y&#x3D;&quot;0&quot; rx&#x3D;&quot;10&quot; ry&#x3D;&quot;10&quot;&gt;&lt;&#x2F;rect&gt;</span><br><span class="line">&lt;&#x2F;svg&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="path-标签-只有一个属性-d-里面可传多多种类型值"><a href="#path-标签-只有一个属性-d-里面可传多多种类型值" class="headerlink" title="path 标签:只有一个属性 d,里面可传多多种类型值"></a>path 标签:只有一个属性 d,里面可传多多种类型值</h2><ul><li>默认填充，参数之间空格隔开即可。</li><li>M -&gt; moveTo 大写字母都是绝对位置</li><li>L -&gt; lineTo</li><li>l -&gt; lineTo 小写字母都是相对位置</li><li>H -&gt; 横着走到指定值</li><li>V -&gt; 竖着走到指定值</li><li>h -&gt; 横向移动多少距离</li><li>v -&gt; 竖着移动多少距离</li><li>Z -&gt; 闭合区间(不区分大小写)</li><li>A hr vr deg a b x y-&gt; 圆弧 （横向半径 纵向半径 旋转角度 选择大弧还是小弧 旋转方向[0 顺 1 逆] 终点坐标[x,y])</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">使用</span><br><span class="line">   &lt;svg width&#x3D;&quot;500px&quot; height&#x3D;&quot;300px&quot; style&#x3D;&quot;border:1px solid&quot;&gt;</span><br><span class="line">        &lt;path d&#x3D;&quot;M 100 100 L 200 100 L 200 200 l -100 0 V 120  H 300&quot;&gt;&lt;&#x2F;path&gt;</span><br><span class="line">    &lt;&#x2F;svg&gt;</span><br></pre></td></tr></table></figure><h2 id="渐变-defs-标签"><a href="#渐变-defs-标签" class="headerlink" title="渐变 defs 标签"></a>渐变 defs 标签</h2><ul><li>linearGradient 标签 线性渐变</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;svg width&#x3D;&quot;500px&quot; height&#x3D;&quot;300px&quot; style&#x3D;&quot;border:1px solid&quot;&gt;</span><br><span class="line">  &lt;defs&gt;</span><br><span class="line">      &lt;linearGradient id&#x3D;&quot;bg1&quot; x1&#x3D;&quot;0&quot; y1&#x3D;&quot;0&quot; x2&#x3D;&quot;0&quot; y2&#x3D;&quot;100%&quot;&gt;</span><br><span class="line">          &lt;stop offset&#x3D;&quot;0%&quot; style&#x3D;&quot;stop-color: white;&quot; &gt;&lt;&#x2F;stop&gt;</span><br><span class="line">          &lt;stop offset&#x3D;&quot;100%&quot; style&#x3D;&quot;stop-color: black;&quot; &gt;&lt;&#x2F;stop&gt;</span><br><span class="line">      &lt;&#x2F;linearGradient&gt;</span><br><span class="line">  &lt;&#x2F;defs&gt;</span><br><span class="line">  &lt;rect x&#x3D;&quot;100&quot; y&#x3D;&quot;100&quot; height&#x3D;&quot;100&quot; width&#x3D;&quot;200&quot; style&#x3D;&quot;fill:url(#bg1)&quot;&gt;&lt;&#x2F;rect&gt;</span><br><span class="line">  &lt;&#x2F;svg&gt;</span><br></pre></td></tr></table></figure><h2 id="filter-标签-高斯模糊（滤镜）"><a href="#filter-标签-高斯模糊（滤镜）" class="headerlink" title="filter 标签 高斯模糊（滤镜）"></a>filter 标签 高斯模糊（滤镜）</h2><ul><li>feGaussianBlur 标签<ul><li>in=”SourceGraphic”</li><li>stdDeviation=”10”;模糊度</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;svg width&#x3D;&quot;500px&quot; height&#x3D;&quot;300px&quot; style&#x3D;&quot;border:1px solid&quot;&gt;</span><br><span class="line">&lt;defs&gt;</span><br><span class="line">    &lt;linearGradient id&#x3D;&quot;bg1&quot; x1&#x3D;&quot;0&quot; y1&#x3D;&quot;0&quot; x2&#x3D;&quot;0&quot; y2&#x3D;&quot;100%&quot;&gt;</span><br><span class="line">        &lt;stop offset&#x3D;&quot;0%&quot; style&#x3D;&quot;stop-color: white;&quot; &gt;&lt;&#x2F;stop&gt;</span><br><span class="line">        &lt;stop offset&#x3D;&quot;100%&quot; style&#x3D;&quot;stop-color: black;&quot; &gt;&lt;&#x2F;stop&gt;</span><br><span class="line">    &lt;&#x2F;linearGradient&gt;</span><br><span class="line">&lt;&#x2F;defs&gt;</span><br><span class="line">&lt;filter id&#x3D;&quot;gs&quot;&gt;</span><br><span class="line">    &lt;feGaussianBlur  in&#x3D;&quot;SourceGraphic&quot; stdDeviation&#x3D;&quot;10&quot;&gt;&lt;&#x2F;feGaussianBlur&gt;</span><br><span class="line">&lt;&#x2F;filter&gt;</span><br><span class="line">&lt;rect x&#x3D;&quot;100&quot; y&#x3D;&quot;100&quot; height&#x3D;&quot;100&quot; width&#x3D;&quot;200&quot; style&#x3D;&quot;fill:url(#bg1); filter:url(#gs)&quot; &gt;&lt;&#x2F;rect&gt;</span><br><span class="line">&lt;&#x2F;svg&gt;</span><br></pre></td></tr></table></figure><h2 id="Audio（声音播放）"><a href="#Audio（声音播放）" class="headerlink" title="Audio（声音播放）"></a>Audio（声音播放）</h2><ul><li>所有功能同下</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;audio src&#x3D;&quot;kanong.mp3&quot; controls&gt;&lt;&#x2F;audio&gt;</span><br></pre></td></tr></table></figure><h2 id="Video（视频播放）"><a href="#Video（视频播放）" class="headerlink" title="Video（视频播放）"></a>Video（视频播放）</h2><ul><li>controls 默认工具栏（通常不用）</li><li>controls(显示组件控件)</li><li>autoplay(自动播放)</li><li>muted(静音播放)</li><li>loop(循环播放)</li></ul><h2 id="自定义工具栏"><a href="#自定义工具栏" class="headerlink" title="自定义工具栏"></a>自定义工具栏</h2><ul><li>video.play(); 播放</li><li>video.pause(); 暂停</li><li>video.paused; 判断是否为暂停状态</li><li>video.duration; 视频总时长(秒)</li><li>video.currentTime;当前秒数</li><li>video.playbackRate = 1;速率</li><li>video.currentTime 当前播放的时间</li><li>video.volume 当前音量(最大为 1，默认为 1)</li><li>document.documentElement.requestFullscreen(); 文档全屏</li><li></li></ul><h1 id="获取地理信息-geoLocation"><a href="#获取地理信息-geoLocation" class="headerlink" title="获取地理信息 geoLocation"></a>获取地理信息 geoLocation</h1><p><strong>定位（GPS）：</strong> 台式机几乎都没有 GPS，笔记本绝大多数都没有 GPS，智能手机几乎都有 GPS</p><p><strong>网络定位：</strong> 电脑可以通过网络进行粗略的地理定位</p><p><strong>定位的使用：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.navigator.geolocation.getCurrentPosition(</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">position</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;成功的回调函数&quot;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(position);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;失败的回调函数&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>特殊情况：</strong> 只有在 https、file 协议下才能使用，http 协议下是不能使用的</p><p><strong>属性值：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">accuracy：准确度</span><br><span class="line">longitude：经度</span><br><span class="line">latitude: 纬度</span><br></pre></td></tr></table></figure><h1 id="4-行代码写个服务器"><a href="#4-行代码写个服务器" class="headerlink" title="4 行代码写个服务器"></a>4 行代码写个服务器</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//server.js:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> express = <span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> app = <span class="keyword">new</span> express(); <span class="comment">//构建一个webapp对象</span></span><br><span class="line"></span><br><span class="line">app.use(express.static(<span class="string">&quot;./page&quot;</span>)); <span class="comment">//设置一个静态文件路径</span></span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">10148</span>); <span class="comment">//监听端口号，尽量大于8000，或者等于80，（默认访问80端口）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//express 默认访问index.html</span></span><br><span class="line"><span class="comment">//启动： node server.js</span></span><br></pre></td></tr></table></figure><h1 id="重力感应"><a href="#重力感应" class="headerlink" title="重力感应"></a>重力感应</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;main&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    &#x2F;&#x2F; 陀螺仪，只有带有陀螺仪的设备才支持体感</span><br><span class="line">    &#x2F;&#x2F; 苹果设备的页面只有再https协议的情况下才能使用这些接口</span><br><span class="line">    &#x2F;&#x2F; 11.1.x以及以前，是可以使用的。</span><br><span class="line">    &#x2F;&#x2F;属性：</span><br><span class="line">    &#x2F;&#x2F;alpha：指北（指南针）[0,360)，当为0的时候指北。180指南</span><br><span class="line">    &#x2F;&#x2F;beta：平放时beta值为0，立起来时（短边接触桌面）beta值为90，反着立（-90）</span><br><span class="line">    &#x2F;&#x2F;gamma：平方时gamma值为0，如果讲手机立起来（长边接触桌面）gamma为90，反着立（-90）</span><br><span class="line">    window.addEventListener(&quot;devicemotion&quot;, function(event) &#123;</span><br><span class="line">        console.log(event);</span><br><span class="line">        document.getElementById(&quot;main&quot;).innerHTML &#x3D; &quot;alpha:&quot; + event.alpha + &quot;&lt;br&gt;&quot; + &quot;beta:&quot; + event.beta + &quot;&lt;br&gt;&quot; + &quot;gamma&quot; + event.gamma + &quot;&lt;br&gt;&quot;</span><br><span class="line">    &#125;);</span><br><span class="line">    &#x2F;&#x2F;手机访问电脑</span><br><span class="line">    &#x2F;&#x2F;1. 手机要和电脑再同一个局域网下</span><br><span class="line">    &#x2F;&#x2F;2. 获取电脑的ip地址</span><br><span class="line">    &#x2F;&#x2F;3. 在手机上输入相应的ip和端口进行访问</span><br><span class="line">    &#x2F;&#x2F;获取ip地址</span><br><span class="line">    &#x2F;&#x2F;mac1:命令框：ifconfig | grep &quot;inet&quot; 配置，找到含有inet的信息</span><br><span class="line">    &#x2F;&#x2F;mac2:设置-》网络</span><br><span class="line">    &#x2F;&#x2F;window:cmd:ipconfig 用网线看以太网适配器，用无线局域网适配器（防火墙需 关闭）</span><br><span class="line">    &#x2F;&#x2F;4. 输入ip地址即可</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h1 id="手机摇晃"><a href="#手机摇晃" class="headerlink" title="手机摇晃"></a>手机摇晃</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;main&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    window.addEventListener(&quot;devicemotion&quot;, function(e) &#123;</span><br><span class="line">        &#x2F;&#x2F; acceleration 三个方向的加速度</span><br><span class="line">        document.getElementById(&quot;main&quot;).innerHTML &#x3D; &quot;x:&quot; + e.acceleration.x + &quot;&lt;br&gt;y:&quot; + e.acceleration.y + &quot;&lt;br&gt;z:&quot; + e.acceleration.e;</span><br><span class="line">        if (Math.abs(e.acceleration.x) &gt; 9 || Math.abs(e.acceleration.y) &gt; 9 || Math.abs(e.acceleration.z) &gt; 9) &#123;</span><br><span class="line">            console.log(&quot;在晃&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h1 id="动画优化-requestAnimationFrame"><a href="#动画优化-requestAnimationFrame" class="headerlink" title="动画优化 requestAnimationFrame"></a>动画优化 requestAnimationFrame</h1><p>屏幕刷新的频率：60 次/秒</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;main&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    &#x2F;&#x2F;requestAnimationFrame是每秒60帧</span><br><span class="line">    &#x2F;&#x2F;1帧（少于1&#x2F;60秒），2帧，3帧</span><br><span class="line">    &#x2F;&#x2F;requestAnimationFrame有个特殊的队列，可以准时执行每一帧</span><br><span class="line">    &#x2F;&#x2F;setInterval上一帧不执行完是不会执行下一帧的，所以不如requestAnimationFrame流畅（一般来说看不大出来）</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;requestAnimationFrame 兼容性极差</span><br><span class="line">    var timer &#x3D; null;</span><br><span class="line"></span><br><span class="line">    function move() &#123;</span><br><span class="line">        var square &#x3D; document.getElementById(&quot;main&quot;);</span><br><span class="line">        if (square.offsetLeft &gt; 700) &#123;</span><br><span class="line">            cancelAnimationFrame(timer); &#x2F;&#x2F;取消这个动画，类似clearTimerout</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        square.style.left &#x3D; square.offsetLeft + 20 + &quot;px&quot;;</span><br><span class="line">        timer &#x3D; requestAnimationFrame(move);</span><br><span class="line">    &#125;</span><br><span class="line">    move();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;强行使用加上如下代码</span><br><span class="line">    window.requestAnimationFrame &#x3D; (function() &#123;</span><br><span class="line">        return window.requestAnimationFrame ||</span><br><span class="line">            function(id) &#123;</span><br><span class="line">                window.setTimeout(id, 1000 &#x2F; 60);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;)()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    window.cancelAnimationFrame &#x3D; (function() &#123;</span><br><span class="line">        return window.cancelAnimationFrame ||</span><br><span class="line">            window.webkitCancelAnimationFrame ||</span><br><span class="line">            window.mozCancelAnimationFrame ||</span><br><span class="line">            function(id) &#123;</span><br><span class="line">                window.clearTimeout(id);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;)();</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h1 id="浏览器存储-localStorage"><a href="#浏览器存储-localStorage" class="headerlink" title="浏览器存储 localStorage"></a>浏览器存储 localStorage</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    &#x2F;&#x2F;cookie:每次请求的时候都有可能传送许多无用的信息到后端</span><br><span class="line">    &#x2F;&#x2F;localStorage 只能存储字符串，可以通过JSON转换实现其他类型</span><br><span class="line">    &#x2F;&#x2F;sessionStorage 和localStorage作用相同</span><br><span class="line">    &#x2F;&#x2F;长期存放在浏览器，写入localStorage(无论窗口是否关闭)</span><br><span class="line">    &#x2F;&#x2F;会话临时需要存储的变量，每次窗口关闭的时候，sessionStorage都会自动清空</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;localStorage 和 cookie</span><br><span class="line">    &#x2F;&#x2F;1. localStorage在发送请求的时候不会把数据发出去，cookie会把所有的数据带出去</span><br><span class="line">    &#x2F;&#x2F;2. cookie存储的内容比较少 4k，localStorage可以存放较多的内容，5m左右</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;相同协议，相同域名，相同端口称为一个域</span><br><span class="line">    localStorage.name &#x3D; &quot;du&quot;;</span><br><span class="line">    localStorage.setItem(&quot;name&quot;, &quot;du&quot;) &#x2F;&#x2F;另一种写法</span><br><span class="line">    localStorage.getItem(&quot;name&quot;)</span><br><span class="line">    localStorage.removeItem(&quot;name&quot;)</span><br><span class="line">    localStorage.arr &#x3D; JSON.stringify([1, 2, 3]);</span><br><span class="line">    console.log(JSON.parse(localStorage.arr))</span><br><span class="line">    localStorage.obj &#x3D; JSON.stringify(&#123;</span><br><span class="line">        name: &quot;du&quot;,</span><br><span class="line">        age: 18</span><br><span class="line">    &#125;)</span><br><span class="line">    console.log(JSON.parse(localStorage.obj))</span><br><span class="line">    sessionStorage.name &#x3D; &quot;du&quot;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h1 id="history"><a href="#history" class="headerlink" title="history"></a>history</h1><p>核心：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">history.pushState(&#123;inpVal: value&#125;, null, &quot;#&quot; + value);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;url改变时触发</span><br><span class="line">window.addEventListener(&quot;popstate&quot;, function(e) &#123;e.state.inpVal&#125;</span><br><span class="line">&#x2F;&#x2F;锚点（#）改变触发</span><br><span class="line">window.addEventListener(&quot;hashchange&quot;, function(e) &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;锚点改变两个都触发，先触发url监听</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        &#x2F;&#x2F;a -&gt; b -&gt; c</span><br><span class="line">        &#x2F;&#x2F; 为了网页的性能，单页面操作</span><br><span class="line">        var data &#x3D; [&#123;</span><br><span class="line">            name: &quot;html&quot;</span><br><span class="line">        &#125;, &#123;</span><br><span class="line">            name: &quot;css&quot;</span><br><span class="line">        &#125;, &#123;</span><br><span class="line">            name: &quot;js&quot;</span><br><span class="line">        &#125;];</span><br><span class="line"></span><br><span class="line">        function search() &#123;</span><br><span class="line">            var value &#x3D; document.getElementById(&quot;search&quot;).value;</span><br><span class="line">            var result &#x3D; data.filter(function(obj) &#123;</span><br><span class="line">                if (obj.name.indexOf(value) &gt; -1) &#123;</span><br><span class="line">                    return obj;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            render(result);</span><br><span class="line">            &#x2F;&#x2F; 把每个查询状态插入到历史记录里 history是一个堆栈形式，通过pushState插入(传入的状态,title(没有浏览器支持，设置null即可),url)</span><br><span class="line">            history.pushState(&#123;</span><br><span class="line">                inpVal: value</span><br><span class="line">            &#125;, null, &quot;#&quot; + value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        function render(renderData) &#123;</span><br><span class="line">            var content &#x3D; &quot;&quot;;</span><br><span class="line">            for (let i &#x3D; 0; i &lt; renderData.length; i++) &#123;</span><br><span class="line">                content +&#x3D; &quot;&lt;div&gt;&quot; + renderData[i].name + &quot;&lt;&#x2F;div&gt;&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">            document.getElementById(&quot;main&quot;).innerHTML &#x3D; content;</span><br><span class="line">        &#125;</span><br><span class="line">        window.addEventListener(&quot;popstate&quot;, function(e) &#123;</span><br><span class="line">            &#x2F;&#x2F; 监听浏览器url改变，可以找到当前页history传入的数据，比较常用</span><br><span class="line">            document.getElementById(&quot;search&quot;).value &#x3D; e.state &amp;&amp; e.state.inpVal ? e.state.inpVal : &quot;&quot;;</span><br><span class="line">            &#x2F;&#x2F; 重新渲染页面数据</span><br><span class="line">            var value &#x3D; document.getElementById(&quot;search&quot;).value;</span><br><span class="line">            var result &#x3D; data.filter(function(obj) &#123;</span><br><span class="line">                if (obj.name.indexOf(value) &gt; -1) &#123;</span><br><span class="line">                    return obj;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            render(result);</span><br><span class="line">        &#125;)</span><br><span class="line">        window.addEventListener(&quot;hashchange&quot;, function(e) &#123;</span><br><span class="line">            &#x2F;&#x2F;hash值改变，或者说锚点改变才会触发</span><br><span class="line">            console.log(e)</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;&quot; id&#x3D;&quot;search&quot;&gt;</span><br><span class="line">    &lt;button onclick&#x3D;&quot;search()&quot;&gt;搜索&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;main&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        render(data)</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><h1 id="worker"><a href="#worker" class="headerlink" title="worker"></a>worker</h1><p>兼容性不太好</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">主页面：</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    &#x2F;&#x2F; js都是单线程的</span><br><span class="line">    &#x2F;&#x2F;worker 是多线程的，是真的多线程，不是伪多线程</span><br><span class="line">    &#x2F;&#x2F;不能操作dom，没有window对象，不能读取本地文件。可以发ajax（ajax本身就是异步的），可以计算。</span><br><span class="line">    &#x2F;&#x2F;在worker中继续创建worder?理论上是可行的，但是实际上没有浏览器支持</span><br><span class="line">    console.log(&#39;----------&#39;)</span><br><span class="line">    var a &#x3D; 100000000;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 当前页面即为主线程,worder.js为辅助线程</span><br><span class="line">    var worker &#x3D; new Worker(&quot;.&#x2F;worder.js&quot;);</span><br><span class="line">    &#x2F;&#x2F; postMessage为发送，onmessage为接收</span><br><span class="line">    worker.postMessage(&#123;</span><br><span class="line">        num: a</span><br><span class="line">    &#125;);</span><br><span class="line">    worker.onmessage &#x3D; function(e) &#123;</span><br><span class="line">        console.log(e.data)</span><br><span class="line">    &#125;;</span><br><span class="line">    &#x2F;&#x2F; 停止运行</span><br><span class="line">    worker.terminate();</span><br><span class="line"></span><br><span class="line">    console.log(&#39;---------&#39;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">worker.js文件:</span><br><span class="line">&#x2F;&#x2F;可以引入其他文件js（不能操作dom等）</span><br><span class="line">importScripts(&quot;.&#x2F;xxx.js&quot;);</span><br><span class="line">&#x2F;&#x2F;把计算的过程放入异步中</span><br><span class="line">this.onmessage &#x3D; function(e) &#123;</span><br><span class="line">    var result &#x3D; 0;</span><br><span class="line">    for (var i &#x3D; 0; i &lt; e.data.num; i++) &#123;</span><br><span class="line">        result +&#x3D; i;</span><br><span class="line">    &#125;</span><br><span class="line">    this.postMessage(result);</span><br><span class="line">    this.close(); &#x2F;&#x2F;自己停止</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 前端 </tag>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript（四）ES6</title>
      <link href="2020/10/01/JavaScript%EF%BC%88%E5%9B%9B%EF%BC%89ES6/"/>
      <url>2020/10/01/JavaScript%EF%BC%88%E5%9B%9B%EF%BC%89ES6/</url>
      
        <content type="html"><![CDATA[<h1 id="声明变量相关"><a href="#声明变量相关" class="headerlink" title="声明变量相关"></a>声明变量相关</h1><h2 id="使用-var-声明变量"><a href="#使用-var-声明变量" class="headerlink" title="使用 var 声明变量"></a>使用 var 声明变量</h2><ol><li>全局变量挂载到全局对象：全局对象成员污染问题</li><li>允许重复的变量声明：导致数据被覆盖</li><li>变量提升：怪异的数据访问、闭包问题<a id="more"></a></li></ol><h2 id="使用-let-声明变量"><a href="#使用-let-声明变量" class="headerlink" title="使用 let 声明变量"></a>使用 let 声明变量</h2><p>ES6 不仅引入 let 关键字用于解决变量生命的问题，同时引入了块级作用域的的概念</p><h3 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域<br></h3><ol><li>代码执行时遇到花括号，会创建一个块级作用域，花括号结束，销毁块级作用域</li><li>在循环中使用 let 声明的循环变量，在循环结束后会销毁</li><li>在循环中，用 let 声明的循环变量，会特殊处理，每次进入循环体，都会开启一个新的作用域，并且将循环变量绑定到该作用域（每次循环，使用的是一个全新的循环变量）</li><li>在循环中使用 let 声明的循环变量，在循环结束后会销毁</li></ol><h3 id="所解决声明变量的问题"><a href="#所解决声明变量的问题" class="headerlink" title="所解决声明变量的问题"></a>所解决声明变量的问题</h3><ol><li>不会污染全局变量（全局变量不会挂载到全局对象[window]）</li><li>let 变量不允许同作用域内重复声明</li><li>使用 let 不会有变量提升，因此，不能在定义 let 变量前使用它<ul><li><strong>底层实现上，let 声明的变量实际上也会有提升，但是，提升后会将其放入到“暂时性死区”，如果访问的变量位于暂时性死区，则会报错：“Cannot access ‘a’ before initialization”。当代码运行到该变量的声明语句时，会将其从暂时性死区中移除。</strong></li></ul></li></ol><h2 id="使用-const-声明常量"><a href="#使用-const-声明常量" class="headerlink" title="使用 const 声明常量"></a>使用 const 声明常量</h2><p>const 和 let 完全相同，仅在于用 const 声明的变量，==必须在声明时赋值，而且不可以重新赋值。==</p><ul><li>实际上，在开发中，应该==尽量使用 const 来声明变量==，以保证变量的值不会随意篡改，原因如下：<ol><li>根据经验，开发中的很多变量，都是不会更改，也不应该更改的。</li><li>后续的很多框架或者是第三方 JS 库，都要求数据不可变，使用常量可以一定程度上保证这一点。</li></ol></li><li>==<strong>注意的细节</strong>==：<ol><li>常量不可变，是指声明的常量的内存空间不可变，并不保证内存空间中的地址指向的其他空间不可变。(==常量本身的值不可变，若常量是个引用值，则可以更改引用值里面的数据==)</li><li>常量的命名<ol><li>特殊的常量：该常量从字面意义上，一定是不可变的，比如圆周率、月地距地或其他一些绝不可能变化的配置。通常，<strong>该常量的名称全部使用大写，多个单词之间用下划线分割</strong></li><li>普通的常量：使用和之前一样的命名即可</li></ol></li><li>在 for 循环中，循环变量不可以使用常量</li></ol></li></ul><h1 id="字符串和正则表达式"><a href="#字符串和正则表达式" class="headerlink" title="字符串和正则表达式"></a>字符串和正则表达式</h1><h3 id="Unicode-相关"><a href="#Unicode-相关" class="headerlink" title="Unicode 相关"></a>Unicode 相关</h3><p>早期，由于存储空间宝贵，Unicode 使用 16 位二进制来存储文字。我们将一个 16 位的二进制编码叫做一个码元（Code Unit）。</p><p>后来，由于技术的发展，Unicode 对文字编码进行了扩展，将某些文字扩展到了 32 位（占用两个码元），并且，将某个文字对应的二进制数字叫做码点（Code Point）。</p><p>ES6 为了解决这个困扰，为字符串提供了方法：codePointAt，根据字符串码元的位置得到其码点。</p><p>同时，ES6 为正则表达式添加了一个 flag: u，如果添加了该配置，则匹配时，使用码点匹配</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">const text &#x3D; &quot;𠮷&quot;; &#x2F;&#x2F;占用了两个码元（32位）</span><br><span class="line"></span><br><span class="line">console.log(&quot;字符串长度：&quot;, text.length);&#x2F;&#x2F;2</span><br><span class="line">console.log(&quot;使用正则测试：&quot;, &#x2F;^.$&#x2F;.test(text));&#x2F;&#x2F;false 因为这里匹配的是码元，所以匹配失败</span><br><span class="line">console.log(&quot;使用正则测试：&quot;, &#x2F;^.$&#x2F;u.test(text));&#x2F;&#x2F;true，这里匹配的是码点</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 判断字符串char，是32位，还是16位</span><br><span class="line"> * @param &#123;*&#125; char</span><br><span class="line"> *&#x2F;</span><br><span class="line">function is32bit(char, i) &#123;</span><br><span class="line">    &#x2F;&#x2F;如果码点大于了16位二进制的最大值，则其是32位的</span><br><span class="line">    return char.codePointAt(i) &gt; 0xffff;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 得到一个字符串码点的真实长度</span><br><span class="line"> * @param &#123;*&#125; str</span><br><span class="line"> *&#x2F;</span><br><span class="line">function getLengthOfCodePoint(str) &#123;</span><br><span class="line">    var len &#x3D; 0;</span><br><span class="line">    for (let i &#x3D; 0; i &lt; str.length; i++) &#123;</span><br><span class="line">        &#x2F;&#x2F;i在索引码元</span><br><span class="line">        if (is32bit(str, i)) &#123;</span><br><span class="line">            &#x2F;&#x2F;当前字符串，在i这个位置，占用了两个码元</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    return len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="更多的字符串-API"><a href="#更多的字符串-API" class="headerlink" title="更多的字符串 API"></a>更多的字符串 API</h3><ul><li>includes 判断字符串中是否包含指定的子字符串</li><li>startsWith 判断字符串中是否以指定的字符串开始</li><li>endsWith 判断字符串中是否以指定的字符串结束</li><li>repeat 将字符串重复指定的次数，返回一个新字符串</li></ul><h3 id="扩展-正则中的粘连标记"><a href="#扩展-正则中的粘连标记" class="headerlink" title="[扩展]正则中的粘连标记"></a>[扩展]正则中的粘连标记</h3><p>标记名：y</p><p>含义：匹配时，完全按照正则对象中的 lastIndex 位置开始匹配，并且匹配的位置必须在 lastIndex 位置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const text &#x3D; &#39;Hello World&#39;;</span><br><span class="line">const reg &#x3D; &#x2F;W\w+&#x2F;y; &#x2F;&#x2F;以W开头的字符串</span><br><span class="line">console.log(&#39;reg.lastIndex：&#39;, reg.lastIndex);&#x2F;&#x2F;0</span><br><span class="line">console.log(reg.test(text));&#x2F;&#x2F;false</span><br><span class="line"></span><br><span class="line">const text &#x3D; &#39;Hello World&#39;;</span><br><span class="line">const reg &#x3D; &#x2F;W\w+&#x2F;;</span><br><span class="line">console.log(&#39;reg.lastIndex：&#39;, reg.lastIndex);&#x2F;&#x2F;0</span><br><span class="line">console.log(reg.test(text));&#x2F;&#x2F;true</span><br><span class="line"></span><br><span class="line">const text &#x3D; &#39;Hello World&#39;;</span><br><span class="line">const reg &#x3D; &#x2F;W\w+&#x2F;y; &#x2F;&#x2F;以W开头的字符串</span><br><span class="line"> reg.lastIndex&#x3D;6</span><br><span class="line">console.log(&#39;reg.lastIndex：&#39;, reg.lastIndex);&#x2F;&#x2F;6</span><br><span class="line">console.log(reg.test(text));&#x2F;&#x2F;true</span><br></pre></td></tr></table></figure><h3 id="模板字符串标记-扩展"><a href="#模板字符串标记-扩展" class="headerlink" title="模板字符串标记[扩展]"></a>模板字符串标记[扩展]</h3><ul><li>模板字符串就是`${…}`</li><li>String.raw`&lt;p&gt;…&lt;/p&gt;` 加上 String.raw 标记后，里面的符号全部是字符串(无需转义)</li><li>自定义标记</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">var text &#x3D; myTag&#96;邓哥喜欢$&#123;love1&#125;，邓哥也喜欢$&#123;love2&#125;。&#96;;</span><br><span class="line">function myTag(parts) &#123;</span><br><span class="line">    const values &#x3D; Array.prototype.slice.apply(arguments).slice(1);</span><br><span class="line">    let str &#x3D; &quot;&quot;;</span><br><span class="line">    for (let i &#x3D; 0; i &lt; values.length; i++) &#123;</span><br><span class="line">        str +&#x3D; &#96;$&#123;parts[i]&#125;：$&#123;values[i]&#125;&#96;;</span><br><span class="line">        if (i &#x3D;&#x3D;&#x3D; values.length - 1) &#123;</span><br><span class="line">            str +&#x3D; parts[i + 1];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return str;</span><br><span class="line">&#125;</span><br><span class="line">console.log(text);  &#x2F;&#x2F;邓哥喜欢：秋葵，邓哥也喜欢：香菜。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">safe&#96;&lt;p&gt;xx&lt;&#x2F;p&gt;&#96; &#x2F;&#x2F;可以处理当内容为标签时出现的bug</span><br><span class="line"></span><br><span class="line">function safe(parts)&#123;</span><br><span class="line">    const values &#x3D; Array.prototype.slice.apply(arguments).slice(1);</span><br><span class="line">    let str &#x3D; &quot;&quot;;</span><br><span class="line">    for (let i &#x3D; 0; i &lt; values.length; i++) &#123;</span><br><span class="line">        const v &#x3D; values[i].replace(&#x2F;&lt;&#x2F;g, &quot;&lt;&quot;).replace(&#x2F;&gt;&#x2F;g, &quot;&gt;&quot;);</span><br><span class="line">        str +&#x3D; parts[i] + v;</span><br><span class="line">        if (i &#x3D;&#x3D;&#x3D; values.length - 1) &#123;</span><br><span class="line">            str +&#x3D; parts[i + 1];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="参数默认值"><a href="#参数默认值" class="headerlink" title="参数默认值"></a>参数默认值</h2><p>在书写形参时，直接给形参赋值，附的值即为默认值</p><p>这样一来，当调用函数时，如果没有给对应的参数赋值（给它的值是 undefined），则会自动使用默认值。</p><p>注意不要用 null，用 null 会转成 0</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function sum(a, b &#x3D; 1, c &#x3D; 2) &#123;</span><br><span class="line">    return a + b + c;</span><br><span class="line">&#125;</span><br><span class="line">console.log(sum(10, undefined, undefined))</span><br><span class="line">console.log(sum(1, undefined, 5))</span><br><span class="line">console.log(sum(11))&#x2F;&#x2F;后面都是undefined可以省略</span><br></pre></td></tr></table></figure><h3 id="对-arguments-的影响-扩展"><a href="#对-arguments-的影响-扩展" class="headerlink" title="对 arguments 的影响[扩展]"></a>对 arguments 的影响[扩展]</h3><p>只要给函数加上参数默认值，该函数会自动变量严格模式(use strict)下的规则：arguments 和形参脱离，尽量不要用 arguments。</p><h3 id="留意暂时性死区-扩展"><a href="#留意暂时性死区-扩展" class="headerlink" title="留意暂时性死区[扩展]"></a>留意暂时性死区[扩展]</h3><p>形参和 ES6 中的 let 或 const 声明一样，具有作用域，并且根据参数的声明顺序，存在暂时性死区。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function test(a &#x3D; b, b) &#123;</span><br><span class="line">    console.log(a, b);</span><br><span class="line">&#125;</span><br><span class="line">test(undefined, 2);&#x2F;&#x2F;报错，不能在b声明前使用</span><br></pre></td></tr></table></figure><h2 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h2><ul><li><strong>arguments 的缺陷：</strong><ol><li>如果和形参配合使用，容易导致混乱</li><li>从语义上，使用 arguments 获取参数，由于形参缺失，无法从函数定义上理解函数的真实意图</li></ol></li></ul><h3 id="剩余参数-1"><a href="#剩余参数-1" class="headerlink" title="剩余参数"></a>剩余参数</h3><p>ES6 的剩余参数专门用于收集末尾的所有参数，将其放置到一个形参数组中。</p><ul><li><strong>细节：</strong><ol><li>一个函数，仅能出现一个剩余参数</li><li>一个函数，如果有剩余参数，剩余参数必须是最后一个参数</li><li>以后尽量用这个，少用 arguments</li></ol></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function (...形参名)&#123;</span><br><span class="line">&#x2F;&#x2F;这里是收集所有参数，形成一个数组</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function (...args)&#123;</span><br><span class="line">console.log(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="展开运算符"><a href="#展开运算符" class="headerlink" title="展开运算符"></a>展开运算符</h2><p>将数组的每一项展开，依次作为参数传递，而不是把整个数组作为一个参数传递</p><ul><li>展开函数参数</li><li>展开数组 es6</li><li>展开对象(可用于混合对象) es7</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">console.log(sum(...numbers))&#x2F;&#x2F;展开参数，相当于传递了10个参数</span><br><span class="line">console.log(sum(1, 3, ...numbers, 3, 5))&#x2F;&#x2F;展开数组</span><br><span class="line">const arr2 &#x3D; [0, ...arr1, 1];</span><br><span class="line"></span><br><span class="line">const obj &#x3D; &#123; &#x2F;&#x2F;展开对象，混合对象</span><br><span class="line">    ...obj1,</span><br><span class="line">    ...obj2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="应用：剩余参数和展开运算符实现柯里化"><a href="#应用：剩余参数和展开运算符实现柯里化" class="headerlink" title="应用：剩余参数和展开运算符实现柯里化"></a>应用：剩余参数和展开运算符实现柯里化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function cal(a, b, c, d) &#123;</span><br><span class="line">    return a + b * c - d;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;curry：柯里化，用户固定某个函数的前面的参数，得到一个新的函数，新的函数调用时，接收剩余的参数</span><br><span class="line">function curry(func, ...args) &#123;</span><br><span class="line">    return function(...subArgs) &#123;</span><br><span class="line">        const allArgs &#x3D; [...args, ...subArgs];</span><br><span class="line">        if (allArgs.length &gt;&#x3D; func.length) &#123;</span><br><span class="line">            &#x2F;&#x2F;参数够了</span><br><span class="line">            return func(...allArgs);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F;参数不够，继续固定</span><br><span class="line">            return curry(func, ...allArgs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const newCal &#x3D; curry(cal, 1, 2)</span><br><span class="line"></span><br><span class="line">console.log(newCal(3, 4)) &#x2F;&#x2F; 1+2*3-4</span><br><span class="line">console.log(newCal(4, 5)) &#x2F;&#x2F; 1+2*4-5</span><br></pre></td></tr></table></figure><h2 id="明确函数的双重用途"><a href="#明确函数的双重用途" class="headerlink" title="明确函数的双重用途"></a>明确函数的双重用途</h2><p>ES6 提供了一个特殊的 API，可以使用该 API 在函数内部，判断该函数是否使用了 new 来调用</p><ul><li>new.target 判断是否使用 new 来调用<ul><li>是则返回函数体</li><li>反之返回 undefined</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function Person(firstName, lastName) &#123;</span><br><span class="line">    &#x2F;&#x2F;判断是否是使用new的方式来调用的函数</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; &#x2F;&#x2F;过去的判断方式</span><br><span class="line">    &#x2F;&#x2F; if (!(this instanceof Person)) &#123;</span><br><span class="line">    &#x2F;&#x2F;     throw new Error(&quot;该函数没有使用new来调用&quot;)</span><br><span class="line">    &#x2F;&#x2F; &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;新的完美方式</span><br><span class="line">    if (new.target &#x3D;&#x3D;&#x3D; undefined) &#123;</span><br><span class="line">        throw new Error(&quot;该函数没有使用new来调用&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    this.firstName &#x3D; firstName;</span><br><span class="line">    this.lastName &#x3D; lastName;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>回顾：this 指向</p><ol><li>通过对象调用函数，this 指向对象</li><li>直接调用函数，this 指向全局对象</li><li>如果通过 new 调用函数，this 指向新创建的对象</li><li>如果通过 apply、call、bind 调用函数，this 指向指定的数据</li><li>如果是 DOM 事件函数，this 指向事件源</li></ol><h3 id="使用语法"><a href="#使用语法" class="headerlink" title="使用语法"></a>使用语法</h3><p>箭头函数是一个函数表达式，理论上，任何使用函数表达式的场景都可以使用箭头函数。</p><p>完整语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(参数1, 参数2, ...)&#x3D;&gt;&#123;</span><br><span class="line">    &#x2F;&#x2F;函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>==<strong>如果参数只有一个，可以省略小括号</strong>==</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const print &#x3D; function(num)&#123;</span><br><span class="line">    console.log(num);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;箭头函数</span><br><span class="line">const print &#x3D; num &#x3D;&gt; &#123;</span><br><span class="line">    console.log(num)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>==<strong>如果箭头函数只有一条返回语句，可以省略大括号，和 return 关键字</strong>==</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var num &#x3D; function fn(a)&#123;</span><br><span class="line">    return a*2;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;箭头函数</span><br><span class="line">var num &#x3D; a &#x3D;&gt; a*2;</span><br></pre></td></tr></table></figure><ul><li>==<strong>如果是对象形式则写成 =&gt; ({……})</strong>==</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const sum &#x3D; function(a,b)&#123;</span><br><span class="line">    a: a,</span><br><span class="line">    b: b,</span><br><span class="line">    sum: a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const sum &#x3D; (a, b) &#x3D;&gt; (&#123;</span><br><span class="line">    a: a,</span><br><span class="line">    b: b,</span><br><span class="line">    sum: a + b</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="注意细节"><a href="#注意细节" class="headerlink" title="注意细节"></a>注意细节</h3><ul><li>箭头函数中，==不存在 this、arguments、new.target==，如果使用了，则使用的是函数外层的对应的 this、arguments、new.target</li><li>箭头函数没有原型</li><li>箭头函数不能作用构造函数使用</li></ul><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ol><li>临时性使用的函数，并不会可以调用它，比如：<ol><li>事件处理函数</li><li>异步处理函数</li><li>其他临时性的函数</li></ol></li><li>为了绑定外层 this 的函数</li><li>在不影响其他代码的情况下，保持代码的简洁，最常见的，数组方法中的回调函数</li><li>==<strong>注意：对象里面的函数不要用箭头函数，因为会产生 this 指向的问题，如下</strong>==<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const obj&#x3D;&#123;</span><br><span class="line">    a: 1,</span><br><span class="line">    b: 2,</span><br><span class="line">    c: function()&#123;</span><br><span class="line">        ……</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li>对于数组的应用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const numbers &#x3D; [3,4,5,6,7,8]</span><br><span class="line">const result &#x3D; numbers.filter(num &#x3D;&gt; num%2 !&#x3D;&#x3D; 0) &#x2F;&#x2F;过滤出为奇数的值</span><br><span class="line">    .map(num &#x3D;&gt; num * 2) &#x2F;&#x2F;映射，将数字乘以2</span><br><span class="line">    .reduce((a,b) &#x3D;&gt; a + b,0); &#x2F;&#x2F;累计，将数字累计相加</span><br></pre></td></tr></table></figure></li></ul><h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><h2 id="新增的对象字面量语法"><a href="#新增的对象字面量语法" class="headerlink" title="新增的对象字面量语法"></a>新增的对象字面量语法</h2><ol><li>成员速写</li></ol><p>如果对象字面量初始化时，成员的名称来自于一个变量，并且和变量的名称相同，则可以进行简写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function createUser(username,password)&#123;</span><br><span class="line">    const func &#x3D; function()&#123;</span><br><span class="line">        ……</span><br><span class="line">    &#125;</span><br><span class="line">    return &#123;</span><br><span class="line">        username, &#x2F;&#x2F;相当于username:username</span><br><span class="line">        password,</span><br><span class="line">        func &#x2F;&#x2F;相当于func:func</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">createUser(&#39;admin&#39;,&#39;123456&#39;);&#x2F;&#x2F;&#123;username:&#39;admin&#39;,password:&#39;123456&#39;,func:function()&#123;……&#125;&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>方法速写</li></ol><p>对象字面量初始化时，方法可以省略冒号和 function 关键字</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const user &#x3D; &#123;</span><br><span class="line">    name:&quot;姬成&quot;,</span><br><span class="line">    age:100,</span><br><span class="line">    func()&#123;……&#125; &#x2F;&#x2F;相当于func:function()&#123;……&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>计算属性名</li></ol><p>有的时候，初始化对象时，某些属性名可能来自于某个表达式的值，在 ES6，可以使用中括号来表示该属性名是通过计算得到的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const prop1 &#x3D; &quot;name&quot;;</span><br><span class="line">const prop2 &#x3D; &quot;age&quot;;</span><br><span class="line">const prop3 &#x3D; &quot;func&quot;;</span><br><span class="line"></span><br><span class="line">const user &#x3D; &#123;</span><br><span class="line">    [prop1]:&quot;姬成&quot;,</span><br><span class="line">    [prop2]:18,</span><br><span class="line">    [prop3]():&#123;</span><br><span class="line">        console.log(this[prop1],this[prop2])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">user[prop3]();&#x2F;&#x2F;姬成,18</span><br><span class="line">console.log(uesr);&#x2F;&#x2F;&#123;name:&quot;姬成&quot;,age:18,func:f&#125;</span><br></pre></td></tr></table></figure><h2 id="Object-的新增-API"><a href="#Object-的新增-API" class="headerlink" title="Object 的新增 API"></a>Object 的新增 API</h2><p>Object 是一个构造函数（说对象的去反省）</p><ul><li>Object.is 用于判断两个对象是否相等<ul><li>基本上跟严格相等（===）是一致的，除了以下两点：</li><li>NaN 和 NaN 相等(=== 是 false)</li><li>+0 和-0 不相等(=== 是 true)</li></ul></li><li>Object.assign 用于混合对象(es6 的方法，不推荐用)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const obj &#x3D; &#123; &#x2F;&#x2F;这里是展开运算符，es7的方法，最常用</span><br><span class="line">    ...obj1,</span><br><span class="line">    ...obj2</span><br><span class="line">&#125;</span><br><span class="line">const obj &#x3D; Object.assign(obj1,obj2);&#x2F;&#x2F;obj1会被改动，可以用巧妙的方法避免</span><br><span class="line">const obj &#x3D; Object.assign(&#123;&#125;,obj1,obj2);</span><br></pre></td></tr></table></figure></li></ul><ol start="3"><li>Object.getOwnPropertyNames 的枚举顺序</li></ol><p>Object.getOwnPropertyNames 方法之前就存在，只不过，官方没有明确要求，对属性的顺序如何排序，如何排序，完全由浏览器厂商决定。</p><p>ES6 规定了该方法返回的数组的排序方式如下：</p><ul><li>先排数字，并按照升序排序</li><li>再排其他，按照书写顺序排序</li></ul><ol start="4"><li>Object.setPrototypeOf</li></ol><p>该函数用于设置某个对象的隐式原型</p><p>比如： Object.setPrototypeOf(obj1, obj2)</p><p>相当于： <code>obj1.__proto__ = obj2</code></p><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>面向对象：一种编程思想，跟具体的语言</p><p>对比面向过程：</p><ul><li>面向过程：思考的切入点是功能的步骤</li><li>面向对象：思考的切入点是对象的划分</li></ul><h2 id="类：构造函数的语法糖"><a href="#类：构造函数的语法糖" class="headerlink" title="类：构造函数的语法糖"></a>类：构造函数的语法糖</h2><ul><li>传统的构造函数的问题<ol><li>属性和原型方法定义分离，降低了可读性</li><li>原型成员可以被遍历</li><li>默认情况下，构造函数仍然可以被当作普通函数使用</li></ol></li></ul><h3 id="类的特点"><a href="#类的特点" class="headerlink" title="类的特点"></a>类的特点</h3><ol><li>类声明不会被提升(window.不会找到)，与 let 和 const 一样，存在暂时性死区(先定义再使用)</li><li>类中的所有代码均在严格模式下执行(自动加的)</li><li>类的所有方法都是不可枚举的</li><li>类的所有方法都无法被当作构造函数使用</li><li>类的构造器必须使用 new 来调用，否则会报错（没有 new，不能调用类构造函数）</li></ol><h3 id="类的写法"><a href="#类的写法" class="headerlink" title="类的写法"></a>类的写法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;原先写法</span><br><span class="line">function Animal(type, name, age, sex) &#123;</span><br><span class="line">    this.type &#x3D; type;</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">    this.age &#x3D; age;</span><br><span class="line">    this.sex &#x3D; sex;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;定义实例方法（原型方法）</span><br><span class="line">Animal.prototype.print &#x3D; function () &#123;</span><br><span class="line">    console.log(&#96;【种类】：$&#123;this.type&#125;&#96;);</span><br><span class="line">    console.log(&#96;【名字】：$&#123;this.name&#125;&#96;);</span><br><span class="line">    console.log(&#96;【年龄】：$&#123;this.age&#125;&#96;);</span><br><span class="line">    console.log(&#96;【性别】：$&#123;this.sex&#125;&#96;);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;类的写法</span><br><span class="line">class Animal &#123;</span><br><span class="line">    constructor(type, name, age, sex) &#123;</span><br><span class="line">        this.type &#x3D; type;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">        this.age &#x3D; age;</span><br><span class="line">        this.sex &#x3D; sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    print() &#123;</span><br><span class="line">        console.log(&#96;【种类】：$&#123;this.type&#125;&#96;);</span><br><span class="line">        console.log(&#96;【名字】：$&#123;this.name&#125;&#96;);</span><br><span class="line">        console.log(&#96;【年龄】：$&#123;this.age&#125;&#96;);</span><br><span class="line">        console.log(&#96;【性别】：$&#123;this.sex&#125;&#96;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类的其他书写方式"><a href="#类的其他书写方式" class="headerlink" title="类的其他书写方式"></a>类的其他书写方式</h2><ol><li><p>可计算的成员名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">const printName &#x3D; &quot;print&quot;;</span><br><span class="line"></span><br><span class="line">class Animal &#123;</span><br><span class="line">    constructor(type, name, age, sex) &#123;</span><br><span class="line">        this.type &#x3D; type;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">        this.age &#x3D; age;</span><br><span class="line">        this.sex &#x3D; sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [printName]() &#123;</span><br><span class="line">        console.log(&#96;【种类】：$&#123;this.type&#125;&#96;);</span><br><span class="line">        console.log(&#96;【名字】：$&#123;this.name&#125;&#96;);</span><br><span class="line">        console.log(&#96;【年龄】：$&#123;this.age&#125;&#96;);</span><br><span class="line">        console.log(&#96;【性别】：$&#123;this.sex&#125;&#96;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const a &#x3D; new Animal(&quot;狗&quot;, &quot;旺财&quot;, 3, &quot;男&quot;);</span><br><span class="line">a[printName]();</span><br></pre></td></tr></table></figure></li><li><p>getter 和 setter</p></li></ol><p>Object.defineProperty 可定义某个对象成员属性的读取和设置</p><p>使用 getter 和 setter 控制的属性，不在原型上，相当于 obj.xx</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">const printName &#x3D; &quot;print&quot;;</span><br><span class="line">class Animal &#123;</span><br><span class="line">    constructor(type, name, age, sex) &#123;</span><br><span class="line">        this.type &#x3D; type;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">        this.age &#x3D; age;</span><br><span class="line">        this.sex &#x3D; sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;创建一个age属性，并给它加上getter，读取该属性时，会运行该函数</span><br><span class="line">    get age() &#123;</span><br><span class="line">        return this._age + &quot;岁&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;创建一个age属性，并给它加上setter，给该属性赋值时，会运行该函数</span><br><span class="line">    set age(age) &#123;</span><br><span class="line">        if (typeof age !&#x3D;&#x3D; &quot;number&quot;) &#123;</span><br><span class="line">            throw new TypeError(&quot;age property must be a number&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (age &lt; 0) &#123;</span><br><span class="line">            age &#x3D; 0;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (age &gt; 1000) &#123;</span><br><span class="line">            age &#x3D; 1000;</span><br><span class="line">        &#125;</span><br><span class="line">        this._age &#x3D; age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [printName]() &#123;</span><br><span class="line">        console.log(&#96;【种类】：$&#123;this.type&#125;&#96;);</span><br><span class="line">        console.log(&#96;【名字】：$&#123;this.name&#125;&#96;);</span><br><span class="line">        console.log(&#96;【年龄】：$&#123;this.age&#125;&#96;);</span><br><span class="line">        console.log(&#96;【性别】：$&#123;this.sex&#125;&#96;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var a &#x3D; new Animal(&quot;狗&quot;, &quot;旺财&quot;, 3, &quot;男&quot;);</span><br><span class="line">console.log(a.age); &#x2F;&#x2F; 3岁</span><br><span class="line">a.age &#x3D; 4; &#x2F;&#x2F;age赋值为4</span><br><span class="line">a.print(); &#x2F;&#x2F;打印信息</span><br><span class="line">&#x2F;&#x2F;备注：getter\setter也可以通过成员名的方式实现，但是哪个必须调用方法名，不如这个直观</span><br></pre></td></tr></table></figure><ol start="3"><li>静态成员</li></ol><p>构造函数本身的成员</p><p>使用 static 关键字定义的成员即静态成员</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Chess &#123;</span><br><span class="line">    constructor(name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line">    static width &#x3D; 50;</span><br><span class="line">    static height &#x3D; 50;</span><br><span class="line">    static method() &#123;</span><br><span class="line">    ……</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;调用</span><br><span class="line">console.log(Chess.width)</span><br><span class="line">console.log(Chess.height)</span><br><span class="line">Chess.method();</span><br></pre></td></tr></table></figure><ol start="4"><li>字段初始化器（ES7）</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Test &#123;</span><br><span class="line">    static a &#x3D; 1; &#x2F;&#x2F;这里是加静态属性</span><br><span class="line">    b &#x3D; 2; &#x2F;&#x2F;此处相当于 在构造方法里面加 this.b &#x3D; 2;</span><br><span class="line">    c &#x3D; 3;</span><br><span class="line"></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        this.d &#x3D; this.b + this.c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    print &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">        console.log(this.a) &#x2F;&#x2F;用箭头函数时，this指向当前对象</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const t &#x3D; new Test();</span><br><span class="line">console.log(t)</span><br></pre></td></tr></table></figure><p>注意：<br>1). 使用 static 的字段初始化器，添加的是静态成员<br>2). 没有使用 static 的字段初始化器，添加的成员位于对象上<br>3). 箭头函数在字段初始化器位置上，指向当前对象</p><ol start="5"><li>类表达式</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const A &#x3D; class &#123; &#x2F;&#x2F;匿名类，类表达式</span><br><span class="line">    a &#x3D; 1;</span><br><span class="line">    b &#x3D; 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const a &#x3D; new A();</span><br><span class="line">console.log(a)</span><br></pre></td></tr></table></figure><ol start="6"><li>[扩展]装饰器（ES7）(Decorator)</li></ol><p>横切关注点</p><p>装饰器的本质是一个函数</p><p>目前还没有很好的支持</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Test &#123;</span><br><span class="line"></span><br><span class="line">    @Obsolete</span><br><span class="line">    print() &#123;</span><br><span class="line">        console.log(&quot;print方法&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Obsolete(target, methodName, descriptor) &#123;</span><br><span class="line">    &#x2F;&#x2F; function Test</span><br><span class="line">    &#x2F;&#x2F; print</span><br><span class="line">    &#x2F;&#x2F; &#123; value: function print()&#123;&#125;, ... &#125;</span><br><span class="line">    &#x2F;&#x2F; console.log(target, methodName, descriptor);</span><br><span class="line">    const oldFunc &#x3D; descriptor.value</span><br><span class="line">    descriptor.value &#x3D; function (...args) &#123;</span><br><span class="line">        console.warn(&#96;$&#123;methodName&#125;方法已过时&#96;);</span><br><span class="line">        oldFunc.apply(this, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h2><p>如果两个类 A 和 B，如果可以描述为：B 是 A，则，A 和 B 形成继承关系</p><p>如果 B 是 A，则：</p><ol><li>B 继承自 A</li><li>A 派生 B</li><li>B 是 A 的子类</li><li>A 是 B 的父类</li></ol><p>如果 A 是 B 的父类，则 B 会自动拥有 A 中的所有实例成员。</p><h3 id="关键字："><a href="#关键字：" class="headerlink" title="关键字："></a>关键字：</h3><ul><li>extends：继承，用于类的定义</li><li>super<ul><li>直接当作函数调用，表示父类构造函数</li><li>如果当作对象使用，则表示父类的原型</li><li>注意：ES6 要求，如果定义了 constructor，并且该类是子类，则必须在 constructor 的第一行手动调用父类的构造函数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Dog extends Animal &#123; &#x2F;&#x2F; Dog 继承自 Animal</span><br><span class="line">constructor(name, age, sex) &#123;</span><br><span class="line">    super(&quot;犬类&quot;, name, age, sex);&#x2F;&#x2F;必须先调用一次super，否则会报错（必须要在函数的最开始位置调用父类的构造函数）</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果子类不写 constructor，则会有默认的构造器，该构造器需要的参数和父类一致，并且自动调用父类构造器</li></ul></li></ul></li></ul><h3 id="继承的写法"><a href="#继承的写法" class="headerlink" title="继承的写法"></a>继承的写法</h3><ul><li>原来的方式</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">function Animal(type, name, age, sex) &#123;</span><br><span class="line">    this.type &#x3D; type;</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">    this.age &#x3D; age;</span><br><span class="line">    this.sex &#x3D; sex;</span><br><span class="line">&#125;</span><br><span class="line">Animal.prototype.print &#x3D; function () &#123;</span><br><span class="line">    console.log(&#96;【种类】：$&#123;this.type&#125;&#96;);</span><br><span class="line">    console.log(&#96;【名字】：$&#123;this.name&#125;&#96;);</span><br><span class="line">    console.log(&#96;【年龄】：$&#123;this.age&#125;&#96;);</span><br><span class="line">    console.log(&#96;【性别】：$&#123;this.sex&#125;&#96;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Dog(name, age, sex) &#123;</span><br><span class="line">    &#x2F;&#x2F;借用父类的构造函数</span><br><span class="line">    Animal.call(this, &quot;犬类&quot;, name, age, sex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Object.setPrototypeOf(Dog.prototype, Animal.prototype);</span><br><span class="line">&#x2F;&#x2F;将Dog.prototype的隐式原型指向Animal的原型，使继承关系完整</span><br><span class="line"></span><br><span class="line">const d &#x3D; new Dog(&quot;旺财&quot;, 3, &quot;公&quot;);</span><br><span class="line">d.print();</span><br><span class="line">console.log(d);</span><br></pre></td></tr></table></figure><ul><li>类的继承（ES6 的写法）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">    constructor(type, name, age, sex) &#123;</span><br><span class="line">        this.type &#x3D; type;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">        this.age &#x3D; age;</span><br><span class="line">        this.sex &#x3D; sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    print() &#123;</span><br><span class="line">        console.log(&#96;【种类】：$&#123;this.type&#125;&#96;);</span><br><span class="line">        console.log(&#96;【名字】：$&#123;this.name&#125;&#96;);</span><br><span class="line">        console.log(&#96;【年龄】：$&#123;this.age&#125;&#96;);</span><br><span class="line">        console.log(&#96;【性别】：$&#123;this.sex&#125;&#96;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    jiao()&#123;</span><br><span class="line">        throw new Error(&quot;动物怎么叫的？&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dog extends Animal &#123; &#x2F;&#x2F; Dog 继承自 Animal</span><br><span class="line">    constructor(name, age, sex) &#123;</span><br><span class="line">        super(&quot;犬类&quot;, name, age, sex);</span><br><span class="line">        &#x2F;&#x2F; 子类特有的属性</span><br><span class="line">        this.loves &#x3D; &quot;吃骨头&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    print()&#123;</span><br><span class="line">        &#x2F;&#x2F;调用父类的print</span><br><span class="line">        super.print();</span><br><span class="line">        &#x2F;&#x2F;自己特有的代码</span><br><span class="line">        console.log(&#96;【爱好】：$&#123;this.loves&#125;&#96;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;同名方法，会覆盖父类</span><br><span class="line">    jiao()&#123;</span><br><span class="line">        console.log(&quot;旺旺！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const d &#x3D; new Dog(&quot;旺财&quot;, 3, &quot;公&quot;);</span><br><span class="line">d.print(); &#x2F;&#x2F; 打印自己的print()</span><br><span class="line">console.log(d) &#x2F;&#x2F; 打印d的所有属性</span><br><span class="line">d.jiao(); &#x2F;&#x2F; 旺旺</span><br></pre></td></tr></table></figure><h3 id="【小知识】"><a href="#【小知识】" class="headerlink" title="【小知识】"></a>【小知识】</h3><ul><li>用 JS 制作抽象类<ul><li>抽象类：一般是父类，不能通过该类创建对象</li></ul></li><li>正常情况下，this 的指向，this 始终指向具体的类的对象</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">    constructor(type, name, age, sex) &#123;</span><br><span class="line">        if (new.target &#x3D;&#x3D;&#x3D; Animal) &#123; &#x2F;&#x2F;如果构造函数是Animal</span><br><span class="line">            throw new TypeError(&quot;你不能直接创建Animal的对象，应该通过子类创建&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        this.type &#x3D; type;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">        this.age &#x3D; age;</span><br><span class="line">        this.sex &#x3D; sex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Dog extends Animal &#123;</span><br><span class="line">    constructor(name, age, sex) &#123;</span><br><span class="line">        super(&quot;犬类&quot;, name, age, sex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">const a &#x3D; new Animal(&quot;狗&quot;,&quot;旺柴&quot;,2,&quot;公&quot;); &#x2F;&#x2F; 会报错 你不能……</span><br><span class="line">const a &#x3D; new Dog(&quot;狗&quot;,&quot;旺柴&quot;,2,&quot;公&quot;); &#x2F;&#x2F;不会报错</span><br></pre></td></tr></table></figure><h1 id="解构"><a href="#解构" class="headerlink" title="解构"></a>解构</h1><p>使用 ES6 的一种语法规则，将一个对象或数组的某个属性提取到某个变量中。</p><h2 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h2><ul><li>写法：<code>let &#123;name,age,sex,address&#125; = user;</code></li><li>当对象没有{}里面的属性时，默认 undefined</li><li>在解构中使用默认值：<code>&#123;同名变量 = 默认值&#125; </code></li><li>非同名属性解构：<code>&#123;属性名:变量名&#125;</code></li><li><strong>解构不会对被解构的目标造成任何影响</strong></li><li>深层次解构：<code>let &#123;address:&#123;province&#125;&#125; = user</code>，相当于定义变量 province,把属性值同名属性赋给变量</li><li>可配合展开运算符</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">const user &#x3D; &#123;</span><br><span class="line">    name: &quot;kevin&quot;,</span><br><span class="line">    age: 11,</span><br><span class="line">    sex: &quot;男&quot;,</span><br><span class="line">    address: &#123;</span><br><span class="line">        province: &quot;四川&quot;,</span><br><span class="line">        city: &quot;成都&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let name,age,sex,address; &#x2F;&#x2F;定义4个变量</span><br><span class="line">(&#123;name,age,sex,address&#125; &#x3D; user);&#x2F;&#x2F;把user同名属性赋值到变量里面</span><br><span class="line"></span><br><span class="line">let &#123;name,age,sex,address&#125; &#x3D; user; &#x2F;&#x2F;简写，意义同上</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;在解构中使用默认值</span><br><span class="line">let &#123;name,age,sex &#x3D; &#39;男&#39;,address&#125; &#x3D; user; &#x2F;&#x2F;如果没有sex属性，sex变量默认为男</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;非同名属性解构    &#123;属性名:变量名&#125;</span><br><span class="line">let &#123; name, age,sex: gender, address &#125; &#x3D; user;&#x2F;&#x2F;把sex属性值给变量gender</span><br><span class="line">console.log(name, age, gender, address)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;深层次解构    &#123;属性名:变量名&#125;</span><br><span class="line">let &#123; name, age,sex, address:&#123;province,city&#125; &#125; &#x3D; user;&#x2F;&#x2F;把sex属性值给变量gender</span><br><span class="line">console.log(name, age, gender, province,city); &#x2F;&#x2F;kevin 11 男 四川 成都</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;展开运算符 解构出name，然后，剩余的所有属性，放到一个新的对象中，变量名为obj</span><br><span class="line">&#x2F;&#x2F; name: kevin</span><br><span class="line">&#x2F;&#x2F; obj : &#123;age:11, sex:&quot;男&quot;, address:&#123;...&#125;&#125;</span><br><span class="line"></span><br><span class="line">const &#123; name, ...obj &#125; &#x3D; user;</span><br></pre></td></tr></table></figure><h2 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构"></a>数组解构</h2><ul><li>写法：<code>const [n1, n2] = numbers; </code></li><li>对象的解构方法也行得通</li><li>其他用法同对象解构一致，用法在下面</li><li>可配合展开运算符来用</li><li>小题目：不用第三个变量交换变量数据：[a,b] = [b,a]</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">const numbers &#x3D; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 用对象的方法来解构，数组本身也是对象</span><br><span class="line">const &#123;</span><br><span class="line">    0: n1,</span><br><span class="line">    1: n2</span><br><span class="line">&#125; &#x3D; numbers;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let n1, n2;</span><br><span class="line">([n1, n2] &#x3D; numbers); &#x2F;&#x2F; 数组解构方法</span><br><span class="line"></span><br><span class="line">const [n1, n2] &#x3D; numbers;&#x2F;&#x2F;数组解构简写方法。</span><br><span class="line"></span><br><span class="line">const numbers &#x3D; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, [1, 2, 3, 4]];</span><br><span class="line">&#x2F;&#x2F;得到numbers下标为4的数组中的下标为2的数据，放到变量n中</span><br><span class="line">const [, , , , [, , n]] &#x3D; numbers;</span><br><span class="line"></span><br><span class="line">const numbers &#x3D; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &#123;</span><br><span class="line">    a: 1,</span><br><span class="line">    b: 2</span><br><span class="line">&#125;];</span><br><span class="line">&#x2F;&#x2F;得到numbers下标为4的数组的属性a，赋值给变量A</span><br><span class="line">const [, , , , &#123; a: A &#125;] &#x3D; numbers;</span><br><span class="line">const &#123; a: A &#125; &#x3D; numbers[4];&#x2F;&#x2F;和上面意义相同，灵活的写法</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 展开运算符： 得到数组前两项，分别放到变量a和b中，然后剩余的所有数据放到数组nums</span><br><span class="line">const numbers &#x3D; [324, 7, 23, 5, 3243];</span><br><span class="line">const [a, b, ...nums] &#x3D; numbers;</span><br></pre></td></tr></table></figure><h3 id="对象数组解构练习题"><a href="#对象数组解构练习题" class="headerlink" title="对象数组解构练习题"></a>对象数组解构练习题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">const article &#x3D; &#123;</span><br><span class="line">          title: &quot;文章标题&quot;,</span><br><span class="line">          content: &quot;文章内容&quot;,</span><br><span class="line">          comments: [&#123;</span><br><span class="line">              content: &quot;评论1&quot;,</span><br><span class="line">              user: &#123;</span><br><span class="line">                  id: 1,</span><br><span class="line">                  name: &quot;用户名1&quot;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;, &#123;</span><br><span class="line">              content: &quot;评论2&quot;,</span><br><span class="line">              user: &#123;</span><br><span class="line">                  id: 2,</span><br><span class="line">                  name: &quot;用户名2&quot;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;]</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F;解构出第二条评论的用户名和评论内容</span><br><span class="line">      &#x2F;&#x2F; name:&quot;用户名2&quot;  content:&quot;评论2&quot;</span><br><span class="line"></span><br><span class="line">      const &#123;</span><br><span class="line">          comments: [, &#123;</span><br><span class="line">              content,</span><br><span class="line">              user: &#123;</span><br><span class="line">                  name</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;]</span><br><span class="line">      &#125; &#x3D; article;</span><br><span class="line">      console.log(content, name);&#x2F;&#x2F;评论2 用户名2</span><br><span class="line"></span><br><span class="line">      const [content,user&#123;name&#125;] &#x3D; article.commnents[1]; &#x2F;&#x2F;这么写也可以，灵活运用</span><br></pre></td></tr></table></figure><h2 id="参数解构"><a href="#参数解构" class="headerlink" title="参数解构"></a>参数解构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;解构传入对象的参数</span><br><span class="line">function print(&#123; name, age, sex, address: &#123;</span><br><span class="line">    province,</span><br><span class="line">    city</span><br><span class="line">&#125; &#125;) &#123;</span><br><span class="line">    console.log(&#96;姓名：$&#123;name&#125;&#96;)</span><br><span class="line">    console.log(&#96;年龄：$&#123;age&#125;&#96;)</span><br><span class="line">    console.log(&#96;性别：$&#123;sex&#125;&#96;)</span><br><span class="line">    console.log(&#96;身份：$&#123;province&#125;&#96;)</span><br><span class="line">    console.log(&#96;城市：$&#123;city&#125;&#96;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const user &#x3D; &#123;</span><br><span class="line">    name: &quot;kevin&quot;,</span><br><span class="line">    age: 11,</span><br><span class="line">    sex: &quot;男&quot;,</span><br><span class="line">    address: &#123;</span><br><span class="line">        province: &quot;四川&quot;,</span><br><span class="line">        city: &quot;成都&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">print(user)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;给传入对象设置默认值</span><br><span class="line">&#x2F;&#x2F;设置默认的method和url属性</span><br><span class="line">&#x2F;&#x2F;如果什么都没传入，默认是空对象</span><br><span class="line">&#x2F;&#x2F;如果不写默认为空对象的话，会报错（不能解构出属性method...）</span><br><span class="line">function ajax(&#123;</span><br><span class="line">    method &#x3D; &quot;get&quot;,</span><br><span class="line">    url &#x3D; &quot;&#x2F;&quot;</span><br><span class="line">&#125; &#x3D; &#123;&#125;) &#123;</span><br><span class="line">    console.log(method, url)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ajax()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h1><h2 id="普通符号"><a href="#普通符号" class="headerlink" title="普通符号"></a>普通符号</h2><p>符号是 ES6 新增的一个数据类型，它通过使用函数 <code>Symbol(符号描述)</code> 来创建</p><p>符号设计的初衷，是为了给对象设置私有属性</p><p>私有属性：只能在对象内部使用，外面无法使用</p><h3 id="符号具有以下特点："><a href="#符号具有以下特点：" class="headerlink" title="符号具有以下特点："></a>符号具有以下特点：</h3><ul><li>没有字面量</li><li>使用 typeof 得到的类型是 symbol</li><li><strong>每次调用 Symbol 函数得到的符号永远不相等，无论符号名是否相同</strong></li><li>符号可以作为对象的属性名存在，这种属性称之为符号属性<ul><li>开发者可以通过精心的设计，让这些属性无法通过常规方式被外界访问，<strong>实现私有属性</strong></li><li><strong>符号属性是不能枚举的</strong>，因此在 for-in 循环中无法读取到符号属性，Object.keys 方法也无法读取到符号属性名</li><li>Object.getOwnPropertyNames 尽管可以得到所有无法枚举的属性，但是仍然无法读取到符号属性</li><li>ES6 新增 Object.getOwnPropertySymbols 方法，可以读取符号</li></ul></li><li><strong>符号无法被隐式转换</strong>，因此不能被用于数学运算、字符串拼接或其他隐式转换的场景，但<strong>符号可以显式的转换为字符串</strong>，通过 String 构造函数进行转换即可，console.log 之所以可以输出符号，是它在内部进行了显式转换</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 实现私有属性</span><br><span class="line">const hero &#x3D; (function () &#123;</span><br><span class="line">    const getRandom &#x3D; Symbol();</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">        attack: 30,</span><br><span class="line">        hp: 300,</span><br><span class="line">        defence: 10,</span><br><span class="line">        gongji() &#123; &#x2F;&#x2F;攻击</span><br><span class="line">            &#x2F;&#x2F;伤害：攻击力*随机数（0.8~1.1)</span><br><span class="line">            const dmg &#x3D; this.attack * this[getRandom](0.8, 1.1);</span><br><span class="line">            console.log(dmg);</span><br><span class="line">        &#125;,</span><br><span class="line">        [getRandom](min, max) &#123; &#x2F;&#x2F;根据最小值和最大值产生一个随机数</span><br><span class="line">            return Math.random() * (max - min) + min;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">console.log(hero);</span><br><span class="line">console.log(hero.getRandom);&#x2F;&#x2F;访问不到</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;访问符号属性</span><br><span class="line">const syb &#x3D; Symbol();</span><br><span class="line"></span><br><span class="line">const obj &#x3D; &#123;</span><br><span class="line">    [syb]: 1,</span><br><span class="line">    a: 2,</span><br><span class="line">    b: 3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (const prop in obj) &#123;</span><br><span class="line">    console.log(prop)</span><br><span class="line">&#125;</span><br><span class="line">console.log(Object.keys(obj)) &#x2F;&#x2F;得到对象的所有属性名，[&quot;a&quot;,&quot;b&quot;]</span><br><span class="line">console.log(Object.getOwnPropertyNames(obj)) &#x2F;&#x2F;能得到无法枚举的属性名，但是也无法读取符号[&quot;a&quot;,&quot;b&quot;]</span><br><span class="line">const sybs &#x3D; Object.getOwnPropertySymbols(obj);&#x2F;&#x2F;得到的是一个符号属性的数组</span><br><span class="line">console.log(sybs, sybs[0] &#x3D;&#x3D;&#x3D; syb)&#x2F;&#x2F; Symbol() true</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;使用符号属性</span><br><span class="line">const Hero &#x3D; (() &#x3D;&gt; &#123;</span><br><span class="line">    const getRandom &#x3D; Symbol();</span><br><span class="line"></span><br><span class="line">    return class &#123;</span><br><span class="line">        constructor(attack, hp, defence) &#123;</span><br><span class="line">            this.attack &#x3D; attack;</span><br><span class="line">            this.hp &#x3D; hp;</span><br><span class="line">            this.defence &#x3D; defence;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        gongji() &#123;</span><br><span class="line">            &#x2F;&#x2F;伤害：攻击力*随机数（0.8~1.1)</span><br><span class="line">            const dmg &#x3D; this.attack * this[getRandom](0.8, 1.1);</span><br><span class="line">            console.log(dmg);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        [getRandom](min, max) &#123; &#x2F;&#x2F;根据最小值和最大值产生一个随机数</span><br><span class="line">            return Math.random() * (max - min) + min;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">const h &#x3D; new Hero(3, 6, 3);</span><br><span class="line">const sybs &#x3D; Object.getOwnPropertySymbols(Hero.prototype);</span><br><span class="line">const prop &#x3D; sybs[0];</span><br><span class="line">console.log(h[prop](3, 5)) &#x2F;&#x2F; -&gt; getRandom(3,5)</span><br></pre></td></tr></table></figure><h2 id="共享符号"><a href="#共享符号" class="headerlink" title="共享符号"></a>共享符号</h2><p>根据某个符号名称（符号描述）能够得到同一个符号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Symbol.for(&quot;符号名&#x2F;符号描述&quot;)  &#x2F;&#x2F;获取共享符号</span><br><span class="line"></span><br><span class="line">const syb1 &#x3D; Symbol.for(&quot;abc&quot;);</span><br><span class="line">const syb2 &#x3D; Symbol.for(&quot;abc&quot;);</span><br><span class="line">console.log(syb1 &#x3D;&#x3D;&#x3D; syb2)&#x2F;&#x2F;true</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;使用共享符号当作属性</span><br><span class="line">const obj &#x3D; &#123;</span><br><span class="line">    a: 1,</span><br><span class="line">    b: 2,</span><br><span class="line">    [Symbol.for(&quot;c&quot;)]: 3</span><br><span class="line">&#125;</span><br><span class="line">console.log(obj[Symbol.for(&quot;c&quot;)]);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="知名符号"><a href="#知名符号" class="headerlink" title="知名符号"></a>知名符号</h2><p>知名符号是一些具有特殊含义的共享符号，通过 Symbol 的静态属性得到</p><p>ES6 延续了 ES5 的思想：减少魔法，暴露内部实现！</p><p>因此，ES6 用知名符号暴露了某些场景的内部实现</p><ol><li>Symbol.hasInstance</li></ol><p>该符号用于定义构造函数的静态成员，它将影响 instanceof 的判定</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">obj instanceof A</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;等效于</span><br><span class="line"></span><br><span class="line">A[Symbol.hasInstance](obj) &#x2F;&#x2F; Function.prototype[Symbol.hasInstance]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;案例</span><br><span class="line">function A() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Object.defineProperty(A, Symbol.hasInstance, &#123; &#x2F;&#x2F;使用知名符号修改</span><br><span class="line">    value: function (obj) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">const obj &#x3D; new A();</span><br><span class="line"></span><br><span class="line">console.log(obj instanceof A); &#x2F;&#x2F;默认true , 修改后为false</span><br><span class="line">console.log(A[Symbol.hasInstance](obj)); &#x2F;&#x2F;默认true , 修改后为false</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>[扩展] Symbol.isConcatSpreadable -&gt; concat 是否拆分</li></ol><p>该知名符号会影响数组的 concat 方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">const arr &#x3D; [3];</span><br><span class="line">const arr2 &#x3D; [5, 6, 7, 8];</span><br><span class="line"></span><br><span class="line">arr2[Symbol.isConcatSpreadable] &#x3D; false;</span><br><span class="line"></span><br><span class="line">const result &#x3D; arr.concat(56, arr2)</span><br><span class="line"></span><br><span class="line">console.log(result)</span><br><span class="line">&#x2F;&#x2F;默认  [3, 56, 5, 6, 7, 8]</span><br><span class="line">&#x2F;&#x2F;修改为false后不拆分</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;对象也适用</span><br><span class="line">const arr &#x3D; [1];</span><br><span class="line">const obj &#x3D; &#123;</span><br><span class="line">    0: 3,</span><br><span class="line">    1: 4,</span><br><span class="line">    length: 2,</span><br><span class="line">    [Symbol.isConcatSpreadable]: true</span><br><span class="line"></span><br><span class="line">const result &#x3D; arr.concat(2, obj)</span><br><span class="line">console.log(result)</span><br><span class="line">&#x2F;&#x2F;默认应该为 [1,2,&#123;……&#125;]</span><br><span class="line">&#x2F;&#x2F;修改为true拆分后，为[1,2,3,4]</span><br></pre></td></tr></table></figure><ol start="3"><li>[扩展] Symbol.toPrimitive -&gt;影响类型转换结果</li></ol><p>该知名符号会影响类型转换的结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Temperature &#123;</span><br><span class="line">    constructor(degree) &#123;</span><br><span class="line">        this.degree &#x3D; degree;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [Symbol.toPrimitive](type) &#123;</span><br><span class="line">        if (type &#x3D;&#x3D;&#x3D; &quot;default&quot;) &#123; &#x2F;&#x2F;默认转换行为</span><br><span class="line">            return this.degree + &quot;摄氏度&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (type &#x3D;&#x3D;&#x3D; &quot;number&quot;) &#123;&#x2F;&#x2F;转换为数字</span><br><span class="line">            return this.degree;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (type &#x3D;&#x3D;&#x3D; &quot;string&quot;) &#123;&#x2F;&#x2F;转换成字符串</span><br><span class="line">            return this.degree + &quot;℃&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const t &#x3D; new Temperature(30);</span><br><span class="line">&#x2F;&#x2F;默认为[Object object]，默认转换过程，t.value -&gt; t.toString</span><br><span class="line">&#x2F;&#x2F;修改后为 30摄氏度！</span><br><span class="line">console.log(t + &quot;!&quot;);</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F;转换为数字，默认为NAN</span><br><span class="line"> &#x2F;&#x2F;修改后为 15</span><br><span class="line">console.log(t &#x2F; 2);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;转换为字符串，默认为[Object object]</span><br><span class="line">&#x2F;&#x2F;修改后为30℃</span><br><span class="line">console.log(String(t));</span><br></pre></td></tr></table></figure><ol start="4"><li>[扩展] Symbol.toStringTag</li></ol><p>该知名符号会影响 Object.prototype.toString 的返回值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line"></span><br><span class="line">    [Symbol.toStringTag] &#x3D; &quot;Person&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const p &#x3D; new Person();</span><br><span class="line"></span><br><span class="line">const arr &#x3D; [32424, 45654, 32]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;默认是[Object object],修改后为[Object Person]</span><br><span class="line">console.log(Object.prototype.toString.apply(p));</span><br><span class="line"></span><br><span class="line">console.log(Object.prototype.toString.apply(arr));</span><br></pre></td></tr></table></figure><ol start="5"><li>其他知名符号</li></ol><p>……</p><h1 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a>异步处理</h1><h2 id="事件循环-回顾"><a href="#事件循环-回顾" class="headerlink" title="事件循环[回顾]"></a>事件循环[回顾]</h2><h3 id="宿主环境"><a href="#宿主环境" class="headerlink" title="宿主环境"></a>宿主环境</h3><p><img src="http://47.97.6.61/%E6%9C%89%E9%81%93%E4%BA%91%E5%9B%BE%E7%89%87/%E5%AE%BF%E4%B8%BB%E7%8E%AF%E5%A2%83.png" alt="宿主环境"></p><ul><li>JS 运行的环境称之为宿主环境。</li></ul><h3 id="执行栈"><a href="#执行栈" class="headerlink" title="执行栈"></a>执行栈</h3><p><img src="http://47.97.6.61/%E6%9C%89%E9%81%93%E4%BA%91%E5%9B%BE%E7%89%87/%E6%89%A7%E8%A1%8C%E6%A0%88.png" alt="执行栈"></p><ul><li>执行栈：call stack，一个数据结构，用于存放各种函数的执行环境，每一个函数执行之前，它的相关信息会加入到执行栈。函数调用之前，创建执行环境，然后加入到执行栈；函数调用之后，销毁执行环境。</li><li>JS 引擎永远执行的是执行栈的最顶部。</li></ul><h3 id="异步函数"><a href="#异步函数" class="headerlink" title="异步函数"></a>异步函数</h3><p>异步函数：某些函数不会立即执行，需要等到某个时机到达后才会执行，这样的函数称之为异步函数。比如事件处理函数。异步函数的执行时机，会被宿主环境控制。</p><ul><li><strong>浏览器宿主环境中包含 5 个线程：</strong></li></ul><ol><li>JS 引擎：负责执行执行栈的最顶部代码</li><li>GUI 线程：负责渲染页面</li><li>事件监听线程：负责监听各种事件</li><li>计时线程：负责计时</li><li>网络线程：负责网络通信<br><img src="http://47.97.6.61/%E6%9C%89%E9%81%93%E4%BA%91%E5%9B%BE%E7%89%87/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF.png" alt="事件循环"></li></ol><p>当上面的线程发生了某些事请，如果该线程发现，这件事情有处理程序，它会将该处理程序加入一个叫做事件队列的内存。当 JS 引擎发现，执行栈中已经没有了任何内容后，会将事件队列中的第一个函数加入到执行栈中执行。</p><p><strong>JS 引擎对事件队列的取出执行方式，以及与宿主环境的配合，称之为事件循环。</strong></p><ul><li>解析上面这段话，<strong>以按钮点击事件为例</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;button id &#x3D; &#39;btn&#39;&gt;点击&lt;&#x2F;button&gt;</span><br><span class="line"></span><br><span class="line">document.getElementById(&#39;btn&#39;).onclick &#x3D; function A()&#123;</span><br><span class="line">    console.log(&#39;按钮被点击了&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>执行栈：建立全局上下文</li><li>执行栈：建立 getElementById 函数的上下文</li><li>执行栈：getElementById 函数运行，此上下文出栈</li><li>函数 A 放入事件监听线程里面</li><li>执行栈：js 继续执行，全局上下文出栈<ul><li>若执行栈为空，看事件队列里是否有任务，若有，将第一个任务放入执行栈执行</li></ul></li><li>点击按钮</li><li>事件监听线程将函数 A 放入事件队列</li><li>执行栈：将事件队列里的函数 A 放入执行栈</li><li>执行栈：执行函数 A，创建函数 A 的上下文</li><li>执行栈：创建 console.log 的上下文</li><li>执行栈：运行 console.log，此上下文出栈</li><li>执行栈：函数 A 上下文出栈</li></ol><ul><li><strong>以 setTimeout 事件为例解析</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setTimeout &#x3D; (function()&#123;</span><br><span class="line">    console.log(&#39;hello world&#39;)</span><br><span class="line">&#125;,1000)</span><br></pre></td></tr></table></figure><ol><li>执行栈：建立全局上下文</li><li>执行栈：建立 setTimeout 函数的上下文</li><li>把 setTimeout 函数放入计时线程</li><li>计时线程：1s 后将异步函数放入事件队列等待执行</li><li>执行栈：当执行栈内容清空后，在去看事件队列</li><li>执行栈：将事件队列里面的异步函数入栈执行</li><li>执行栈：执行完成后异步函数的上下文出栈</li></ol><h3 id="宏队列和微队列"><a href="#宏队列和微队列" class="headerlink" title="宏队列和微队列"></a>宏队列和微队列</h3><p>事件队列在不同的宿主环境中有所差异，大部分宿主环境会将事件队列进行细分。在浏览器中，事件队列分为两种：宏队列和微队列<br><img src="http://47.97.6.61/%E6%9C%89%E9%81%93%E4%BA%91%E5%9B%BE%E7%89%87/%E5%AE%8F%E9%98%9F%E5%88%97%EF%BC%8C%E5%BE%AE%E9%98%9F%E5%88%97.png" alt="宏队列，微队列"></p><ul><li>宏任务（队列）：macroTask，计时器结束的回调、事件回调、http 回调等等绝大部分异步函数进入宏队列。ps：之前学过的都是宏队列</li><li>微任务（队列）：MutationObserver，Promise 产生的回调进入微队列。ps：相当于 vip，优先查找</li><li><strong>==当执行栈清空时，JS 引擎首先会将微任务中的所有任务依次执行结束，如果没有微任务，则执行宏任务。务==</strong></li></ul><blockquote><p>MutationObserver 用于监听某个 DOM 对象的变化</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul id&#x3D;&quot;container&quot;&gt;&lt;&#x2F;ul&gt;</span><br><span class="line">&lt;button id&#x3D;&quot;btn&quot;&gt;点击&lt;&#x2F;button&gt;</span><br><span class="line"></span><br><span class="line">let count &#x3D; 1;</span><br><span class="line">const ul &#x3D; document.getElementById(&quot;container&quot;);</span><br><span class="line">document.getElementById(&quot;btn&quot;).onclick &#x3D; function A() &#123;</span><br><span class="line">    setTimeout(function C() &#123;</span><br><span class="line">        console.log(&quot;添加了一个li&quot;)</span><br><span class="line">    &#125;, 0);</span><br><span class="line">    var li &#x3D; document.createElement(&quot;li&quot;)</span><br><span class="line">    li.innerText &#x3D; count++;</span><br><span class="line">    ul.appendChild(li);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;监听ul</span><br><span class="line">const observer &#x3D; new MutationObserver(function B() &#123;</span><br><span class="line">    &#x2F;&#x2F;当监听的dom元素发生变化时运行的回调函数</span><br><span class="line">    console.log(&quot;ul元素发生了变化&quot;)</span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F;监听ul</span><br><span class="line">observer.observe(ul, &#123;</span><br><span class="line">    attributes: true, &#x2F;&#x2F;监听属性的变化</span><br><span class="line">    childList: true, &#x2F;&#x2F;监听子元素的变化</span><br><span class="line">    subtree: true &#x2F;&#x2F;监听子树的变化</span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F;取消监听</span><br><span class="line">observer.disconnect();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;点击按钮时先执行console.log(&quot;ul元素发生了变化&quot;)</span><br><span class="line">&#x2F;&#x2F;在执行console.log(&quot;添加了一个li&quot;)</span><br></pre></td></tr></table></figure><ul><li>解析：</li></ul><ol><li>浏览器线程中已有函数 A(点击事件)和函数 B(监听事件)</li><li>点击按钮，函数 A 执行，放入宏队列</li><li>执行栈将宏队列的函数 A 入栈执行</li><li>将函数 C(setTimeout)放入计时线程，0 秒后放入宏队列</li><li>li 添加到 ul 触发函数 B，函数 B 放入微队列</li><li>函数 A 出栈</li><li>执行微队列中的函数 B 并出栈</li><li>执行宏队列中的函数 C 并出栈</li></ol><h2 id="事件和回调函数的缺陷"><a href="#事件和回调函数的缺陷" class="headerlink" title="事件和回调函数的缺陷"></a>事件和回调函数的缺陷</h2><p>我们习惯于使用传统的回调或事件处理来解决异步问题</p><p>本质上，事件和回调并没有本质的区别，只是把函数放置的位置不同而已。</p><p>存在的问题：</p><ol><li>回调地狱：某个异步操作需要等待之前的异步操作完成，无论用回调还是事件，都会陷入不断的嵌套</li><li>异步之间的联系：某个异步操作要等待多个异步操作的结果，对这种联系的处理，会让代码的复杂度剧增</li></ol><h2 id="异步处理的通用模型"><a href="#异步处理的通用模型" class="headerlink" title="异步处理的通用模型"></a>异步处理的通用模型</h2><p>ES 官方参考了大量的异步场景，总结出了一套异步的通用模型，该模型可以覆盖几乎所有的异步场景，甚至是同步场景。</p><p>值得注意的是，为了兼容旧系统，ES6 并不打算抛弃掉过去的做法，只是基于该模型推出一个全新的 API，使用该 API，会让异步处理更加的简洁优雅。</p><p>理解该 API，最重要的，是理解它的异步模型</p><h3 id="1-ES6-将某一件可能发生异步操作的事情，分为两个阶段：unsettled-和-settled"><a href="#1-ES6-将某一件可能发生异步操作的事情，分为两个阶段：unsettled-和-settled" class="headerlink" title="1. ES6 将某一件可能发生异步操作的事情，分为两个阶段：unsettled 和 settled"></a>1. ES6 将某一件可能发生异步操作的事情，分为两个阶段：unsettled 和 settled</h3><ul><li>unsettled： 未决阶段，表示事情还在进行前期的处理，并没有发生通向结果的那件事</li><li>settled：已决阶段，事情已经有了一个结果，不管这个结果是好是坏，整件事情无法逆转</li></ul><p>事情总是从<strong>未决阶段</strong>逐步发展到<strong>已决阶段</strong>的。并且，未决阶段拥有<strong>控制</strong>何时通向已决阶段的能力。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">未决：监听窗口中的某个元素是否被点击</span><br><span class="line">已决：按钮已经被点击了</span><br></pre></td></tr></table></figure><p><img src="http://47.97.6.61/%E6%9C%89%E9%81%93%E4%BA%91%E5%9B%BE%E7%89%87/unsettled%20%E5%92%8C%20settled.png" alt="unsettled 和 settled"></p><h3 id="2-ES6-将事情划分为三种状态：-pending、resolved、rejected"><a href="#2-ES6-将事情划分为三种状态：-pending、resolved、rejected" class="headerlink" title="2. ES6 将事情划分为三种状态： pending、resolved、rejected"></a>2. ES6 将事情划分为三种状态： pending、resolved、rejected</h3><ul><li><strong>pending</strong>： ==挂起，处于未决阶段==，则表示这件事情还在挂起（最终的结果还没出来）</li><li><strong>resolved</strong>：==已处理，已决阶段的一种状态==，表示整件事情<strong>已经出现结果</strong>，并是一个可以按照正常逻辑进行下去的结果</li><li><strong>rejected</strong>：==已拒绝，已决阶段的一种状态==，表示整件事情已经出现结果，并是一个无法按照正常逻辑进行下去的结果，通常用于表示有一个错误</li></ul><p>既然未决阶段有权力决定事情的走向，因此，<strong>未决阶段可以决定事情最终的状态！</strong></p><p>我们将 把事情变为 resolved 状态的过程叫做：<strong>resolve</strong>，推向该状态时，可能会传递一些数据</p><p>我们将 把事情变为 rejected 状态的过程叫做：<strong>reject</strong>，推向该状态时，同样可能会传递一些数据，通常为错误信息</p><p><strong>==始终记住，无论是阶段，还是状态，是不可逆的！==</strong></p><p><img src="http://47.97.6.61/%E6%9C%89%E9%81%93%E4%BA%91%E5%9B%BE%E7%89%87/%E6%9C%AA%E5%86%B3%E6%8E%A8%E5%90%91%E5%B7%B2%E5%86%B3.png" alt="未决推向已决"></p><h3 id="3-当事情达到已决阶段后，通常需要进行后续处理，不同的已决状态，决定了不同的后续处理。"><a href="#3-当事情达到已决阶段后，通常需要进行后续处理，不同的已决状态，决定了不同的后续处理。" class="headerlink" title="3. 当事情达到已决阶段后，通常需要进行后续处理，不同的已决状态，决定了不同的后续处理。"></a>3. 当事情达到已决阶段后，通常需要进行后续处理，不同的已决状态，决定了不同的后续处理。</h3><ul><li>resolved 状态：这是一个正常的已决状态，后续处理表示为 thenable</li><li>rejected 状态：这是一个非正常的已决状态，后续处理表示为 catchable</li></ul><p>后续处理可能有多个，因此会形成作业队列，这些后续处理会按照顺序，当状态到达后依次执行</p><p><img src="http://47.97.6.61/%E6%9C%89%E9%81%93%E4%BA%91%E5%9B%BE%E7%89%87/%E5%B7%B2%E5%86%B3%E9%98%B6%E6%AE%B5%E5%90%8E%E7%BB%AD%E5%A4%84%E7%90%86.png" alt="已决阶段后续处理"></p><h3 id="整件事称之为-Promise"><a href="#整件事称之为-Promise" class="headerlink" title="整件事称之为 Promise"></a>整件事称之为 Promise</h3><p><img src="http://47.97.6.61/%E6%9C%89%E9%81%93%E4%BA%91%E5%9B%BE%E7%89%87/Promise.png" alt="Promise"></p><p><strong>理解上面的概念，对学习 Promise 至关重要！</strong></p><h2 id="Promise-的基本使用"><a href="#Promise-的基本使用" class="headerlink" title="Promise 的基本使用"></a>Promise 的基本使用</h2><p><img src="http://47.97.6.61/%E6%9C%89%E9%81%93%E4%BA%91%E5%9B%BE%E7%89%87/Promise.png" alt="Promise"></p><ul><li>格式及解析：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pro = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 未决阶段的处理</span></span><br><span class="line">  <span class="comment">// 通过调用resolve函数将Promise推向已决阶段的resolved状态</span></span><br><span class="line">  <span class="comment">// 通过调用reject函数将Promise推向已决阶段的rejected状态</span></span><br><span class="line">  <span class="comment">// resolve和reject均可以传递最多一个参数，表示推向状态的数据</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">pro.then(</span><br><span class="line">  (data) =&gt; &#123;</span><br><span class="line">    <span class="comment">//这是thenable函数，如果当前的Promise已经是resolved状态，该函数会立即执行</span></span><br><span class="line">    <span class="comment">//如果当前是未决阶段，则会加入到作业队列，等待到达resolved状态后执行</span></span><br><span class="line">    <span class="comment">//data为状态数据</span></span><br><span class="line">  &#125;,</span><br><span class="line">  (err) =&gt; &#123;</span><br><span class="line">    <span class="comment">//这是catchable函数，如果当前的Promise已经是rejected状态，该函数会立即执行</span></span><br><span class="line">    <span class="comment">//如果当前是未决阶段，则会加入到作业队列，等待到达rejected状态后执行</span></span><br><span class="line">    <span class="comment">//err为状态数据</span></span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>各种用法：</li></ul><p>基本使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pro = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;未决阶段&quot;</span>);</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&quot;推入resolved&quot;</span>);</span><br><span class="line">  &#125;, <span class="number">3000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">pro.then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data); <span class="comment">//3s后打印&quot;推入resolved&quot;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>配合函数来实现回调：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">biaodai</span>(<span class="params">god</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;这里是立即执行的&quot;</span>);</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">Math</span>.random() &lt; <span class="number">0.5</span>) &#123;</span><br><span class="line">        resolve(<span class="string">&quot;表白成功了&quot;</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resolve(<span class="string">&quot;表白失败了&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">3000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">biaodai(<span class="string">&quot;女孩&quot;</span>).then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//当前pro的状态是pending，不执行，等状态变为resolve时执行</span></span><br><span class="line">  <span class="built_in">console</span>.log(data); <span class="comment">// 3s后打印返回结果</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>可以注册多个 thenable：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pro = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">&quot;就算立即执行也是异步执行，加入微队列&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;这里是先打印的&quot;</span>);</span><br><span class="line">pro.then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br><span class="line">pro.then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>获取两种状态（resolved 和 rejectd）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pro = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;未决阶段&quot;</span>);</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Math</span>.random &lt; <span class="number">0.5</span>) &#123;</span><br><span class="line">      resolve(<span class="number">123</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;这是一个错误信息……&quot;</span>)); <span class="comment">//通常错误状态会返回一个错误信息</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="number">3000</span>);</span><br><span class="line">&#125;);</span><br><span class="line">pro.then(</span><br><span class="line">  (data) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data); <span class="comment">// resolved状态执行</span></span><br><span class="line">  &#125;,</span><br><span class="line">  (err) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err); <span class="comment">// rejected状态执行</span></span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>实现 ajax 的回调：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 辅助函数,把传进来的对象拼接成url的字符串</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toData</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (obj === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> arr = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">let</span> str = i + <span class="string">&quot;=&quot;</span> + obj[i];</span><br><span class="line">    arr.push(str);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr.join(<span class="string">&quot;&amp;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 封装Ajax</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//指定提交方式的默认值</span></span><br><span class="line">    obj.type = obj.type || <span class="string">&quot;get&quot;</span>;</span><br><span class="line">    <span class="comment">//设置是否异步，默认为true(异步)</span></span><br><span class="line">    obj.async = obj.async || <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//设置数据的默认值</span></span><br><span class="line">    obj.data = obj.data || <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 根据不同的浏览器创建XHR对象</span></span><br><span class="line">    <span class="keyword">let</span> xhr = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.XMLHttpRequest) &#123;</span><br><span class="line">      <span class="comment">// 非IE浏览器</span></span><br><span class="line">      xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// IE浏览器</span></span><br><span class="line">      xhr = <span class="keyword">new</span> ActiveXObject(<span class="string">&quot;Microsoft.XMLHTTP&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 区分get和post,发送HTTP请求</span></span><br><span class="line">    <span class="keyword">if</span> (obj.type === <span class="string">&quot;post&quot;</span>) &#123;</span><br><span class="line">      xhr.open(obj.type, obj.url, obj.async);</span><br><span class="line">      xhr.setRequestHeader(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>);</span><br><span class="line">      <span class="keyword">let</span> data = toData(obj.data);</span><br><span class="line">      xhr.send(data);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> url = obj.url + <span class="string">&quot;?&quot;</span> + toData(obj.data);</span><br><span class="line">      xhr.open(obj.type, url, obj.async);</span><br><span class="line">      xhr.send();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 接收返回过来的数据</span></span><br><span class="line">    xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>) || xhr.status == <span class="number">304</span>) &#123;</span><br><span class="line">          resolve(<span class="built_in">JSON</span>.parse(xhr.responseText));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          reject(xhr.status);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ajax(&#123;</span><br><span class="line">  url: <span class="string">&quot;./data/students.json?name=李华&quot;</span>,</span><br><span class="line">&#125;).then(</span><br><span class="line">  (resp) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(resp);</span><br><span class="line">  &#125;,</span><br><span class="line">  (err) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>细节</strong></p><ol><li>未决阶段的处理函数本身是同步的，会立即执行</li><li>thenable 和 catchable 函数是异步的，就算是立即执行，也会加入到事件队列中等待执行，并且，加入的队列是微队列<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const pro &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&quot;此处第一个打印&quot;);</span><br><span class="line">    resolve(&#39;此处第三个打印&#39;);</span><br><span class="line">&#125;)</span><br><span class="line">console.log(&quot;此处第二个打印&quot;);</span><br><span class="line">pro.then(data &#x3D;&gt; &#123;</span><br><span class="line">    console.log(data);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li>pro.then 可以只添加 thenable 函数，pro.catch 可以单独添加 catchable 函数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const pro &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    resolve(&quot;这里只展示效果&quot;);</span><br><span class="line">&#125;)</span><br><span class="line">pro.then(data &#x3D;&gt; &#123;</span><br><span class="line">    console.log(data)</span><br><span class="line">&#125;)</span><br><span class="line">pro.catch(err &#x3D;&gt; &#123;</span><br><span class="line">    console.log(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li>在未决阶段的处理函数中，如果发生未捕获的错误，会将状态推向 rejected，并会被 catchable 捕获<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const pro &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    throw new Error(&quot;123&quot;); &#x2F;&#x2F; pro 状态推向 rejected</span><br><span class="line">&#125;)</span><br><span class="line">pro.then(data &#x3D;&gt; &#123;</span><br><span class="line">    console.log(data)</span><br><span class="line">&#125;)</span><br><span class="line">pro.catch(err &#x3D;&gt; &#123;</span><br><span class="line">    console.log(err) &#x2F;&#x2F;     先打印错误，然后报错（因为thenable和catchable函数在微队    列中）</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li>一旦状态推向了已决阶段，无法再对状态做任何更改<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const pro &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    throw new Error(&quot;abc&quot;); &#x2F;&#x2F; pro推向已决阶段rejectd状态</span><br><span class="line">    resolve(1); &#x2F;&#x2F;无效</span><br><span class="line">    reject(2); &#x2F;&#x2F;无效</span><br><span class="line">    resolve(3); &#x2F;&#x2F;无效</span><br><span class="line">    reject(4); &#x2F;&#x2F;无效</span><br><span class="line">&#125;)</span><br><span class="line">pro.then(data &#x3D;&gt; &#123;</span><br><span class="line">    console.log(data)</span><br><span class="line">&#125;)</span><br><span class="line">pro.catch(err &#x3D;&gt; &#123;</span><br><span class="line">    console.log(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><strong>Promise 并没有消除回调，只是让回调变得可控</strong></li></ol><h2 id="Promise-的串联"><a href="#Promise-的串联" class="headerlink" title="Promise 的串联"></a>Promise 的串联</h2><p>当后续的 Promise 需要用到之前的 Promise 的处理结果时，需要 Promise 的串联</p><p>==Promise 对象中，无论是 then 方法还是 catch 方法，它们都具有返回值，返回的是一个全新的 Promise 对象==</p><p>它的状态满足下面的规则：</p><ol><li>==如果当前的 Promise 是未决的，<strong>得到的新的 Promise 是挂起状态</strong>==</li><li>==如果当前的 Promise 是已决的，会运行响应的后续处理函数，并将后续处理函数的结果（返回值）作为 resolved 状态数据，应用到新的 Promise 中；如果后续处理函数发生错误，则把返回值作为 rejected 状态数据，应用到新的 Promise 中。==</li></ol><p>==<strong>后续的 Promise 一定会等到前面的 Promise 有了后续处理结果后，才会变成已决状态</strong>==</p><p>如果前面的 Promise 的后续处理，返回的是一个 Promise，则返 回的==新的 Promise 状态和后续处理返回的 Promise 状态保持一致。==</p><p>基本使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1.pro.then(……) 返回一个新的Promise</span></span><br><span class="line"><span class="comment"> * 2.如果函数体内没有错误，新Promise由pending(挂起)状态推向resolve(已处理)状态</span></span><br><span class="line"><span class="comment"> * 3.如果函数体内出现错误，新Promise由pending(挂起)状态推向reject(已拒绝)状态</span></span><br><span class="line"><span class="comment"> * 4.return data; 为传入的参数</span></span><br><span class="line"><span class="comment"> * 5.当pro处于未决状态时，pro2也保持未决状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> pro = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">&quot;成功了&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> pro2 = pro.then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">  <span class="keyword">return</span> data;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(pro2); <span class="comment">//此处打印pending</span></span><br><span class="line">pro2.then(</span><br><span class="line">  (data) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data, <span class="number">2</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  (err) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>加深理解：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pro1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="number">1</span>; <span class="comment">//这里报错，推向rejected状态</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此处运行：return 3，推向resolved状态，当pro1.then里面的代码出错时才会推向rejected状态</span></span><br><span class="line"><span class="keyword">const</span> pro2 = pro1.then(</span><br><span class="line">  (result) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> result * <span class="number">2</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  (err) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> err * <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">//此处和上面err一起运行，但是这个并没有返回给pro2，所以不影响下面输出</span></span><br><span class="line">pro1.catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> err * <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//pro2的状态：</span></span><br><span class="line">pro2.then(</span><br><span class="line">  (result) =&gt; <span class="built_in">console</span>.log(result * <span class="number">2</span>),</span><br><span class="line">  (err) =&gt; <span class="built_in">console</span>.log(err * <span class="number">3</span>)</span><br><span class="line">);</span><br><span class="line"><span class="comment">//输出：6</span></span><br></pre></td></tr></table></figure><p>返回 Promise</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pro1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pro2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">2</span>);</span><br><span class="line">  &#125;, <span class="number">3000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">pro1</span><br><span class="line">  .then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;结果出来了，得到的是一个Promise&quot;</span>); <span class="comment">//运行后会立刻打印</span></span><br><span class="line">    <span class="keyword">return</span> pro2;</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result); <span class="comment">//等待pro2执行完，3s后打印 2</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result); <span class="comment">//上一个没有传入数据，打印undefined</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>解决回调地狱</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ajax函数在上面</span></span><br><span class="line"><span class="comment">//获取李华所在班级的老师的信息</span></span><br><span class="line"><span class="comment">//1. 获取李华的班级id   Promise</span></span><br><span class="line"><span class="comment">//2. 根据班级id获取李华所在班级的老师id   Promise</span></span><br><span class="line"><span class="comment">//3. 根据老师的id查询老师信息   Promise</span></span><br><span class="line"><span class="keyword">const</span> pro = ajax(&#123;</span><br><span class="line">  url: <span class="string">&quot;./data/students.json&quot;</span>,</span><br><span class="line">&#125;);</span><br><span class="line">pro</span><br><span class="line">  .then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (data[i].name === <span class="string">&quot;李华&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> data[i].classId;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">cid</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ajax(&#123;</span><br><span class="line">      url: <span class="string">&quot;./data/classes.json?id=&quot;</span> + cid,</span><br><span class="line">    &#125;).then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (data[i].id == cid) &#123;</span><br><span class="line">          <span class="keyword">return</span> data[i].teacherId;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">tid</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ajax(&#123;</span><br><span class="line">      url: <span class="string">&quot;./data/teachers.json?id=&quot;</span> + tid,</span><br><span class="line">    &#125;).then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(data);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (data[i].id === tid) &#123;</span><br><span class="line">          <span class="keyword">return</span> data[i];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">teacher</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(teacher);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>邓哥女神表白</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    邓哥心中有三个女神</span></span><br><span class="line"><span class="comment">    有一天，邓哥决定向第一个女神表白，如果女神拒绝，则向第二个女神表白，直到所有的女神都拒绝，或有一个女神同意为止</span></span><br><span class="line"><span class="comment">    用代码模拟上面的场景</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">biaobai</span>(<span class="params">god</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;邓哥向&quot;</span> + god + <span class="string">&quot;发出了表白&quot;</span>);</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">Math</span>.random() &lt; <span class="number">0.3</span>) &#123;</span><br><span class="line">        resolve(<span class="literal">true</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resolve(<span class="literal">false</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> gods = [<span class="string">&quot;女神1&quot;</span>, <span class="string">&quot;女神2&quot;</span>, <span class="string">&quot;女神3&quot;</span>, <span class="string">&quot;女神4&quot;</span>, <span class="string">&quot;女神5&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> pro;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; gods.length; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">    pro = biaobai(gods[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  pro = pro.then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (result === <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (result) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;result&#125;</span>同意了`</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;result&#125;</span>拒绝了`</span>);</span><br><span class="line">      <span class="keyword">if</span> (i &lt; gods.length - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> biaobai(gods[i + <span class="number">1</span>]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Promise-的其他-API"><a href="#Promise-的其他-API" class="headerlink" title="Promise 的其他 API"></a>Promise 的其他 API</h2><h3 id="原型成员-实例成员"><a href="#原型成员-实例成员" class="headerlink" title="原型成员 (实例成员)"></a>原型成员 (实例成员)</h3><ul><li>then：注册一个后续处理函数，当 Promise 为 resolved 状态时运行该函数</li><li>catch：注册一个后续处理函数，当 Promise 为 rejected 状态时运行该函数</li><li>finally：[ES2018]注册一个后续处理函数（无参），当 Promise 为已决时运行该函数</li></ul><h3 id="构造函数成员-（静态成员）"><a href="#构造函数成员-（静态成员）" class="headerlink" title="构造函数成员 （静态成员）"></a>构造函数成员 （静态成员）</h3><ul><li>resolve(数据)：该方法返回一个 resolved 状态的 Promise，传递的数据作为状态数据<ul><li>特殊情况：如果传递的数据是 Promise，则直接返回传递的 Promise 对象</li></ul></li><li>reject(数据)：该方法返回一个 rejected 状态的 Promise，传递的数据作为状态数据</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pro = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//等效于：</span></span><br><span class="line"><span class="keyword">const</span> pro = <span class="built_in">Promise</span>.resolve(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="number">3</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// const pro = Promise.resolve(p);</span></span><br><span class="line"><span class="comment">//等效于</span></span><br><span class="line"><span class="keyword">const</span> pro = p;</span><br><span class="line"><span class="built_in">console</span>.log(pro === p);</span><br></pre></td></tr></table></figure><ul><li>all(iterable)：这个方法返回一个新的 promise 对象，该 promise 对象在 iterable 参数对象里所有的 promise 对象都成功的时候才会触发成功，一旦有任何一个 iterable 里面的 promise 对象失败则立即触发该 promise 对象的失败。<ul><li>这个新的 promise 对象在触发成功状态以后，会把一个包含 iterable 里所有 promise 返回值的数组作为成功回调的返回值，顺序跟 iterable 的顺序保持一致；如果这个新的 promise 对象触发了失败状态，它会把 iterable 里第一个触发失败的 promise 对象的错误信息作为它的失败错误信息。</li><li><strong>Promise.all 方法常被用于处理多个 promise 对象的状态集合。</strong></li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRandom</span>(<span class="params">min, max</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (max - min)) + min;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> proms = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  proms.push(</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Math</span>.random() &lt; <span class="number">0.5</span>) &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(i, <span class="string">&quot;完成&quot;</span>);</span><br><span class="line">          resolve(i);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(i, <span class="string">&quot;失败&quot;</span>);</span><br><span class="line">          reject(i);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, getRandom(<span class="number">1000</span>, <span class="number">5000</span>));</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//等到所有的promise变成resolved状态后输出: 全部完成</span></span><br><span class="line"><span class="keyword">const</span> pro = <span class="built_in">Promise</span>.all(proms);</span><br><span class="line">pro.then(<span class="function">(<span class="params">datas</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;全部完成&quot;</span>, datas);</span><br><span class="line">&#125;);</span><br><span class="line">pro.catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;有失败的&quot;</span>, err);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(proms);</span><br></pre></td></tr></table></figure><ul><li>race(iterable)：当 iterable 参数里的任意一个子 promise 被成功或失败后，父 promise 马上也会用子 promise 的成功返回值或失败详情作为参数调用父 promise 绑定的相应句柄，并返回该 promise 对象</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">function getRandom(min, max) &#123;</span><br><span class="line">    return Math.floor(Math.random() * (max - min)) + min;</span><br><span class="line">&#125;</span><br><span class="line">const proms &#x3D; [];</span><br><span class="line">for (let i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">    proms.push(new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">        setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">            if (Math.random() &lt; 0.5) &#123;</span><br><span class="line">                console.log(i, &quot;完成&quot;);</span><br><span class="line">                resolve(i);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                console.log(i, &quot;失败&quot;)</span><br><span class="line">                reject(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, getRandom(1000, 5000));</span><br><span class="line">    &#125;))</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;等到所有的promise变成resolved状态后输出: 全部完成</span><br><span class="line">const pro &#x3D; Promise.race(proms)</span><br><span class="line">pro.then(data &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&quot;有人完成了&quot;, data);</span><br><span class="line">&#125;)</span><br><span class="line">pro.catch(err &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&quot;有人失败了&quot;, err);</span><br><span class="line">&#125;)</span><br><span class="line">console.log(proms);</span><br></pre></td></tr></table></figure><h2 id="手写-Promise-扩展"><a href="#手写-Promise-扩展" class="headerlink" title="手写 Promise[扩展]"></a>手写 Promise[扩展]</h2><p>有时间去看视频</p><h2 id="async-和-await"><a href="#async-和-await" class="headerlink" title="async 和 await"></a>async 和 await</h2><p>async 和 await 是 ES2016 新增两个关键字，它们借鉴了 ES2015 中生成器在实际开发中的应用，目的是简化 Promise api 的使用，并非是替代 Promise。</p><h3 id="async-关键字"><a href="#async-关键字" class="headerlink" title="async 关键字"></a>async 关键字</h3><p>==目的是简化在函数的返回值中对 Promise 的创建==</p><p>async 用于修饰函数（无论是函数字面量还是函数表达式），放置在函数最开始的位置，被修饰函数的返回结果一定是 Promise 对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">throw</span> <span class="number">3</span>; <span class="comment">//推向reject(3);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//等效于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    resolve(<span class="number">2</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="await-关键字"><a href="#await-关键字" class="headerlink" title="await 关键字"></a>await 关键字</h3><ul><li><p>==await 关键字必须出现在 async 函数中==</p></li><li><p>await 用在某个表达式之前，如果表达式是一个 Promise，则==得到的是 thenable 中的状态数据。==</p></li><li><p>如果 await 的表达式不是 Promise，则会将其使用 Promise.resolve 包装后按照规则运行</p></li></ul><p>基本使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//这里就相当于把return回来的数据直接赋值给result</span></span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">await</span> test1();</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test2();</span><br><span class="line"><span class="comment">//等效于:</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    resolve(<span class="number">2</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    test1().then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> result = data;</span><br><span class="line">      <span class="built_in">console</span>.log(result);</span><br><span class="line">      resolve();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test2();</span><br></pre></td></tr></table></figure><p>await 的表达式不是 Promise：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//await不返回Promise</span></span><br><span class="line"><span class="comment">//如果await的表达式不是Promise，则会将其使用Promise.resolve包装后按照规则运行</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">await</span> <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//等效于：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">Promise</span>.resolve(<span class="number">1</span>).then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> result = data;</span><br><span class="line">      <span class="built_in">console</span>.log(result);</span><br><span class="line">      resolve();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">test();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">123</span>);</span><br></pre></td></tr></table></figure><p>捕获 catchable 状态数据：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getPromise</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Math</span>.random() &lt; <span class="number">0.5</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> getPromise();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;正常状态&quot;</span>, result);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;错误状态&quot;</span>, err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test();</span><br></pre></td></tr></table></figure><h3 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h3><p>ajax 请求</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取李华所在班级的老师的信息</span></span><br><span class="line"><span class="comment">//1. 获取李华的班级id   Promise</span></span><br><span class="line"><span class="comment">//2. 根据班级id获取李华所在班级的老师id   Promise</span></span><br><span class="line"><span class="comment">//3. 根据老师的id查询老师信息   Promise</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getTeacher</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> stus = <span class="keyword">await</span> ajax(&#123;</span><br><span class="line">    url: <span class="string">&quot;./data/students.json&quot;</span>,</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">let</span> cid;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; stus.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (stus[i].name === <span class="string">&quot;李华&quot;</span>) &#123;</span><br><span class="line">      cid = stus[i].classId;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> cls = <span class="keyword">await</span> ajax(&#123;</span><br><span class="line">    url: <span class="string">&quot;./data/classes.json&quot;</span>,</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">let</span> tid;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; cls.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (cls[i].id === cid) &#123;</span><br><span class="line">      tid = cls[i].teacherId;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> ts = <span class="keyword">await</span> ajax(&#123;</span><br><span class="line">    url: <span class="string">&quot;./data/teachers.json&quot;</span>,</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; ts.length; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> element = ts[i];</span><br><span class="line">    <span class="keyword">if</span> (element.id === tid) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(element);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">getTeacher();</span><br></pre></td></tr></table></figure><p>邓哥表白女神</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    邓哥心中有三个女神</span></span><br><span class="line"><span class="comment">    有一天，邓哥决定向第一个女神表白，如果女神拒绝，则向第二个女神表白，直到所有的女神都拒绝，或有一个女神同意为止</span></span><br><span class="line"><span class="comment">    用代码模拟上面的场景</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> gods = [<span class="string">&quot;女神1&quot;</span>, <span class="string">&quot;女神2&quot;</span>, <span class="string">&quot;女神3&quot;</span>, <span class="string">&quot;女神4&quot;</span>, <span class="string">&quot;女神5&quot;</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; gods.length; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> g = gods[i];</span><br><span class="line">    <span class="comment">// 当前循环等待的Promise没有resolve，下一次循环不运行</span></span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> biaobai(g);</span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;g&#125;</span>同意了，不用再表白了！！！`</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;g&#125;</span>没有同意`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>如果 async 里面有定时器，会出现 this 指向的问题，可以通过改造计时器的方式实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delay</span>(<span class="params">duration</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      resolve();</span><br><span class="line">    &#125;, duration);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">biaobai</span>(<span class="params">god</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`邓哥向<span class="subst">$&#123;god&#125;</span>发出了表白短信`</span>);</span><br><span class="line">  <span class="keyword">await</span> delay(<span class="number">500</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.random() &lt; <span class="number">0.3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Fetch-Api"><a href="#Fetch-Api" class="headerlink" title="Fetch Api"></a>Fetch Api</h1><h2 id="Fetch-Api-概述"><a href="#Fetch-Api-概述" class="headerlink" title="Fetch Api 概述"></a>Fetch Api 概述</h2><p><strong>XMLHttpRequest 的问题</strong></p><ol><li>所有的功能全部集中在同一个对象上，容易书写出混乱不易维护的代码</li><li>若采用传统的事件驱动模式，无法适配新的 Promise Api</li></ol><p><strong>Fetch Api 的特点</strong></p><ol><li>并非取代 AJAX，而是对 AJAX 传统 API 的改进</li><li>精细的功能分割：头部信息、请求信息、响应信息等均分布到不同的对象，更利于处理各种复杂的 AJAX 场景</li><li>使用 Promise Api，更利于异步代码的书写</li><li>Fetch Api 并非 ES6 的内容，属于 HTML5 新增的 Web Api</li><li>需要掌握网络通信的知识</li></ol><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><blockquote><p>请求测试地址：<a href="http://101.132.72.36:5100/api/local">http://101.132.72.36:5100/api/local</a></p></blockquote><p>使用 <code>fetch</code> 函数即可立即向服务器发送网络请求</p><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>该函数有两个参数：</p><ol><li>必填，字符串，请求地址</li><li>选填，对象，请求配置(下面为可配置参数)</li></ol><p><strong>请求配置对象</strong></p><ul><li><strong>method</strong>：字符串，请求方法，默认值 GET</li><li><strong>headers</strong>：对象，请求头信息。常见<code>&quot;Content-Type:&quot;application/json&quot;</code>,也可以配置自定义的内容</li><li><strong>body</strong>: 请求体的内容，必须匹配请求头中的 Content-Type。==（注：只有 post 请求才会有请求体，get 的请求内容都在 url 中）==</li><li>mode：字符串，请求模式<ul><li>cors：默认值，配置为该值，会在请求头中加入 origin 和 referer</li><li>no-cors：配置为该值，不会在请求头中加入 origin 和 referer，跨域的时候可能会出现问题</li><li>same-origin：指示请求必须在同一个域中发生，如果请求其他域，则会报错</li></ul></li><li>credentials: 如何携带凭据（cookie）<ul><li>omit：默认值，不携带 cookie</li><li>same-origin：请求同源地址时携带 cookie</li><li>include：请求任何地址都携带 cookie</li></ul></li><li>cache：配置缓存模式<ul><li>default: 表示 fetch 请求之前将检查下 http 的缓存.</li><li>no-store: 表示 fetch 请求将完全忽略 http 缓存的存在. 这意味着请求之前将不再检查下 http 的缓存, 拿到响应后, 它也不会更新 http 缓存.</li><li>no-cache: 如果存在缓存, 那么 fetch 将发送一个条件查询 request 和一个正常的 request, 拿到响应后, 它会更新 http 缓存.</li><li>reload: 表示 fetch 请求之前将忽略 http 缓存的存在, 但是请求拿到响应后, 它将主动更新 http 缓存.</li><li>force-cache: 表示 fetch 请求不顾一切的依赖缓存, 即使缓存过期了, 它依然从缓存中读取. 除非没有任何缓存, 那么它将发送一个正常的 request.</li><li>only-if-cached: 表示 fetch 请求不顾一切的依赖缓存, 即使缓存过期了, 它依然从缓存中读取. 如果没有缓存, 它将抛出网络错误(该设置只在 mode 为”same-origin”时有效).</li></ul></li></ul><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>fetch 函数返回一个 Promise 对象</p><ul><li>当收到服务器的返回结果后(注：404 等也是返回的结果)，Promise 进入 resolved 状态，状态数据为 Response 对象</li><li>当网络发生错误（或其他导致无法完成交互的错误）时，Promise 进入 rejected 状态，状态数据为错误信息</li></ul><p><strong>Response 对象</strong></p><ul><li>ok：boolean，当响应消息码在 200~299 之间时为 true，其他为 false</li><li>status：number，响应的状态码</li><li>**json()**：用于处理 JSON 格式的 Ajax 的响应。它将 JSON 数据流转换为一个被解决为 JavaScript 对象的 promise。</li><li>**text()**：用于处理文本格式的 Ajax 响应。它从响应中获取文本流，将其读完，然后返回一个被解决为 string 对象的 Promise。</li><li>blob()：用于处理二进制文件格式（比如图片或者电子表格）的 Ajax 响应。它读取文件的原始数据，一旦读取完整个文件，就返回一个被解决为 blob 对象的 Promise。</li><li>redirect()：可以用于重定向到另一个 URL。它会创建一个新的 Promise，以解决来自重定向的 URL 的响应。</li></ul><p><strong>完整使用</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getProvinces</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> url = <span class="string">&quot;http://101.132.72.36:5100/api/local&quot;</span>;</span><br><span class="line">  <span class="keyword">const</span> config = &#123;</span><br><span class="line">    method: <span class="string">&quot;GET&quot;</span>,</span><br><span class="line">    headers: &#123;</span><br><span class="line">      a: <span class="number">1</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> resp = <span class="keyword">await</span> fetch(url, config); <span class="comment">//返回response对象，先等服务器的响应结果</span></span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> resp.json(); <span class="comment">//解析响应结果，等解析完成后再进行后续操作，所以用await</span></span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="comment">//如果上面为rejected状态会进入这里面</span></span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果确定不会出错，甚至可以更简单</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getProvinces</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> url = <span class="string">&quot;http://101.132.72.36:5100/api/local&quot;</span>;</span><br><span class="line">  <span class="keyword">const</span> resp = <span class="keyword">await</span> fetch(url);</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">await</span> resp.json();</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//袁总用过的一种写法</span></span><br><span class="line"></span><br><span class="line">fetch(url)</span><br><span class="line">  .then(<span class="function">(<span class="params">resp</span>) =&gt;</span> resp.json())</span><br><span class="line">  .then(<span class="function">(<span class="params">resp</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(resp);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h2 id="Request-对象"><a href="#Request-对象" class="headerlink" title="Request 对象"></a>Request 对象</h2><p>除了使用基本的 fetch 方法，还可以通过创建一个 Request 对象来完成请求（实际上，fetch 的内部会帮你创建一个 Request 对象）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Request(url地址, 配置);</span><br></pre></td></tr></table></figure><p>注意点：</p><p>尽量保证每次请求都是一个新的 Request 对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> req;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRequestInfo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!req) &#123;</span><br><span class="line">    <span class="keyword">const</span> url = <span class="string">&quot;http://101.132.72.36:5100/api/local&quot;</span>;</span><br><span class="line">    req = <span class="keyword">new</span> Request(url, &#123;&#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(req);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> req.clone(); <span class="comment">//克隆一个全新的request对象，配置一致</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getProvinces</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> resp = <span class="keyword">await</span> fetch(getRequestInfo());</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">await</span> resp.json();</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">&quot;button&quot;</span>).onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  getProvinces();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Response-对象"><a href="#Response-对象" class="headerlink" title="Response 对象"></a>Response 对象</h2><p>可以用来模拟数据使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getProvinces</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> resp = <span class="keyword">new</span> Response(</span><br><span class="line">    <span class="string">`[</span></span><br><span class="line"><span class="string">        &#123;&quot;id&quot;:1, &quot;name&quot;:&quot;北京&quot;&#125;,</span></span><br><span class="line"><span class="string">        &#123;&quot;id&quot;:2, &quot;name&quot;:&quot;天津&quot;&#125;</span></span><br><span class="line"><span class="string">    ]`</span>,</span><br><span class="line">    &#123;</span><br><span class="line">      ok: <span class="literal">true</span>,</span><br><span class="line">      status: <span class="number">200</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">await</span> getJSON(resp);</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getJSON</span>(<span class="params">resp</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> json = <span class="keyword">await</span> resp.json();</span><br><span class="line">  <span class="keyword">return</span> json;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Header-对象"><a href="#Header-对象" class="headerlink" title="Header 对象"></a>Header 对象</h2><p>在 Request 和 Response 对象内部，会将传递的请求头对象，转换为 Headers</p><p>Headers 对象中的方法：</p><ul><li>has(key)：检查请求头中是否存在指定的 key 值</li><li>get(key): 得到请求头中对应的 key 值</li><li>set(key, value)：修改对应的键值对</li><li>append(key, value)：添加对应的键值对</li><li>keys(): 得到所有的请求头键的集合</li><li>values(): 得到所有的请求头中的值的集合</li><li>entries(): 得到所有请求头中的键值对的集合</li></ul><p>基本使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> req;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRequestInfo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!req) &#123;</span><br><span class="line">    <span class="keyword">const</span> url = <span class="string">&quot;http://101.132.72.36:5100/api/local&quot;</span>;</span><br><span class="line">    <span class="keyword">const</span> headers = <span class="keyword">new</span> Headers(&#123;</span><br><span class="line">      a: <span class="number">1</span>,</span><br><span class="line">      b: <span class="number">2</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">    req = <span class="keyword">new</span> Request(url, &#123;</span><br><span class="line">      headers,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(req);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> req.clone(); <span class="comment">//克隆一个全新的request对象，配置一致</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>案例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> req;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCommonHeaders</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Headers(&#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: <span class="number">2</span>,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printHeaders</span>(<span class="params">headers</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> datas = headers.entries();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> pair <span class="keyword">of</span> datas) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`key: <span class="subst">$&#123;pair[<span class="number">0</span>]&#125;</span>，value: <span class="subst">$&#123;pair[<span class="number">1</span>]&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRequestInfo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!req) &#123;</span><br><span class="line">    <span class="keyword">const</span> url = <span class="string">&quot;http://101.132.72.36:5100/api/local&quot;</span>;</span><br><span class="line">    <span class="keyword">const</span> headers = getCommonHeaders();</span><br><span class="line">    headers.set(<span class="string">&quot;a&quot;</span>, <span class="number">3</span>);</span><br><span class="line">    req = <span class="keyword">new</span> Request(url, &#123;</span><br><span class="line">      headers,</span><br><span class="line">    &#125;);</span><br><span class="line">    printHeaders(headers);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> req.clone(); <span class="comment">//克隆一个全新的request对象，配置一致</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getProvinces</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> resp = <span class="keyword">await</span> fetch(getRequestInfo());</span><br><span class="line">  printHeaders(resp.headers);</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">await</span> getJSON(resp);</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getJSON</span>(<span class="params">resp</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> json = <span class="keyword">await</span> resp.json();</span><br><span class="line">  <span class="keyword">return</span> json;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">&quot;button&quot;</span>).onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  getProvinces();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><p>流程：</p><ol><li>客户端将文件数据发送给服务器</li><li>服务器保存上传的文件数据到服务器端</li><li>服务器响应给客户端一个文件访问地址</li></ol><blockquote><p>测试地址：<a href="http://101.132.72.36:5100/api/upload">http://101.132.72.36:5100/api/upload</a><br>键的名称（表单域名称）：imagefile</p></blockquote><p>请求方法：POST<br>请求的表单格式：enctype =”multipart/form-data” （input 的 multiple 属性可选择多个文件）<br>请求体中必须包含一个键值对，键的名称是服务器要求的名称，值是文件数据</p><blockquote><p>HTML5 中，JS 仍然无法随意的获取文件数据，但是可以获取到 input 元素中，被用户选中的文件数据<br>可以利用 HTML5 提供的 FormData 构造函数来创建请求体</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">upload</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> inp = <span class="built_in">document</span>.getElementById(<span class="string">&quot;avatar&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (inp.files.length === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//判断是否选择了文件</span></span><br><span class="line">    alert(<span class="string">&quot;请先选择文件&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> formdata = <span class="keyword">new</span> FormData(); <span class="comment">//创建ForData对象</span></span><br><span class="line">  formdata.append(<span class="string">&quot;imagefile&quot;</span>, inp.files[<span class="number">0</span>]); <span class="comment">//把文件添加到对象</span></span><br><span class="line">  <span class="keyword">const</span> url = <span class="string">&quot;http://101.132.72.36:5100/api/upload&quot;</span>;</span><br><span class="line">  <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(url, &#123;</span><br><span class="line">    <span class="comment">//进行ajax请求</span></span><br><span class="line">    method: <span class="string">&quot;POST&quot;</span>,</span><br><span class="line">    body: formdata, <span class="comment">//fordata对象会自动添加header</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">await</span> response.json(); <span class="comment">//将响应数据转为json格式</span></span><br><span class="line">  <span class="keyword">return</span> result; <span class="comment">//返回数据</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">&quot;button&quot;</span>).onclick = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">await</span> upload(); <span class="comment">//异步调用方法</span></span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">  <span class="comment">//将返回数据里面的图片路径赋值给img标签</span></span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&quot;imgAvatar&quot;</span>).src = result.path;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="迭代器和生成器"><a href="#迭代器和生成器" class="headerlink" title="迭代器和生成器"></a>迭代器和生成器</h1><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><h3 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h3><ol><li>什么是迭代？</li></ol><p>从一个数据集合中按照一定的顺序，不断取出数据的过程</p><ol start="2"><li>迭代和遍历的区别？</li></ol><p>迭代强调的是依次取数据，并不保证取多少，也不保证把所有的数据取完</p><p>遍历强调的是要把整个数据依次全部取出</p><ol start="3"><li>迭代器</li></ol><p>对迭代过程的封装，在不同的语言中有不同的表现形式，通常为对象</p><ol start="4"><li>迭代模式</li></ol><p>一种设计模式，用于统一迭代过程，并规范了迭代器规格：</p><ul><li>迭代器应该具有得到下一个数据的能力</li><li>迭代器应该具有判断是否还有后续数据的能力</li></ul><h3 id="JS-中的迭代器"><a href="#JS-中的迭代器" class="headerlink" title="JS 中的迭代器"></a>JS 中的迭代器</h3><p>JS 规定，如果一个对象具有 next 方法，并且该方法返回一个对象，则认为该对象是一个迭代器。该对象的格式如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">value</span>: 值, <span class="attr">done</span>: 是否迭代完成&#125;</span><br></pre></td></tr></table></figure><p>含义：</p><ul><li>next 方法：用于得到下一个数据</li><li>返回的对象<ul><li>value：下一个数据的值</li><li>done：boolean，是否迭代完成</li></ul></li></ul><h4 id="使用迭代器和循环的区别"><a href="#使用迭代器和循环的区别" class="headerlink" title="使用迭代器和循环的区别"></a>使用迭代器和循环的区别</h4><ol><li>用循环的方式也能够完成迭代的过程，但是使用循环需要直接跟数据集打交道</li><li>很多情况下没有什么问题，可以直接使用循环</li><li>数据集如果不是真数组，可能还需要把他转换为真数组，做一些处理。</li><li>使用迭代器就可以避免这种情况</li></ol><ul><li>==可以这么想象：==<ol><li>这个数组是一个仓库</li><li>用循环的模式，是亲自去仓库取数据</li><li>用迭代器的方式，相当于多加了一个人，不是直接跟仓库打交道，而是和管理员打交道</li></ol></li></ul><h4 id="迭代器的使用"><a href="#迭代器的使用" class="headerlink" title="迭代器的使用"></a>迭代器的使用</h4><p>基本写法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="comment">//迭代数组arr</span></span><br><span class="line"><span class="keyword">const</span> iterator = &#123;</span><br><span class="line">  i: <span class="number">0</span>, <span class="comment">//当前的数组下标</span></span><br><span class="line">  next() &#123;</span><br><span class="line">    <span class="keyword">var</span> result = &#123;</span><br><span class="line">      value: arr[<span class="built_in">this</span>.i],</span><br><span class="line">      done: <span class="built_in">this</span>.i &gt;= arr.length,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">this</span>.i++;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//让迭代器不断的取出下一个数据，直到没有数据为止</span></span><br><span class="line"><span class="comment">//最重要的是：使用过程中没有用到数组</span></span><br><span class="line"><span class="keyword">let</span> data = iterator.next();</span><br><span class="line"><span class="keyword">while</span> (!data.done) &#123;</span><br><span class="line">  <span class="comment">//只要没有迭代完成，则取出数据</span></span><br><span class="line">  <span class="built_in">console</span>.log(data.value);</span><br><span class="line">  <span class="comment">//进行下一次迭代</span></span><br><span class="line">  data = iterator.next();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;迭代完成&quot;</span>);</span><br></pre></td></tr></table></figure><p>迭代器创建函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代器创建函数  iterator creator</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createIterator</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>; <span class="comment">//当前的数组下标</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    next() &#123;</span><br><span class="line">      <span class="keyword">var</span> result = &#123;</span><br><span class="line">        value: arr[i],</span><br><span class="line">        done: i &gt;= arr.length,</span><br><span class="line">      &#125;;</span><br><span class="line">      i++;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> iter1 = createIterator(arr1);</span><br><span class="line"><span class="keyword">const</span> iter2 = createIterator(arr2);</span><br></pre></td></tr></table></figure><p>获取斐波拉契数列</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 依次得到斐波拉契数列前面n位的值</span></span><br><span class="line"><span class="comment">// 1 1 2 3 5 8 13 .....</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个斐波拉契数列的迭代器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFeiboIterator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> prev1 = <span class="number">1</span>,</span><br><span class="line">    prev2 = <span class="number">1</span>, <span class="comment">//当前位置的前1位和前2位</span></span><br><span class="line">    n = <span class="number">1</span>; <span class="comment">//当前是第几位</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    next() &#123;</span><br><span class="line">      <span class="keyword">let</span> value;</span><br><span class="line">      <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">        value = <span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        value = prev1 + prev2;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> result = &#123;</span><br><span class="line">        value,</span><br><span class="line">        done: <span class="literal">false</span>,</span><br><span class="line">      &#125;;</span><br><span class="line">      prev2 = prev1;</span><br><span class="line">      prev1 = result.value;</span><br><span class="line">      n++;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> iterator = createFeiboIterator();</span><br></pre></td></tr></table></figure><h2 id="可迭代协议-与-for-of-循环"><a href="#可迭代协议-与-for-of-循环" class="headerlink" title="可迭代协议 与 for-of 循环"></a>可迭代协议 与 for-of 循环</h2><h3 id="可迭代协议"><a href="#可迭代协议" class="headerlink" title="可迭代协议"></a>可迭代协议</h3><p><strong>概念回顾</strong></p><ul><li>迭代器(iterator)：一个具有 next 方法的对象，next 方法返回下一个数据并且能指示是否迭代完成</li><li>迭代器创建函数（iterator creator）：一个返回迭代器的函数</li></ul><h4 id="可迭代协议-1"><a href="#可迭代协议-1" class="headerlink" title="可迭代协议"></a>可迭代协议</h4><p>==ES6 规定，如果一个对象具有知名符号属性<code>Symbol.iterator</code>，并且属性值是一个迭代器创建函数，则该对象是可迭代的（iterable）==</p><blockquote><p>思考：如何知晓一个对象是否是可迭代的？</p></blockquote><p>答：判断是否有 Symbol.iterator 这个符号属性，并且是否是一个函数</p><blockquote><p>思考：如何遍历一个可迭代对象？</p></blockquote><p>答：如下。</p><h4 id="遍历可迭代对象"><a href="#遍历可迭代对象" class="headerlink" title="遍历可迭代对象"></a>遍历可迭代对象</h4><ul><li>数组是可迭代对象</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">5</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>];</span><br><span class="line"><span class="keyword">const</span> iterator = arr[<span class="built_in">Symbol</span>.iterator](); <span class="comment">//返回arr的迭代器</span></span><br><span class="line"><span class="keyword">let</span> result = iterator.next();</span><br><span class="line"><span class="keyword">while</span> (!result.done) &#123;</span><br><span class="line">  <span class="comment">//判断迭代是否完成</span></span><br><span class="line">  <span class="keyword">const</span> item = result.value; <span class="comment">//取出数据</span></span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">  result = iterator.next(); <span class="comment">//下一次迭代</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>获取的 domList 也是可迭代对象</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> divs = <span class="built_in">document</span>.querySelectorAll(<span class="string">&quot;div&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> iterator = divs[<span class="built_in">Symbol</span>.iterator](); <span class="comment">//返回divs的迭代器</span></span><br><span class="line"><span class="keyword">let</span> result = iterator.next();</span><br><span class="line"><span class="keyword">while</span> (!result.done) &#123;</span><br><span class="line">  <span class="keyword">const</span> item = result.value; <span class="comment">//取出数据</span></span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">  result = iterator.next(); <span class="comment">//下一次迭代</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="for-of-循环"><a href="#for-of-循环" class="headerlink" title="for-of 循环"></a>for-of 循环</h4><ul><li>for-of 循环用于遍历可迭代对象，格式如下</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//迭代完成后循环结束</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> iterable) &#123;</span><br><span class="line">  <span class="comment">//iterable：可迭代对象</span></span><br><span class="line">  <span class="comment">//item：每次迭代得到的数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>基本使用：</strong></li></ul><p>遍历数组：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">5</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// const iterator = arr[Symbol.iterator]();</span></span><br><span class="line"><span class="comment">// let result = iterator.next();</span></span><br><span class="line"><span class="comment">// while (!result.done) &#123;</span></span><br><span class="line"><span class="comment">//     const item = result.value; //取出数据</span></span><br><span class="line"><span class="comment">//     console.log(item);</span></span><br><span class="line"><span class="comment">//     //下一次迭代</span></span><br><span class="line"><span class="comment">//     result = iterator.next();</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="comment">//作用完全相等于上方代码</span></span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遍历对象属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="number">2</span>,</span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">    <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(<span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      next: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> propName = keys[i];</span><br><span class="line">        <span class="keyword">const</span> propValue = <span class="built_in">this</span>[propName];</span><br><span class="line">        <span class="keyword">const</span> result = &#123;</span><br><span class="line">          value: &#123;</span><br><span class="line">            propName,</span><br><span class="line">            propValue,</span><br><span class="line">          &#125;,</span><br><span class="line">          done: i &gt;= keys.length,</span><br><span class="line">        &#125;;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> obj) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="展开运算符与可迭代对象"><a href="#展开运算符与可迭代对象" class="headerlink" title="展开运算符与可迭代对象"></a>展开运算符与可迭代对象</h4><p>展开运算符可以==<strong>作用于可迭代对象</strong>==，这样，就可以轻松的将可迭代对象转换为数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="number">2</span>,</span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">    <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(<span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      next: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> propName = keys[i];</span><br><span class="line">        <span class="keyword">const</span> propValue = <span class="built_in">this</span>[propName];</span><br><span class="line">        <span class="keyword">const</span> result = &#123;</span><br><span class="line">          value: &#123;</span><br><span class="line">            propName,</span><br><span class="line">            propValue,</span><br><span class="line">          &#125;,</span><br><span class="line">          done: i &gt;= keys.length,</span><br><span class="line">        &#125;;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [...obj]; <span class="comment">//把可迭代对象展开放入数组中</span></span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//此处是被展开后的属性a和b</span></span><br><span class="line">  <span class="built_in">console</span>.log(a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(...obj); <span class="comment">// //把可迭代对象展开放入函数中</span></span><br></pre></td></tr></table></figure><h2 id="生成器-Generator"><a href="#生成器-Generator" class="headerlink" title="生成器 (Generator)"></a>生成器 (Generator)</h2><h3 id="什么是生成器？"><a href="#什么是生成器？" class="headerlink" title="什么是生成器？"></a>什么是生成器？</h3><p>生成器是一个通过构造函数 Generator 创建的对象，生成器既是一个迭代器，同时又是一个可迭代对象</p><h3 id="如何创建生成器？"><a href="#如何创建生成器？" class="headerlink" title="如何创建生成器？"></a>如何创建生成器？</h3><p>生成器的创建，必须使用生成器函数（Generator Function）</p><h3 id="生成器格式-amp-基本使用"><a href="#生成器格式-amp-基本使用" class="headerlink" title="生成器格式&amp;基本使用"></a>生成器格式&amp;基本使用</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是一个生成器函数，该函数一定返回一个生成器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">method</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//注：*可以在function后面，也可在函数名前面</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>==生成器函数内部是如何执行的？==</strong></p><p>生成器函数内部是为了给生成器的每次迭代提供的数据</p><p>每次调用生成器的 next 方法，将导致生成器函数运行到下一个 yield 关键字位置</p><p>yield 是一个关键字，该关键字只能在生成器函数内部使用，表达“产生”一个迭代数据。</p><p><strong>==生成器基本使用：==</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;第1次运行&quot;</span>);</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>; <span class="comment">//返回value值为1</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;第2次运行&quot;</span>);</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>; <span class="comment">//返回value值为2</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;第3次运行&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> generator = test();</span><br><span class="line">grenerator.next();</span><br><span class="line"><span class="comment">//第一次运行</span></span><br><span class="line"><span class="comment">//&#123;value: 1, done: false&#125;</span></span><br><span class="line">grenerator.next();</span><br><span class="line"><span class="comment">//第二次运行</span></span><br><span class="line"><span class="comment">//&#123;value: 2, done: false&#125;</span></span><br><span class="line">grenerator.next();</span><br><span class="line"><span class="comment">//第三次运行，后面没有yield关键字，迭代器结束</span></span><br><span class="line"><span class="comment">//&#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure><p>数组迭代：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代器创建函数  iterator creator</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">createIterator</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">    <span class="keyword">yield</span> item;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> iter1 = createIterator(arr1);</span><br><span class="line"><span class="keyword">const</span> iter2 = createIterator(arr2);</span><br></pre></td></tr></table></figure><p>斐波拉契数列</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个斐波拉契数列的迭代器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">createFeiboIterator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> prev1 = <span class="number">1</span>,</span><br><span class="line">    prev2 = <span class="number">1</span>, <span class="comment">//当前位置的前1位和前2位</span></span><br><span class="line">    n = <span class="number">1</span>; <span class="comment">//当前是第几位</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> newValue = prev1 + prev2;</span><br><span class="line">      <span class="keyword">yield</span> newValue;</span><br><span class="line">      prev2 = prev1;</span><br><span class="line">      prev1 = newValue;</span><br><span class="line">    &#125;</span><br><span class="line">    n++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> iterator = createFeiboIterator();</span><br></pre></td></tr></table></figure><h3 id="需要注意的细节"><a href="#需要注意的细节" class="headerlink" title="需要注意的细节"></a>需要注意的细节</h3><ol><li><p>生成器函数可以有返回值，返回值出现在第一次 done 为 true 时的 value 属性中（也就是迭代结束的时候）</p><pre><code><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">function</span>* <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;第1次运行&quot;</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;第2次运行&quot;</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;第3次运行&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2.  调用生成器的 next 方法时，可以传递参数，传递的参数会交给 yield 表达式的返回值</span><br><span class="line"></span><br><span class="line">    &#96;&#96;&#96;js</span><br><span class="line">    function* test() &#123;</span><br><span class="line">      console.log(&quot;函数开始&quot;);</span><br><span class="line">      let info &#x3D; yield 1; &#x2F;&#x2F; 此处不是把1赋值给info</span><br><span class="line">      console.log(info);</span><br><span class="line">      info &#x3D; yield 2 + info;</span><br><span class="line">      console.log(info);</span><br><span class="line">    &#125;</span><br><span class="line">    const generator &#x3D; test();</span><br><span class="line">    genrator.next(); &#x2F;&#x2F; 函数开始  &#123;value: 1, done: false&#125;</span><br><span class="line">    genrator.next(5); &#x2F;&#x2F;在这里传递参数 &#123;value: 7, done: false&#125;</span><br><span class="line">    grenerator.next();</span><br><span class="line">    &#x2F;&#x2F;第三次运行，后面没有yield关键字，迭代器结束</span><br><span class="line">    &#x2F;&#x2F;&#123;value: undefined, done: true&#125;</span><br></pre></td></tr></table></figure></li><li><p>第一次调用 next 方法时，传参没有任何意义</p></li><li><p>在生成器函数内部，可以调用其他生成器函数，但是要注意加上*号</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">t1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span>* t1();</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="生成器的其他-API"><a href="#生成器的其他-API" class="headerlink" title="生成器的其他 API"></a>生成器的其他 API</h3><ul><li>return 方法：调用该方法，可以提前结束生成器函数，从而提前让整个迭代过程结束<ul><li>grenerator.return(); 让整个迭代结束{value: undefined, done: true}</li><li>grenerator.return(10);让整个迭代结束{value: 10, done: true}</li></ul></li><li>throw 方法：调用该方法，可以在生成器中产生一个错误<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>; <span class="comment">//错误会放在这里</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> generator = test();</span><br><span class="line">generator.next();</span><br><span class="line">generator.throw(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;这是一个错误&quot;</span>));</span><br></pre></td></tr></table></figure></li></ul><h2 id="生成器应用-异步任务控制"><a href="#生成器应用-异步任务控制" class="headerlink" title="生成器应用-异步任务控制"></a>生成器应用-异步任务控制</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">task</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> d = <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(d);</span><br><span class="line">  <span class="comment">// //d : 1</span></span><br><span class="line">  <span class="keyword">const</span> resp = <span class="keyword">yield</span> fetch(<span class="string">&quot;http://101.132.72.36:5100/api/local&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">yield</span> resp.json();</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run(task);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">generatorFunc</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> generator = generatorFunc();</span><br><span class="line">  <span class="keyword">let</span> result = generator.next(); <span class="comment">//启动任务（开始迭代）, 得到迭代数据</span></span><br><span class="line">  handleResult();</span><br><span class="line">  <span class="comment">//对result进行处理</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleResult</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (result.done) &#123;</span><br><span class="line">      <span class="keyword">return</span>; <span class="comment">//迭代完成，不处理</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//迭代没有完成，分为两种情况</span></span><br><span class="line">    <span class="comment">//1. 迭代的数据是一个Promise</span></span><br><span class="line">    <span class="comment">//2. 迭代的数据是其他数据</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> result.value.then === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">      <span class="comment">//1. 迭代的数据是一个Promise</span></span><br><span class="line">      <span class="comment">//等待Promise完成后，再进行下一次迭代</span></span><br><span class="line">      result.value.then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">        result = generator.next(data);</span><br><span class="line">        handleResult();</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//2. 迭代的数据是其他数据，直接进行下一次迭代</span></span><br><span class="line">      result = generator.next(result.value);</span><br><span class="line">      handleResult();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="更多集合类型"><a href="#更多集合类型" class="headerlink" title="更多集合类型"></a>更多集合类型</h1><blockquote><p>一直以来，JS 只能使用数组和对象来保存多个数据，缺乏像其他语言那样拥有丰富的集合类型。因此，ES6 新增了两种集合类型（set 和 map），用于在不同的场景中发挥作用。</p></blockquote><h2 id="set-集合"><a href="#set-集合" class="headerlink" title="set 集合"></a>set 集合</h2><p>set 用于存放不重复的数据</p><h3 id="创建-set-集合"><a href="#创建-set-集合" class="headerlink" title="创建 set 集合"></a>创建 set 集合</h3><p>创建一个没有任何内容的 set 集合</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Set</span>();</span><br></pre></td></tr></table></figure><p>创建一个具有初始内容的 set 集合，内容来自于可迭代对象每一次迭代的结果</p><ul><li>传入可迭代对象</li><li>字符串也是可迭代对象，每次迭代一个字符</li><li>也是一种非常简单的去重方式</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Set</span>(iterable); <span class="comment">//传入必须是可迭代对象</span></span><br></pre></td></tr></table></figure><h3 id="set-集合的操作"><a href="#set-集合的操作" class="headerlink" title="set 集合的操作"></a>set 集合的操作</h3><ul><li>add(数据): 添加一个数据到 set 集合末尾，如果数据已存在，则不进行任何操作<ul><li>set 使用 Object.is 的方式判断两个数据是否相同，但是，针对+0 和-0，set 认为是相等</li></ul></li><li>has(数据): 判断 set 中是否存在对应的数据</li><li>delete(数据)：删除匹配的数据，返回是否删除成功</li><li>clear()：清空整个 set 集合</li><li>size: 获取 set 集合中的元素数量，只读属性，无法重新赋值</li></ul><p>数组转换成 set 集合：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([……]);</span><br></pre></td></tr></table></figure><p>set 集合转换成数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [...s];</span><br></pre></td></tr></table></figure><p>数组去重</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">const</span> result = [...new <span class="built_in">Set</span>(arr)];</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure><p>字符串去重</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&quot;adsdlfjdslkf&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> result = [...new <span class="built_in">Set</span>(str)].join(<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure><h3 id="遍历-set-集合"><a href="#遍历-set-集合" class="headerlink" title="遍历 set 集合"></a>遍历 set 集合</h3><ol><li>使用 for-of 循环</li><li>使用 set 中的实例方法 forEach<ul><li>注意：set 集合中不存在下标，因此 forEach 中的回调的第二个参数和第一个参数是一致的，均表示 set 中的每一项</li></ul></li></ol><h3 id="set-应用"><a href="#set-应用" class="headerlink" title="set 应用"></a>set 应用</h3><ul><li>获得两个数组的并集、交集、差集(不能出现重复项)，得到的结果是一个新数组</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//并集</span></span><br><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>(arr1.concat(arr2));</span><br><span class="line"><span class="keyword">const</span> result = [...s]</span><br><span class="line">cosnt result = [...new <span class="built_in">Set</span>(arr1.concat(arr2))];<span class="comment">//一步写完方式一</span></span><br><span class="line">cosnt result = [...new <span class="built_in">Set</span>([...arr1,...arr2])];<span class="comment">//一步写完方式二</span></span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br><span class="line"></span><br><span class="line"><span class="comment">//交集</span></span><br><span class="line"><span class="keyword">const</span> s1 = <span class="keyword">new</span> <span class="built_in">Set</span>(arr1);</span><br><span class="line">[...s1].filter(<span class="function"><span class="params">item</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr2.indexOf(item) &gt;=<span class="number">0</span>;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> result = [...new <span class="built_in">Set</span>(arr1)].filter(<span class="function"><span class="params">item</span> =&gt;</span> arr2.indexOf(item) &gt;= <span class="number">0</span>);<span class="comment">//简写</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//差集</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;差集&quot;</span>, [...new <span class="built_in">Set</span>([...arr1, ...arr2])].filter(<span class="function"><span class="params">item</span> =&gt;</span> arr1.indexOf(item) &gt;= <span class="number">0</span> &amp;&amp; arr2.indexOf(item) &lt; <span class="number">0</span> || arr2.indexOf(item) &gt;= <span class="number">0</span> &amp;&amp; arr1.indexOf(item) &lt; <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;差集&quot;</span>, [...new <span class="built_in">Set</span>([...arr1, ...arr2])].filter(<span class="function"><span class="params">item</span> =&gt;</span> jiaoji.indexOf(item) &lt; <span class="number">0</span>)) <span class="comment">//如果已经有交集，可以用它</span></span><br></pre></td></tr></table></figure><h3 id="手写-set-扩展"><a href="#手写-set-扩展" class="headerlink" title="手写 set[扩展]"></a>手写 set[扩展]</h3><p>这里是模拟，并不是和源码一模一样</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySet</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(iterator = []) &#123;</span><br><span class="line">    <span class="comment">//验证是否是可迭代的对象</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> iterator[<span class="built_in">Symbol</span>.iterator] !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">`你提供的<span class="subst">$&#123;iterator&#125;</span>不是一个可迭代的对象`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>._datas = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> iterator) &#123;</span><br><span class="line">      <span class="built_in">this</span>.add(item);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> <span class="title">size</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._datas.length;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  add(data) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.has(data)) &#123;</span><br><span class="line">      <span class="built_in">this</span>._datas.push(data);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  has(data) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> <span class="built_in">this</span>._datas) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.isEqual(data, item)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span>(data) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>._datas.length; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> element = <span class="built_in">this</span>._datas[i];</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.isEqual(element, data)) &#123;</span><br><span class="line">        <span class="comment">//删除</span></span><br><span class="line">        <span class="built_in">this</span>._datas.splice(i, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  clear() &#123;</span><br><span class="line">    <span class="built_in">this</span>._datas.length = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//这里是用生成器创建迭代器</span></span><br><span class="line">  *[<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> <span class="built_in">this</span>._datas) &#123;</span><br><span class="line">      <span class="keyword">yield</span> item;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  forEach(callback) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> <span class="built_in">this</span>._datas) &#123;</span><br><span class="line">      callback(item, item, <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 判断两个数据是否相等</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;*&#125;</span> <span class="variable">data1</span></span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;*&#125;</span> <span class="variable">data2</span></span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  isEqual(data1, data2) &#123;</span><br><span class="line">    <span class="keyword">if</span> (data1 === <span class="number">0</span> &amp;&amp; data2 === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.is(data1, data2);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="map-集合"><a href="#map-集合" class="headerlink" title="map 集合"></a>map 集合</h2><p>键值对（key value pair）数据集合的特点：键不可重复</p><p>map 集合专门用于存储多个键值对数据。</p><p>在 map 出现之前，我们使用的是对象的方式来存储键值对，键是属性名，值是属性值。</p><p>使用对象存储有以下问题：</p><ol><li>键名只能是字符串</li><li>获取数据的数量不方便</li><li>键名容易跟原型上的名称冲突</li></ol><h3 id="创建-map-集合"><a href="#创建-map-集合" class="headerlink" title="创建 map 集合"></a>创建 map 集合</h3><p>创建一个空的 map</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Map</span>();</span><br></pre></td></tr></table></figure><p>创建一个具有初始内容的 map，初始内容来自于可迭代对象每一次迭代的结果，但是，它要求每一次迭代的结果必须是一个长度为 2 的数组，数组第一项表示键，数组的第二项表示值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mp1 = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="string">&quot;a&quot;</span>, <span class="number">3</span>],</span><br><span class="line">  [<span class="string">&quot;b&quot;</span>, <span class="number">4</span>],</span><br><span class="line">  [<span class="string">&quot;c&quot;</span>, <span class="number">5</span>],</span><br><span class="line">]);</span><br></pre></td></tr></table></figure><h3 id="操作-map-集合"><a href="#操作-map-集合" class="headerlink" title="操作 map 集合"></a>操作 map 集合</h3><ul><li>size：只读属性，获取当前 map 中键的数量</li><li>set(键, 值)：设置一个键值对，键和值可以是任何类型<ul><li>如果键不存在，则添加一项</li><li>如果键已存在，则修改它的值</li><li>比较键的方式和 set 相同</li></ul></li><li>get(键): 根据一个键得到对应的值</li><li>has(键)：判断某个键是否存在</li><li>delete(键)：删除指定的键</li><li>clear(): 清空 map</li></ul><h3 id="和数组互相转换"><a href="#和数组互相转换" class="headerlink" title="和数组互相转换"></a>和数组互相转换</h3><p>数组转换成 map 集合：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Map</span>([……]);</span><br></pre></td></tr></table></figure><p>map 集合转换成数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [...s];</span><br></pre></td></tr></table></figure><h3 id="遍历-map-集合"><a href="#遍历-map-集合" class="headerlink" title="遍历 map 集合"></a>遍历 map 集合</h3><ul><li>for-of，每次迭代得到的是一个长度为 2 的数组</li><li>forEach，通过回调函数遍历<ul><li>参数 1：每一项的值</li><li>参数 2：每一项的键</li><li>参数 3：map 本身</li></ul></li></ul><h3 id="手写-map-扩展"><a href="#手写-map-扩展" class="headerlink" title="手写 map[扩展]"></a>手写 map[扩展]</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyMap</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(iterable = []) &#123;</span><br><span class="line">    <span class="comment">//验证是否是可迭代的对象</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> iterable[<span class="built_in">Symbol</span>.iterator] !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">`你提供的<span class="subst">$&#123;iterable&#125;</span>不是一个可迭代的对象`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>._datas = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> iterable) &#123;</span><br><span class="line">      <span class="comment">// item 也得是一个可迭代对象</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> item[<span class="built_in">Symbol</span>.iterator] !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">`你提供的<span class="subst">$&#123;item&#125;</span>不是一个可迭代的对象`</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> iterator = item[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line">      <span class="keyword">const</span> key = iterator.next().value;</span><br><span class="line">      <span class="keyword">const</span> value = iterator.next().value;</span><br><span class="line">      <span class="built_in">this</span>.set(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  set(key, value) &#123;</span><br><span class="line">    <span class="keyword">const</span> obj = <span class="built_in">this</span>._getObj(key);</span><br><span class="line">    <span class="keyword">if</span> (obj) &#123;</span><br><span class="line">      <span class="comment">//修改</span></span><br><span class="line">      obj.value = value;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>._datas.push(&#123;</span><br><span class="line">        key,</span><br><span class="line">        value,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  get(key) &#123;</span><br><span class="line">    <span class="keyword">const</span> item = <span class="built_in">this</span>._getObj(key);</span><br><span class="line">    <span class="keyword">if</span> (item) &#123;</span><br><span class="line">      <span class="keyword">return</span> item.value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> <span class="title">size</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._datas.length;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span>(key) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>._datas.length; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> element = <span class="built_in">this</span>._datas[i];</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.isEqual(element.key, key)) &#123;</span><br><span class="line">        <span class="built_in">this</span>._datas.splice(i, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  clear() &#123;</span><br><span class="line">    <span class="built_in">this</span>._datas.length = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 根据key值从内部数组中，找到对应的数组项</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;*&#125;</span> <span class="variable">key</span></span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  _getObj(key) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> <span class="built_in">this</span>._datas) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.isEqual(item.key, key)) &#123;</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  has(key) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._getObj(key) !== <span class="literal">undefined</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 判断两个数据是否相等</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;*&#125;</span> <span class="variable">data1</span></span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;*&#125;</span> <span class="variable">data2</span></span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  isEqual(data1, data2) &#123;</span><br><span class="line">    <span class="keyword">if</span> (data1 === <span class="number">0</span> &amp;&amp; data2 === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.is(data1, data2);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  *[<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> <span class="built_in">this</span>._datas) &#123;</span><br><span class="line">      <span class="keyword">yield</span> [item.key, item.value];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  forEach(callback) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> <span class="built_in">this</span>._datas) &#123;</span><br><span class="line">      callback(item.value, item.key, <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="WeakSet-和-WeakMap-扩展"><a href="#WeakSet-和-WeakMap-扩展" class="headerlink" title="WeakSet 和 WeakMap[扩展]"></a>WeakSet 和 WeakMap[扩展]</h2><h3 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h3><p>使用该集合，可以实现和 set 一样的功能，不同的是：</p><ol><li><strong>它内部存储的对象地址不会影响垃圾回收</strong><ul><li>使用 Set()时，在数据对象变为 null 的时候，通过 set 对象依然可以找到数据，数据因为 Set()的影响不会被回收</li><li>使用 WeakSet()对象时，则数据对象在变为 null 的时，不会影响其垃圾回收(也就是数据会回收，WeakSet 对象也找不到)<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  name: <span class="string">&quot;yj&quot;</span>,</span><br><span class="line">  age: <span class="number">18</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//const set = new Set();</span></span><br><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="built_in">WeakSet</span>();</span><br><span class="line">set.add(obj);</span><br><span class="line">obj = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">console</span>.log(set);</span><br><span class="line"><span class="comment">//注意：垃圾回收不是立即回收的，重新获取set会为空</span></span><br></pre></td></tr></table></figure></li></ul></li><li>只能添加对象</li><li>不能遍历（不是可迭代的对象）、没有 size 属性、没有 forEach 方法</li><li>主要就是看看是否被回收</li></ol><h3 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h3><p>类似于 map 的集合，不同的是：</p><ol><li><strong>它的键存储的地址不会影响垃圾回收</strong></li><li>它的键只能是对象</li><li>不能遍历（不是可迭代的对象）、没有 size 属性、没有 forEach 方法</li></ol><ul><li>应用场景：有时候界面的某些元素可能会关联到一个普通的 js 对象，这个&lt;li&gt;存在的话，这个对象应该存在，这个&lt;li&gt;不存在的话，这个对象应该消失。如果把这些对象放在数组里面，因为不会回收就要出问题，这个时候就可以用 WeakMap 来实现</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;!-- &#123; id:&quot;1&quot;, name:&quot;姓名1&quot; &#125; --&gt;</span><br><span class="line">    &lt;li&gt;1&lt;&#x2F;li&gt;</span><br><span class="line">    &lt;!-- &#123; id:&quot;2&quot;, name:&quot;姓名2&quot; &#125; --&gt;</span><br><span class="line">    &lt;li&gt;2&lt;&#x2F;li&gt;</span><br><span class="line">    &lt;!-- &#123; id:&quot;3&quot;, name:&quot;姓名3&quot; &#125; --&gt;</span><br><span class="line">    &lt;li&gt;3&lt;&#x2F;li&gt;</span><br><span class="line">&lt;&#x2F;ul&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    const wmap &#x3D; new WeakMap();</span><br><span class="line">    let list &#x3D; document.querySelectorAll(&quot;li&quot;);</span><br><span class="line">    for (const li of list) &#123;</span><br><span class="line">        wmap.set(li, &#123;</span><br><span class="line">            id: li.innerHTML,</span><br><span class="line">            name: &#96;姓名$&#123;li.innerHTML&#125;&#96;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    lis[0].remove();</span><br><span class="line">    lis &#x3D; null;</span><br><span class="line"></span><br><span class="line">    console.log(wmap);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h1 id="代理与反射"><a href="#代理与反射" class="headerlink" title="代理与反射"></a>代理与反射</h1><h3 id="Reflect-反射"><a href="#Reflect-反射" class="headerlink" title="Reflect 反射"></a>Reflect 反射</h3><p>Reflect 是一个内置的 JS 对象，它提供了一系列方法，可以让开发者通过调用这些方法，访问一些 JS 底层功能</p><p>由于它类似于其他语言的<strong>反射</strong>，因此取名为 Reflect</p><h4 id="它可以做什么？"><a href="#它可以做什么？" class="headerlink" title="它可以做什么？"></a>它可以做什么？</h4><p>使用 Reflect 可以实现诸如 属性的赋值与取值、调用普通函数、调用构造函数、判断属性是否存在与对象中 等等功能</p><h4 id="这些功能不是已经存在了吗？为什么还需要用-Reflect-实现一次？"><a href="#这些功能不是已经存在了吗？为什么还需要用-Reflect-实现一次？" class="headerlink" title="这些功能不是已经存在了吗？为什么还需要用 Reflect 实现一次？"></a>这些功能不是已经存在了吗？为什么还需要用 Reflect 实现一次？</h4><p>有一个重要的理念，在 ES5 就被提出：==减少魔法、让代码更加纯粹==</p><p>这种理念很大程度上是受到函数式编程的影响</p><p>ES6 进一步贯彻了这种理念，它认为，对属性内存的控制、原型链的修改、函数的调用等等，这些都属于底层实现，属于一种魔法，因此，需要将它们提取出来，形成一个正常的 API，并高度聚合到某个对象中，于是，就造就了 Reflect 对象</p><p>因此，你可以看到 Reflect 对象中有很多的 API 都可以使用过去的某种语法或其他 API 实现。</p><h4 id="提供的-API"><a href="#提供的-API" class="headerlink" title="提供的 API"></a>提供的 API</h4><ul><li>Reflect.set(target, propertyKey, value): 设置对象 target 的属性 propertyKey 的值为 value，等同于给对象的属性赋值</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.a = <span class="number">10</span>; <span class="comment">//阅读起来就是：给obj的属性a赋值为10</span></span><br><span class="line"><span class="built_in">Reflect</span>.set(obj, <span class="string">&quot;a&quot;</span>, <span class="number">10</span>); <span class="comment">//阅读起来就是：使用底层实现，将obj的a赋值为10</span></span><br></pre></td></tr></table></figure><ul><li>Reflect.get(target, propertyKey): 读取对象 target 的属性 propertyKey，等同于读取对象的属性值</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(obj.a);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Reflect</span>.get(obj, <span class="string">&quot;a&quot;</span>));</span><br></pre></td></tr></table></figure><ul><li>Reflect.apply(target, thisArgument, argumentsList)：调用一个指定的函数，并绑定 this 和参数列表。等同于函数调用</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">method</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;method&quot;</span>, a, b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//method(3, 4);</span></span><br><span class="line"><span class="built_in">Reflect</span>.apply(method, <span class="literal">null</span>, [<span class="number">3</span>, <span class="number">4</span>]);</span><br></pre></td></tr></table></figure><ul><li>Reflect.deleteProperty(target, propertyKey)：删除一个对象的属性</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">delete</span> obj.a;</span><br><span class="line"><span class="built_in">Reflect</span>.deleteProperty(obj, <span class="string">&quot;a&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li><p>Reflect.defineProperty(target, propertyKey, attributes)：类似于 Object.defineProperty，不同的是如果配置出现问题，返回 false 而不是报错</p></li><li><p>Reflect.construct(target, argumentsList)：用构造函数的方式创建一个对象</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.a = a;</span><br><span class="line">  <span class="built_in">this</span>.b = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// const t = new Test(1, 3);</span></span><br><span class="line"><span class="keyword">const</span> t = <span class="built_in">Reflect</span>.construct(Test, [<span class="number">1</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(t);</span><br></pre></td></tr></table></figure><ul><li>Reflect.has(target, propertyKey): 判断一个对象是否拥有一个属性</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// console.log(&quot;a&quot; in obj);</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Reflect</span>.has(obj, <span class="string">&quot;a&quot;</span>));</span><br></pre></td></tr></table></figure><ul><li>其他 API：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect</a></li></ul><h2 id="Proxy-代理"><a href="#Proxy-代理" class="headerlink" title="Proxy 代理"></a>Proxy 代理</h2><p>代理：提供了让开发者能够重写底层实现的机制</p><p>格式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代理一个目标对象</span></span><br><span class="line"><span class="comment">//target：目标对象</span></span><br><span class="line"><span class="comment">//handler：是一个普通对象，其中可以重写底层实现</span></span><br><span class="line"><span class="comment">//返回一个代理对象</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br></pre></td></tr></table></figure><p>handler 里面可以重写反射里面的所有方法</p><p>使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;</span><br><span class="line">  set(target, propertyKey, value) &#123;</span><br><span class="line">    <span class="comment">//目标对象，属性名，属性值</span></span><br><span class="line">    target[propertyKey] = value;</span><br><span class="line">    <span class="comment">//代理时一般使用下面这种格式，更容易理解</span></span><br><span class="line">    <span class="built_in">Reflect</span>.set(target, propertyKey, value);</span><br><span class="line">  &#125;,</span><br><span class="line">  get(target, propertyKey) &#123;</span><br><span class="line">    <span class="comment">// 判断是否有这个关键字</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Reflect</span>.has(target, propertyKey)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, propertyKey);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  has(target, propertyKey) &#123;</span><br><span class="line">    <span class="comment">//判断是否含有某属性</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">proxy.a = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(proxy.a); <span class="comment">//10</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy, c); <span class="comment">//-1 通过代理读取c属性，代理运行get</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;a&quot;</span> <span class="keyword">in</span> proxy); <span class="comment">//false 通过代理判断是否含有a这个属性</span></span><br></pre></td></tr></table></figure><h2 id="应用：观察者模式"><a href="#应用：观察者模式" class="headerlink" title="应用：观察者模式"></a>应用：观察者模式</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个观察者</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observer</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> div = <span class="built_in">document</span>.getElementById(<span class="string">&quot;container&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">    set(target, prop, value) &#123;</span><br><span class="line">      <span class="built_in">Reflect</span>.set(target, prop, value);</span><br><span class="line">      render();</span><br><span class="line">    &#125;,</span><br><span class="line">    get(target, prop) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, prop);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">  render();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> html = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> prop <span class="keyword">of</span> <span class="built_in">Object</span>.keys(target)) &#123;</span><br><span class="line">      html += <span class="string">`</span></span><br><span class="line"><span class="string">                &lt;p&gt;&lt;span&gt;<span class="subst">$&#123;prop&#125;</span>：&lt;/span&gt;&lt;span&gt;<span class="subst">$&#123;target[prop]&#125;</span>&lt;/span&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="string">            `</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    div.innerHTML = html;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> obj = observer(target);</span><br></pre></td></tr></table></figure><h2 id="应用：偷懒的构造函数"><a href="#应用：偷懒的构造函数" class="headerlink" title="应用：偷懒的构造函数"></a>应用：偷懒的构造函数</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ConstructorProxy</span>(<span class="params">Class, ...propNames</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(Class, &#123;</span><br><span class="line">    construct(target, argumentsList) &#123;</span><br><span class="line">      <span class="keyword">const</span> obj = <span class="built_in">Reflect</span>.construct(target, argumentsList);</span><br><span class="line">      propNames.forEach(<span class="function">(<span class="params">name, i</span>) =&gt;</span> &#123;</span><br><span class="line">        obj[name] = argumentsList[i];</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> UserProxy = ConstructorProxy(User, <span class="string">&quot;firstName&quot;</span>, <span class="string">&quot;lastName&quot;</span>, <span class="string">&quot;age&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> UserProxy(<span class="string">&quot;袁&quot;</span>, <span class="string">&quot;进&quot;</span>, <span class="number">18</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Monster</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MonsterProxy = ConstructorProxy(</span><br><span class="line">  Monster,</span><br><span class="line">  <span class="string">&quot;attack&quot;</span>,</span><br><span class="line">  <span class="string">&quot;defence&quot;</span>,</span><br><span class="line">  <span class="string">&quot;hp&quot;</span>,</span><br><span class="line">  <span class="string">&quot;rate&quot;</span>,</span><br><span class="line">  <span class="string">&quot;name&quot;</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> MonsterProxy(<span class="number">10</span>, <span class="number">20</span>, <span class="number">100</span>, <span class="number">30</span>, <span class="string">&quot;怪物&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(m);</span><br></pre></td></tr></table></figure><h2 id="应用：可验证的参数函数"><a href="#应用：可验证的参数函数" class="headerlink" title="应用：可验证的参数函数"></a>应用：可验证的参数函数</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">validatorFunction</span>(<span class="params">func, ...types</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(func, &#123;</span><br><span class="line">    apply(target, thisArgument, argumentsList) &#123;</span><br><span class="line">      types.forEach(<span class="function">(<span class="params">t, i</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> arg = argumentsList[i];</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> arg !== t) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(</span><br><span class="line">            <span class="string">`第<span class="subst">$&#123;i + <span class="number">1</span>&#125;</span>个参数<span class="subst">$&#123;argumentsList[i]&#125;</span>不满足类型<span class="subst">$&#123;t&#125;</span>`</span></span><br><span class="line">          );</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Reflect</span>.apply(target, thisArgument, argumentsList);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sumProxy = validatorFunction(sum, <span class="string">&quot;number&quot;</span>, <span class="string">&quot;number&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(sumProxy(<span class="number">1</span>, <span class="number">2</span>));</span><br></pre></td></tr></table></figure><h1 id="增强的数组功能"><a href="#增强的数组功能" class="headerlink" title="增强的数组功能"></a>增强的数组功能</h1><h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><ul><li>Array.of(…args): 使用指定的数组项创建一个新数组<ul><li>和 Array(…args)是一样的，只是传一个参数时也是参数</li><li><code>const arr = new Array.of(1,2,3)</code></li><li>建议：除非初始化长度，否则建议使用[]或者 Array.of()</li></ul></li><li>Array.from(arg): 传入类数组或可迭代对象，创建一个新的数组</li></ul><h2 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h2><ul><li>find(callback): 用于查找满足条件的第一个元素<ul><li>一般查找一个元素时用 find，查找多个时用 filter</li></ul></li><li>findIndex(callback)：用于查找满足条件的第一个元素的下标<ul><li>indexOf()用来查找对象数组时，因为地址不一样，所以会出问题</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">&quot;a&quot;</span>,</span><br><span class="line">    id: <span class="number">1</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">&quot;b&quot;</span>,</span><br><span class="line">    id: <span class="number">2</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">&quot;c&quot;</span>,</span><br><span class="line">    id: <span class="number">3</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">//找到id为5的对象</span></span><br><span class="line"><span class="comment">//arr.find(item =&gt;&#123;</span></span><br><span class="line"><span class="comment">//    if(item.id === 5)&#123;</span></span><br><span class="line"><span class="comment">//        return true;</span></span><br><span class="line"><span class="comment">//    &#125; else &#123;</span></span><br><span class="line"><span class="comment">//        return false</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//&#125;)</span></span><br><span class="line"><span class="keyword">const</span> result = arr.find(<span class="function">(<span class="params">item</span>) =&gt;</span> item.id === <span class="number">3</span>);</span><br><span class="line"><span class="keyword">const</span> resultIndex = arr.findIndex(<span class="function">(<span class="params">item</span>) =&gt;</span> item.id === <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(result, resultIndex); <span class="comment">//obj 2 ,若不存在返回undefined</span></span><br></pre></td></tr></table></figure><ul><li>fill(data)：用指定的数据填充满数组所有的内容</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建了一个长度为100的数组，数组的每一项是&quot;abc&quot;</span></span><br><span class="line"><span class="keyword">const</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">100</span>);</span><br><span class="line">arr.fill(<span class="string">&quot;abc&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li>copyWithin(target, start?, end?): 在数组内部完成复制<ul><li>后两项代表可传可不传</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="comment">//从下标2开始，改变数组的数据，数据来自于下标0位置开始</span></span><br><span class="line">arr.copyWithin(<span class="number">2</span>); <span class="comment">// [1, 2, 1, 2, 3, 4]</span></span><br><span class="line">arr.copyWithin(<span class="number">2</span>, <span class="number">1</span>); <span class="comment">// [1, 2, 2, 3, 4, 5]</span></span><br><span class="line">arr.copyWithin(<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>); <span class="comment">// [1, 2, 2, 4, 5, 6]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br></pre></td></tr></table></figure><ul><li>includes(data)：判断数组中是否包含某个值，使用 Object.is 匹配</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">45</span>, <span class="number">21</span>, <span class="number">356</span>, <span class="number">66</span>, <span class="number">6</span>, <span class="literal">NaN</span>, <span class="number">723</span>, <span class="number">54</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr.indexOf(<span class="number">66</span>) &gt;= <span class="number">0</span>); <span class="comment">//拿的是下标，语义化不好</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.includes(<span class="number">66</span>)); <span class="comment">//返回布尔</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.includes(<span class="literal">NaN</span>)); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><h2 id="类型化数组-扩展"><a href="#类型化数组-扩展" class="headerlink" title="类型化数组[扩展]"></a>类型化数组[扩展]</h2><h3 id="数字存储的前置知识"><a href="#数字存储的前置知识" class="headerlink" title="数字存储的前置知识"></a>数字存储的前置知识</h3><ol><li><p>计算机必须使用固定的位数来存储数字，无论存储的数字是大是小，在内存中占用的空间是固定的。</p></li><li><p>n 位的无符号整数能表示的数字是 2^n 个，取值范围是：0 ~ 2^n - 1</p></li><li><p>n 位的有符号整数能表示的数字是 2^n 个，取值范围是：-2^(n-1) ~ 2^(n-1) - 1</p></li><li><p>浮点数表示法可以用于表示整数和小数，目前分为两种标准：</p><ol><li>32 位浮点数：又称为单精度浮点数，它用 1 位表示符号，8 位表示阶码，23 位表示尾数</li><li>64 位浮点数：又称为双精度浮点数，它用 1 位表示符号，11 位表示阶码，52 位表示尾数</li></ol></li><li><p>JS 中的所有数字，均使用双精度浮点数保存</p></li></ol><h3 id="类型化数组"><a href="#类型化数组" class="headerlink" title="类型化数组"></a>类型化数组</h3><p>类型化数组：用于优化多个==数字==的存储</p><p>具体分为：</p><ul><li>Int8Array： 8 位有符号整数（-128 ~ 127）</li><li>Uint8Array： 8 位无符号整数（0 ~ 255）</li><li>Int16Array: …</li><li>Uint16Array: …</li><li>Int32Array: …</li><li>Uint32Array: …</li><li>Float32Array:</li><li>Float64Array</li></ul><ol><li>如何创建数组</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">new</span> 数组构造函数(长度)</span><br><span class="line"></span><br><span class="line">数组构造函数.of(元素...)</span><br><span class="line"></span><br><span class="line">数组构造函数.from(可迭代对象)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> 数组构造函数(其他类型化数组)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意：超出既定长度会出现问题</p><ol start="2"><li>得到长度</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">数组.length; <span class="comment">//得到元素数量</span></span><br><span class="line">数组.byteLength; <span class="comment">//得到占用的字节数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = <span class="keyword">new</span> <span class="built_in">Int32Array</span>(<span class="number">10</span>);</span><br><span class="line"><span class="comment">// const arr = Uint8Array.of(12, 5, 6, 7);</span></span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br><span class="line"><span class="built_in">console</span>.log(arr.length);</span><br><span class="line"><span class="built_in">console</span>.log(arr.byteLength);</span><br></pre></td></tr></table></figure><ol start="3"><li>其他的用法跟普通数组一致，但是：</li></ol><ul><li>不能增加和删除数据，==类型化数组的长度固定==</li><li>一些返回数组的方法，返回的数组是同类型化的新数组</li></ul><h2 id="ArrayBuffer-扩展"><a href="#ArrayBuffer-扩展" class="headerlink" title="ArrayBuffer[扩展]"></a>ArrayBuffer[扩展]</h2><p>ArrayBuffer：一个对象，用于存储一块固定内存大小的数据。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(字节数);</span><br></pre></td></tr></table></figure><p>可以通过属性<code>byteLength</code>得到字节数，可以通过方法<code>slice</code>得到新的 ArrayBuffer</p><p>创建了一个用于存储 10 个字节的内存空间</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bf = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bf2 = bf.slice(<span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(bf, bf2);</span><br></pre></td></tr></table></figure><h3 id="读写-ArrayBuffer"><a href="#读写-ArrayBuffer" class="headerlink" title="读写 ArrayBuffer"></a>读写 ArrayBuffer</h3><ol><li>使用 DataView</li></ol><p>通常会在需要混用多种存储格式时使用 DataView</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bf = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">const</span> view = <span class="keyword">new</span> <span class="built_in">DataView</span>(bf); <span class="comment">//ArrayBuffer，开始位置偏移量，操作数量(不可超过长度)</span></span><br><span class="line"><span class="built_in">console</span>.log(view);</span><br><span class="line"></span><br><span class="line">view.setInt16(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">写数据(偏移量, 长度);</span><br><span class="line">view.getInt8(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">读数据;</span><br></pre></td></tr></table></figure><ol start="2"><li>使用类型化数组</li></ol><p>实际上，每一个类型化数组都对应一个 ArrayBuffer，如果没有手动指定 ArrayBuffer，类型化数组创建时，会新建一个 ArrayBuffer</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bf = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">10</span>); <span class="comment">//10个字节的内存</span></span><br><span class="line"><span class="keyword">const</span> arr = <span class="keyword">new</span> <span class="built_in">Int16Array</span>(bf);</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">2344</span>; <span class="comment">//操作了两个字节,如果是Int32Array，则 操作4个字节</span></span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br></pre></td></tr></table></figure><h2 id="制作黑白照片-扩展"><a href="#制作黑白照片-扩展" class="headerlink" title="制作黑白照片[扩展]"></a>制作黑白照片[扩展]</h2><ul><li>制作黑白照片</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div style=<span class="string">&quot;display: flex;&quot;</span>&gt;</span><br><span class="line">        &lt;img src=<span class="string">&quot;./img/liao.jpg&quot;</span> alt=<span class="string">&quot;&quot;</span>&gt;</span><br><span class="line">        &lt;button onclick=<span class="string">&quot;change()&quot;</span>&gt;转换&lt;/button&gt;</span><br><span class="line">        &lt;canvas width=<span class="string">&quot;100&quot;</span> height=<span class="string">&quot;117&quot;</span>&gt;&lt;/canvas&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 画布中的1个图像是由多个像素点组成，每个像素点拥有4个数据：红、绿、蓝、alpha</span></span><br><span class="line"><span class="comment">         * 把一个图像变成黑白，只需要将图像的每个像素点设置成为红绿蓝的平均数即可</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">change</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">const</span> img = <span class="built_in">document</span>.querySelector(<span class="string">&quot;img&quot;</span>);</span><br><span class="line">            <span class="keyword">const</span> cvs = <span class="built_in">document</span>.querySelector(<span class="string">&quot;canvas&quot;</span>);</span><br><span class="line">            <span class="keyword">const</span> ctx = cvs.getContext(<span class="string">&quot;2d&quot;</span>);</span><br><span class="line"></span><br><span class="line">            ctx.drawImage(img, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="comment">//得到画布某一个区域的图像信息</span></span><br><span class="line">            <span class="keyword">const</span> imageData = ctx.getImageData(<span class="number">0</span>, <span class="number">0</span>, img.width, img.height);</span><br><span class="line">            <span class="comment">//这里面的data数据用的是Uint8ClampedArray</span></span><br><span class="line">            <span class="comment">//为什么用Uint8呢？正好是0-255</span></span><br><span class="line">            <span class="comment">//和Uint8Array有什么区别？基本没区别，对画布进行了特殊处理</span></span><br><span class="line">            <span class="built_in">console</span>.log(imageData);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; imageData.data.length; i += <span class="number">4</span>) &#123;</span><br><span class="line">                <span class="comment">//循环一个像素点</span></span><br><span class="line">                <span class="keyword">const</span> r = imageData.data[i];</span><br><span class="line">                <span class="keyword">const</span> g = imageData.data[i + <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">const</span> b = imageData.data[i + <span class="number">2</span>];</span><br><span class="line">                <span class="keyword">const</span> avg = (r + g + b) / <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">                imageData.data[i] = imageData.data[i + <span class="number">1</span>] = imageData.data[i + <span class="number">2</span>] = avg;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将图像数据设置到画布</span></span><br><span class="line">            ctx.putImageData(imageData, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><ul><li>ajax 请求一张图片<br>图片数据不是 json 格式，是一种二进制格式，用 blob()解析。</li></ul><p>blob()返回一个 blob 对象，返回一个文件信息（文件尺寸，类型）</p><p>blob.arrayBuffer()，可以得到一个 ArrayBuffer 数组，记录了图像信息</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> resp = <span class="keyword">await</span> fetch(<span class="string">&quot;./img/liao.jpg&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> blob = <span class="keyword">await</span> resp.blob();</span><br><span class="line">  <span class="keyword">const</span> bf = <span class="keyword">await</span> blob.arrayBuffer(); <span class="comment">//得到二进制信息</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> arr = <span class="keyword">new</span> <span class="built_in">Int8Array</span>(bf, <span class="number">3</span>, <span class="number">2</span>); <span class="comment">//处理二进制信息，可以有偏移量，长度</span></span><br><span class="line">  <span class="built_in">console</span>.log(arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 前端 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript（三）BOM</title>
      <link href="2020/10/01/JavaScript%EF%BC%88%E4%B8%89%EF%BC%89BOM/"/>
      <url>2020/10/01/JavaScript%EF%BC%88%E4%B8%89%EF%BC%89BOM/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是-BOM"><a href="#什么是-BOM" class="headerlink" title="什么是 BOM?"></a>什么是 BOM?</h1><p>BOM browser object model 简称浏览器对象模型</p><p>主要处理浏览器窗口（window）和框架（iframe），描述了浏览器进行交互的方法和接口，可以对浏览器窗口进行访问和操作，不过通常浏览器特定的 JavaScript 扩展都被看做是 BOM 的一部分。</p><a id="more"></a><h2 id="BOM-的核心"><a href="#BOM-的核心" class="headerlink" title="BOM 的核心"></a>BOM 的核心</h2><p>window 对象是 BOM 的顶层（核心）对象，玩转 BOM,就是玩转 window 的属性和方法</p><p>window 对象它具有双重角色，既是通过 js 访问浏览器窗口的一个接口，又是一个全局对象。这意味着在网页中定义的任何对象、变量和函数，都是 window 的属性。</p><h2 id="BOM-和-DOM-的关系"><a href="#BOM-和-DOM-的关系" class="headerlink" title="BOM 和 DOM 的关系"></a>BOM 和 DOM 的关系</h2><p>JavaScript 语法的标准化组织是 ECMA<br>DOM 的标准化组织 W3C<br>BOM…(很尴尬)<br><img src="http://47.97.6.61/%E6%9C%89%E9%81%93%E4%BA%91%E5%9B%BE%E7%89%87/%E6%B5%81%E7%A8%8B.png" alt="流程"></p><h2 id="BOM-的组成"><a href="#BOM-的组成" class="headerlink" title="BOM 的组成"></a>BOM 的组成</h2><ul><li>Window JavaScript 层级中的顶层对象表示浏览器窗口</li><li>Navigator 包含客户端浏览器的信息</li><li>History 包含了浏览器窗口访问过的 URL</li><li>Location 包含了当前 URL 的信息</li><li>Screen 包含客户端显示屏的信息</li></ul><hr><h3 id="window-详解"><a href="#window-详解" class="headerlink" title="window 详解"></a>window 详解</h3><p>重点属性</p><ul><li>innerHeight：返回窗口的文档显示区的高度。</li><li>innerWidth：返回窗口的文档显示区的宽度。</li><li>pageXoffset：设置或返回当前页面相对于窗口显示区左上角的 X 位置（横向偏移量）</li><li>pageYoffset：设置或返回当前页面相对于窗口显示区左上角的 Y 位置（纵向偏移量）</li><li>screenX/Y/Left/Right：声明窗口左上角在屏幕上的坐标。</li><li>top；iframe 中能用的，访问最高的 window。</li><li>self/parent：self 代表自己的 window，parent 代表父级 window。</li><li>open()：打开一个新的浏览器窗口或查找一个已命名的窗口。<ul><li>window.open(URL,name,features,replace)</li><li>window.open(‘<a href="http://www.baidu.com&/#39;,&#39;baidu&#39;,&#39;width=200,height=200&#39;">http://www.baidu.com&#39;,&#39;baidu&#39;,&#39;width=200,height=200&#39;</a>)</li></ul></li><li>scrollBy()：按照指定像素来滚动内容。</li><li>scrollTo()：把内容滚动到指定的坐标。</li><li>moveBy()：可相对窗口的当前坐标把他移动指定的像素。</li><li>moveTo()：把窗口的左上角移动到指定的坐标。</li><li>resizeBy()：按照指定的像素调整窗口的大小。</li><li>resizeTo()：把窗口的大小调整到指定的宽度和高度。</li><li>alert()/prompt()：原生弹窗</li><li>close()：关闭窗口（可能关不了，不重要）</li></ul><h3 id="Navigator（客户端浏览器的信息）"><a href="#Navigator（客户端浏览器的信息）" class="headerlink" title="Navigator（客户端浏览器的信息）"></a>Navigator（客户端浏览器的信息）</h3><p>Navigator 对象包含的属性描述了正在使用的浏览器<br>重点属性</p><ul><li>userAgent：当前浏览器信息。</li><li>platform：返回运行浏览器的操作系统平台。</li><li>onLine：返回系统是否处于脱机状态的布尔值。</li></ul><hr><h3 id="History-对象"><a href="#History-对象" class="headerlink" title="History 对象"></a>History 对象</h3><p>History 对象包含用户（在浏览器窗口中）访问过的 URL</p><ul><li>length：返回浏览器历史列表中的 URL 数量。</li><li>back()：加载 history 列表中的前一个 URL</li><li>forward()：加载 history 列表中的后一个 URL</li><li>go()：加载 history 列表中的某个具体页面</li></ul><hr><h3 id="Location-对象-★"><a href="#Location-对象-★" class="headerlink" title="Location 对象 ★"></a>Location 对象 ★</h3><p>Location 对象包含有关当前 URL 的信息。<br>URL=协议+域名+路径+参数</p><ul><li>protocol：返回协议</li><li>host：域名</li><li>pathname：路径</li><li>search：参数</li><li>hash：锚点<ul><li>1.根据锚点的信息来选择对应要展示的内容</li><li>2.切换内容时我们映射到锚点之中</li><li>3.检测锚点修改，修改以后再映射内容</li></ul></li><li>assign()：加载新的文档。assign(‘<a href="http://www.baidu.com&/#39;">http://www.baidu.com&#39;</a>)</li><li>reload(‘force’)：重新加载当前文档。参数可选，不填或填 false 则取浏览器缓存的文档。</li><li>replace()：用新的文档替换当前文档。</li></ul><h3 id="Screen-对象（基本没用）"><a href="#Screen-对象（基本没用）" class="headerlink" title="Screen 对象（基本没用）"></a>Screen 对象（基本没用）</h3><ul><li>height/weith：屏幕的宽高</li></ul><h3 id="js-使用"><a href="#js-使用" class="headerlink" title="js 使用"></a>js 使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var url&#x3D;new URL(&quot;http:&#x2F;&#x2F;xxx&quot;);</span><br><span class="line">url.protocol,url.host....</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 前端 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript（二）DOM</title>
      <link href="2020/10/01/JavaScript%EF%BC%88%E4%BA%8C%EF%BC%89DOM/"/>
      <url>2020/10/01/JavaScript%EF%BC%88%E4%BA%8C%EF%BC%89DOM/</url>
      
        <content type="html"><![CDATA[<h1 id="DOM-操作"><a href="#DOM-操作" class="headerlink" title="DOM 操作"></a>DOM 操作</h1><h2 id="DOM-选择器（方法类操作）"><a href="#DOM-选择器（方法类操作）" class="headerlink" title="DOM 选择器（方法类操作）"></a>DOM 选择器（方法类操作）</h2><ul><li>document 代表整个文档</li><li>id 选择器 document.getElementById(“only”)</li><li>标签选择器 document.getElementsByTagName(“div”)</li><li>class 选择器 document.getElementsByClassName(“demo”)</li><li>name 选择器 document.getElementsByName(“abc”)<a id="more"></a></li><li>css 选择器：<ul><li>document.querySelector(“div span strong”);（一个元素）</li><li>document.querySelectorAll(“div span strong”);（一组元素）</li><li>注意：选出的元素不是实时的。</li></ul></li></ul><h2 id="节点类型"><a href="#节点类型" class="headerlink" title="节点类型"></a>节点类型</h2><ul><li>元素节点 —— 1</li><li>属性节点 —— 2</li><li>文本节点 —— 3</li><li>注释节点 —— 8</li><li>document —— 9</li><li>DocumentFragment —— 11</li></ul><h2 id="遍历节点树（全能用）"><a href="#遍历节点树（全能用）" class="headerlink" title="遍历节点树（全能用）"></a>遍历节点树（全能用）</h2><ul><li>parentNode :父节点（最顶端为#document(代表整个文档));</li><li>==childNodes== :子节点们</li><li>firstChild :第一个子节点</li><li>lastChild :最后一个子节点</li><li>nextSibling :后一个兄弟节点</li><li>previousSibling :前一个兄弟节点</li></ul><h3 id="节点的四个属性"><a href="#节点的四个属性" class="headerlink" title="节点的四个属性"></a>节点的四个属性</h3><ul><li>nodeName :元素的标签名，以大写形式表示，只读</li><li>nodeValue ：Text 节点或 Comment 节点的文本内容，可读写</li><li>==nodeTypez== ：该节点的类型，只读（最有用）</li><li>attributes ：Element 节点的属性集合</li></ul><h3 id="节点的一个方法："><a href="#节点的一个方法：" class="headerlink" title="节点的一个方法："></a>节点的一个方法：</h3><ul><li>Node.==hasChildNode==s();是否含有子节点 //true 或者 false</li></ul><h2 id="遍历元素节点树（大部分-IE9-以下不能用）"><a href="#遍历元素节点树（大部分-IE9-以下不能用）" class="headerlink" title="遍历元素节点树（大部分 IE9 以下不能用）"></a>遍历元素节点树（大部分 IE9 以下不能用）</h2><ul><li>parentElement :父元素节点</li><li>==children== :元素子节点// .length–&gt;元素子节点个数 （浏览器通用）</li><li>firstElementChild :第一个元素子节点</li><li>lastElementChild :最后一个元素子节点</li><li>nextElementSibling:后一个兄弟元素节点</li><li>previousElementSibling :前一个兄弟元素节点</li></ul><h3 id="元素节点的一些属性方法"><a href="#元素节点的一些属性方法" class="headerlink" title="元素节点的一些属性方法"></a>元素节点的一些属性方法</h3><ul><li>innerHTML：能获得这个元素里面的 html 内容，直接覆盖<ul><li>div.innerHTML += “123” ,可以追加内容</li></ul></li><li>innerText：能获得元素里面的文本内容，也可以赋值(需小心)<ul><li>老火狐不支持此方法：textContent –&gt;和 innerText 一样</li></ul></li><li>==setAttribute==(‘class’,’demo’); :给元素设置属性,（属性名，属性值）<ul><li>注意:可以设置没有的属性，如：index</li></ul></li><li>==getAttribute==(‘class’);获取元素的属性值</li><li>==dataset.myAge==;读写 data 属性值（此处为 data-my-age）</li><li>==cloneNode()==：克隆一个元素，div.cloneNode(true);填 ture 克隆子元素，否则只克隆自己。</li></ul><h1 id="DOM-继承树及基本操作"><a href="#DOM-继承树及基本操作" class="headerlink" title="DOM 继承树及基本操作"></a>DOM 继承树及基本操作</h1><h2 id="DOM-结构树"><a href="#DOM-结构树" class="headerlink" title="DOM 结构树"></a>DOM 结构树</h2><pre><code>+Node    -Document（文档）            -HTMLDocument    -CharacterData            -Text（文本）            -Comment（注释）    -Element（文档中的元素）            -HTMLElement                    -HTMLHeadElement                    -HTMLBodyElement                    -HTMLTitleElement                    -HTMLParagraphElement                    -HTMLInputElement                    -HTMLTableElement                    -...    -Attr注意：此树是一系列继承关系。是原型链的继承关系。1.document --&gt;HTMLDocument.prototype  --&gt; Document2.比如在HTMLBodyElement.prototype上加属性，那么body元素就会有这个属性。</code></pre><h2 id="dom-结构树的应用"><a href="#dom-结构树的应用" class="headerlink" title="dom 结构树的应用"></a>dom 结构树的应用</h2><ol><li><p>getElementById 方法定义在 Document.prototype 上，即 Element 节点上不能使用</p></li><li><p>getElementByName 方法定义在 HTMLDocument.prototype 上，即非 heml 中的 document 不能使用(xml document,Element)</p></li><li><p>getElementByTagName 方法定义在 Document.prototype 和 Element.prototype 上</p></li><li><p>HTMLDocument.prototype 定义了一些常用的属性，body,head 分别代指 HTML 文档中的<body><head>标签。</p><ul><li>document.body</li><li>document.head</li></ul></li><li><p>Document.prototype 上定义了 documentElement 属性，代指文档的根元素，在 HTML 文档中，他总是代指<html>元素</p><ul><li>document.documentElement –&gt; html 文档(document)</li></ul></li><li><p>getElementsByClassName、querySelectorAll、querySelector 在 Document.prototype,Element.prototype 类中均有定义</p></li></ol><h1 id="DOM-基本操作"><a href="#DOM-基本操作" class="headerlink" title="DOM 基本操作"></a>DOM 基本操作</h1><h2 id="添加元素节点"><a href="#添加元素节点" class="headerlink" title="*添加元素节点"></a>*添加元素节点</h2><ul><li>==document.createElement();== 创建元素节点</li><li>document.createTextNode(); 创建文本节点</li><li>document.createComment(); 创建注释节点</li><li>document.createDocumentFragment(); 创建文档碎片节点（最后学）</li></ul><h2 id="插入元素"><a href="#插入元素" class="headerlink" title="*插入元素"></a>*插入元素</h2><ul><li>.==appendChild==(); （当插入已有元素时，实现的是剪切操作）</li><li>div.==insertBefore==(a,b); 由父级元素调用<ul><li>读： div insert a Before b</li><li>将 a 插入到 div 下，b 之前</li></ul></li></ul><h2 id="删除节点"><a href="#删除节点" class="headerlink" title="*删除节点"></a>*删除节点</h2><ul><li>parent.removeChild(); 父节点删除子节点</li><li>child.==remove==(); 节点自己删除</li></ul><h2 id="替换"><a href="#替换" class="headerlink" title="*替换"></a>*替换</h2><ul><li>div.replaceChild(new, origin); //新元素替换老元素,由父级元素调用</li></ul><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">查找操作：</span><br><span class="line">练习1： 遍历元素节点树</span><br><span class="line">   var i &#x3D; document.getElementsByTagName(&#39;i&#39;)[0];</span><br><span class="line">   Element.prototype.jiedian &#x3D; function() &#123;</span><br><span class="line">       if (this.children) &#123;</span><br><span class="line">           var ele &#x3D; this.children;</span><br><span class="line">           for (var i &#x3D; 0; i &lt; ele.length; i++) &#123;</span><br><span class="line">               console.log(ele[i]);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           var ele &#x3D; this.childNodes;</span><br><span class="line">           for (var i &#x3D; 0; i &lt; ele.length; i++) &#123;</span><br><span class="line">               if (ele[i].nodeType &#x3D;&#x3D; 1)</span><br><span class="line">                   console.log(ele[i]);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> 练习2：封装函数，返回元素e的第n层祖先元素节点</span><br><span class="line">   function zuxian(ele, n) &#123;</span><br><span class="line">       while (ele.parentElement &amp;&amp; n) &#123;</span><br><span class="line">           ele &#x3D; ele.parentElement;</span><br><span class="line">           n--;</span><br><span class="line">       &#125;</span><br><span class="line">       console.log(ele);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   练习3：封装函数，返回元素e的第n个兄弟节点</span><br><span class="line">    function xiongdi(ele, n) &#123;</span><br><span class="line">       while (ele &amp;&amp; n) &#123;</span><br><span class="line">           if (n &gt; 0) &#123;</span><br><span class="line">               if (ele.previousElementSibling) &#123;</span><br><span class="line">                   ele &#x3D; ele.previousElementSibling;</span><br><span class="line">               &#125; else &#123;</span><br><span class="line">                   ele &#x3D; ele.previousSibling;</span><br><span class="line">                   while (ele &amp;&amp; ele.nodeType !&#x3D; 1) &#123;</span><br><span class="line">                       ele &#x3D; ele.previousSibling;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               n--;</span><br><span class="line">           &#125; else if (n &lt; 0) &#123;</span><br><span class="line">               if (ele.nextElementSibling) &#123;</span><br><span class="line">                   ele &#x3D; ele.nextElementSibling;</span><br><span class="line">               &#125; else &#123;</span><br><span class="line">                   ele &#x3D; ele.nextSibling;</span><br><span class="line">                   while (ele &amp;&amp; ele.nodeType !&#x3D; 1) &#123;</span><br><span class="line">                       ele &#x3D; ele.nextSibling;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               n++;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       console.log(ele);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="获取窗口属性，DOM-尺寸"><a href="#获取窗口属性，DOM-尺寸" class="headerlink" title="获取窗口属性，DOM 尺寸"></a>获取窗口属性，DOM 尺寸</h1><p><img src="http://47.97.6.61/%E6%9C%89%E9%81%93%E4%BA%91%E5%9B%BE%E7%89%87/%E5%90%84%E7%A7%8D%E8%B7%9D%E7%A6%BB.png" alt="各种距离"></p><h2 id="1-查看滚动条的滚动距离（px"><a href="#1-查看滚动条的滚动距离（px" class="headerlink" title="1.查看滚动条的滚动距离（px)"></a>1.查看滚动条的滚动距离（px)</h2><ul><li>==windows.pageXOffset/pageYOffset== //ie9 以下不兼容<br><br>//ie8 及以下使用</li><li>docmuent.body.scrollLeft</li><li>Top+docmuent.documentElement.scrollLeft/Top</li><li>(上面兼容性比较乱）封装一个查看滚动条距离的方法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function getScrollOffset() &#123;</span><br><span class="line">    if (window.pageXOffset) &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            x: window.pageXOffset,</span><br><span class="line">            y: window.pageYOffset</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            x: docmuent.body.scrollLeft +</span><br><span class="line">            docmuent.documentElement.scrollLeft,</span><br><span class="line">            y: docmuent.body.scrollTop +</span><br><span class="line">            docmuent.documentElement.scrollTop</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-查看视口的尺寸"><a href="#2-查看视口的尺寸" class="headerlink" title="2.查看视口的尺寸"></a>2.查看视口的尺寸</h2><ul><li>Window.innerWidth/innerHeight //ie9 以下不兼容</li><li>document.documentElement.clientWidth/clientHeight//标准模式下任何浏览器都兼容</li><li>document.body.clientWidth/clientHeight //适用于怪异模式下的浏览器</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;启动怪异模式</span><br><span class="line">&lt;!DOCTYPE html&gt;这行删除</span><br><span class="line">+ 封装查看视口尺寸的方法</span><br><span class="line">    function getViewprotOffset() &#123;</span><br><span class="line">        if (window.innerWidth) &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                w: window.innerWidth,</span><br><span class="line">                h: window.innerHeight</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (document.compatMode &#x3D;&#x3D; &quot;BackCompat&quot;) &#123;</span><br><span class="line">                return &#123;</span><br><span class="line">                    w: document.body.clientWidth,</span><br><span class="line">                    h: document.body.clientHeight,</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return &#123;</span><br><span class="line">                    w: document.documentElement.clientWidth,</span><br><span class="line">                    h: document.documentElement.clientHeight</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="3-查看元素的几何尺寸"><a href="#3-查看元素的几何尺寸" class="headerlink" title="3.查看元素的几何尺寸"></a>3.查看元素的几何尺寸</h2><pre><code>+ domEle.getBoundingClientRect();    - 可以返回一个元素的多个属性包括：长宽、距离可视区的宽高等    - 结果不是实时的    - 老版本Ie没有width和height属性</code></pre><h2 id="4-查看元素尺寸-常用"><a href="#4-查看元素尺寸-常用" class="headerlink" title="4.==查看元素尺寸== (常用)"></a>4.==查看元素尺寸== (常用)</h2><ul><li>dom.==offsetWidth== ：查看元素宽</li><li>dom.==offsetHeight== ：查看元素高</li></ul><h2 id="5-查看元素位置"><a href="#5-查看元素位置" class="headerlink" title="5.==查看元素位置=="></a>5.==查看元素位置==</h2><pre><code>+ dom.offsetLeft/Top    //返回元素距离，无视margin    - 对于无定位父级的元素，返回相对文档的坐标，反之返回相对父级元素的坐标+ dom.offsetParent          //返回最近有定位的父级，若无，返回body</code></pre><h2 id="6-让滚动条滚动"><a href="#6-让滚动条滚动" class="headerlink" title="6.==让滚动条滚动=="></a>6.==让滚动条滚动==</h2><pre><code>+ window.srollTO(x,y)   滚动条滚动到（x,y)处          和sroll()相同+ window.srollBy(x,y)   滚动条要滚动的距离</code></pre><h2 id="判断元素正好运动到浏览器底部"><a href="#判断元素正好运动到浏览器底部" class="headerlink" title="判断元素正好运动到浏览器底部"></a>判断元素正好运动到浏览器底部</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div.offsetTop &#x3D;&#x3D; document.documentElement.clientHeight - div.clientHeight</span><br></pre></td></tr></table></figure><h1 id="脚本化-CSS"><a href="#脚本化-CSS" class="headerlink" title="脚本化 CSS"></a>脚本化 CSS</h1><h2 id="读写元素-css-属性"><a href="#读写元素-css-属性" class="headerlink" title="读写元素 css 属性"></a>读写元素 css 属性</h2><ul><li>dom.style.*** //可读写行间样式，没有兼容性问题。像 float 这样的关键字前面加 css：cssFloat</li></ul><h2 id="className-相关："><a href="#className-相关：" class="headerlink" title="className 相关："></a>className 相关：</h2><ul><li>dom.classList.add(‘xxx’);//添加 class</li><li>classList.remove(class);//删除一个或多个 className</li><li>classList.contains(class);//判断是否存在此 class</li></ul><h2 id="查询元素样式"><a href="#查询元素样式" class="headerlink" title="查询元素样式"></a>查询元素样式</h2><ul><li>window.==getComputedStyle==(div,null); //获取元素显示样式<ul><li>此方法只读，不可写入</li><li>IE9 以下不兼容</li><li>window.getComputedStyle(div,”after”); //可以获取伪元素 style 属性，唯一方法<ul><li>不可以更改伪类的属性，但可以通过更改父元素的 class，实现之前 css 里面已经定义好的属性</li></ul></li></ul></li><li>div.==currentStyle== //和上个方法作用相同：IE 独有</li><li>封装一个查看 Style 属性的方法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;封装一个查看元素属性的方法：传入元素和要查看的属性</span><br><span class="line">    function getStyle(elem, prop) &#123;</span><br><span class="line">        if (window.getComputedStyle) &#123;</span><br><span class="line">            return window.getComputedStyle(elem, null)[prop];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return elem.currentStyle[prop];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="更改-css-最好的方法："><a href="#更改-css-最好的方法：" class="headerlink" title="更改 css 最好的方法："></a>更改 css 最好的方法：</h2><p>提前在 css 里面定义好 class，然后直接改 class 效率比直接改要高</p><h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><h2 id="绑定事件"><a href="#绑定事件" class="headerlink" title="绑定事件"></a>绑定事件</h2><ul><li>div.onclick = function(){}<ul><li>兼容性很好，但是同一元素的同一事件上只能绑定一个函数</li><li>基本等同于写在 HTML 行间上</li><li>this 指向本身</li></ul></li><li>div.addEventListener(type,fn,false);<ul><li>(‘事件类型’,处理函数,false)</li><li>处理函数可以直接写函数名 ：(‘click’,text(),false)</li><li>可以给元素绑定多个处理函数</li><li>同一函数绑定多次只执行一次</li><li>this 指向本身</li><li>ie9 以下不兼容</li></ul></li><li>div.attachEvent(‘onclick’,function(){});<ul><li>ie 独有</li><li>同一函数绑定几次执行几次</li><li>this 指向 window</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;当循环添加事件时会形成闭包，若需要用到i，则需要使用立即执行函数来实现</span><br><span class="line">  for (var i &#x3D; 0; i &lt; li.length; i++) &#123;</span><br><span class="line">        (function(i) &#123;</span><br><span class="line">            li[i].addEventListener(&#39;click&#39;, function() &#123;</span><br><span class="line">                console.log(i)</span><br><span class="line">            &#125;, false);</span><br><span class="line">        &#125;(i))</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>封装一个添加事件方法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function addEvent(elem, type, handle) &#123;</span><br><span class="line">    if (elem.addEventListener) &#123;</span><br><span class="line">        elem.addEventListener(type, handle, false);</span><br><span class="line">    &#125; else if (elem.attachEvent) &#123;</span><br><span class="line">        elem.attachEvent(&#39;on&#39; + type, function() &#123;</span><br><span class="line">            &#x2F;&#x2F; 此方法的this指向的是window，所以用call方法更改this为call</span><br><span class="line">            handle.call(elem);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F;elem.onclick &#x3D; function()&#123;&#125;;</span><br><span class="line">        elem[&#39;on&#39; + type] &#x3D; handle;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解除事件"><a href="#解除事件" class="headerlink" title="解除事件"></a>解除事件</h2><ul><li>div.onclick = null;</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;只能执行一次的事件</span><br><span class="line">div.onclick &#x3D; function()&#123;... this.onclick &#x3D; null;&#125;</span><br></pre></td></tr></table></figure><ul><li>div.removeEventListener(type,fn,false);</li><li>div.datachEvent(‘on’+type,fn);</li></ul><h1 id="事件处理模型（事件冒牌、事件捕获）"><a href="#事件处理模型（事件冒牌、事件捕获）" class="headerlink" title="事件处理模型（事件冒牌、事件捕获）"></a>事件处理模型（事件冒牌、事件捕获）</h1><h2 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h2><p>==结构上（非视觉上）嵌套关系的元素，会存在事件冒泡的功能，即同一事件，自子元素冒泡到父元素。（自底向上）==</p><pre><code>块嵌套绿块嵌套蓝块，点击最小的蓝块，会依次执行父元素的点击事件    -&gt;蓝-绿-红</code></pre><h2 id="事件捕获（和事件冒泡相反）"><a href="#事件捕获（和事件冒泡相反）" class="headerlink" title="事件捕获（和事件冒泡相反）"></a>事件捕获（和事件冒泡相反）</h2><p>==结构上（非视觉上）嵌套关系的元素，会存在事件捕获的功能，即同一事件，自父元素捕获至子元素（事件源元素）。（自顶向下）==</p><pre><code>+ 目前只有Google Chrome实现了此功能+ 即 红-绿-蓝 ：红和绿都是事件捕获，蓝是事件执行+ div.addEventListener(type,fn,true);+ ie没有事件捕获</code></pre><h2 id="关于捕获和冒泡"><a href="#关于捕获和冒泡" class="headerlink" title="关于捕获和冒泡"></a>关于捕获和冒泡</h2><p>==一个对象的一个事件类型，只能存在一个事件处理模型<br><br>触发顺序： 先捕获，再执行，再冒泡<br><br>注意：所点击的对象是执行，不存在捕获和冒牌<br><br>详解：事件冒泡是默认就有的，除非取消不然都会有冒泡。<br><br>事件捕获是父级元素来设置的，当父级元素设置了事件捕获后，就会捕获子元素的事件<br><br>若父元素既想在捕获时触发也想在冒泡时触发，则需要创建两个事件。<br><br>再来解读一下第一句，当设置事件捕获时，事件在捕获阶段触发。冒泡阶段不再触发此事件。反之，则只在冒泡阶段触发==</p><h5 id="focus-blur-change-submit-reset-select-等事件不冒泡"><a href="#focus-blur-change-submit-reset-select-等事件不冒泡" class="headerlink" title="focus,blur,change,submit,reset,select 等事件不冒泡"></a>focus,blur,change,submit,reset,select 等事件不冒泡</h5><h2 id="取消冒泡（需要事件对象-e）"><a href="#取消冒泡（需要事件对象-e）" class="headerlink" title="取消冒泡（需要事件对象 e）"></a>取消冒泡（需要事件对象 e）</h2><pre><code>+ e.stopPropagation();    - ie9以下不支持+ e.cancelBubble = true;    - ie独有，Chrome支持//封装一个取消冒泡函数function stopBubble(e)&#123;    if(e.stopPropagation()&#123;        e.stopPropagation();    &#125;else&#123;        e.cancelBubble=true;    &#125;&#125;</code></pre><h2 id="清除默认事件"><a href="#清除默认事件" class="headerlink" title="清除默认事件"></a>清除默认事件</h2><p>默认事件：表单提交，a 标签跳转，右键菜单等等</p><ol><li>return false; 句柄的方式阻止事件。</li><li>e.preventDefault()： W3C 标注，IE9 以下不兼容</li><li>e.returnValue = false; 兼容 IE9 以下,用法和 preventDefault()相同</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;阻止右键出菜单事件</span><br><span class="line">document.oncontextmenu &#x3D; function(e)&#123;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> 封装阻止默认事件函数</span><br><span class="line">function cancelHandler(e) &#123;</span><br><span class="line">    if (e.preventDefault) &#123;</span><br><span class="line">        e.preventDefault();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        e.returnValue &#x3D; false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>协议限定符:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">取消默认事件还有一种高端写法：</span><br><span class="line">&lt;a href&#x3D;&quot;javascript:void()&quot;&gt;demo&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure><h2 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h2><p>在每个事件处理函数中我们可以写一个形参。系统会帮我们传一个事件对象。记载着事件发生时的一系列信息。</p><ul><li>event || window.event 用于 IE</li></ul><h2 id="事件源对象（哪个-DOM-元素触发了该事件）"><a href="#事件源对象（哪个-DOM-元素触发了该事件）" class="headerlink" title="事件源对象（哪个 DOM 元素触发了该事件）"></a>事件源对象（哪个 DOM 元素触发了该事件）</h2><pre><code>+ event.target  火狐只有这个+ event.srcElement  ie只有这个+ Chrome这俩都有div.onclick = function(e)&#123;    &lt;!--ie浏览器上不会把事件对象传给e，而是传给window.event。    若用到时，需做以下兼容--&gt;    var event = e || window.event;    &lt;!--获取事件源对象，此处为做兼容--&gt;    var target = event.target || event.srcElement;&#125;</code></pre><h2 id="小知识点："><a href="#小知识点：" class="headerlink" title="小知识点："></a>小知识点：</h2><pre><code>获取元素标签名：e.currentTarget/this.tagName/e.target.tagNamea标签点击时不是刷新页面就是跳到最顶上。可以通过取消默认事件。a.onclick=function(e)&#123;    return  false;&#125;</code></pre><h2 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h2><ul><li>利用事件冒泡，和事件源对象进行处理<ul><li>优点 ：<ul><li>高性能，不需要循环所有元素一个个绑定事件</li><li>灵活，当有新的子元素时不需要重新绑定事件</li></ul></li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">利用事件源对象来事件点击li返回li里面的文本，高效率</span><br><span class="line">var ul &#x3D; document.getElementsByTagName(&#39;ul&#39;)[0];</span><br><span class="line">ul.onclick &#x3D; function(e) &#123;</span><br><span class="line">    &#x2F;&#x2F; ie浏览器上不会把事件对象传给e，而是传给window.event。若用到时，需做以下兼容</span><br><span class="line">    var event &#x3D; e || window.event;</span><br><span class="line">    &#x2F;&#x2F; 获取事件源对象，此处为做兼容</span><br><span class="line">    var target &#x3D; event.target || event.srcElement;</span><br><span class="line">    console.log(target.innerText);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="事件分类"><a href="#事件分类" class="headerlink" title="事件分类"></a>事件分类</h1><h2 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h2><ul><li>click 点击</li><li>dblclick：用户双击主鼠标按键触发（频率取决于系统配置）</li><li>mousedown 按下</li><li>mouseup 松开</li><li>contextmenu 右键产生菜单</li><li>mousemove：鼠标在元素上移动时触发</li><li>mouseover：鼠标进入元素时触发</li><li>mouseout：鼠标离开元素时触发</li><li>mouseenter 鼠标移至某元素之上(事件不会冒泡)</li><li>mouseleave 鼠标从某元素移开(事件不会冒泡)</li><li>touchstar/touchmove/touchend 移动端–&gt;<br>mousedown/move/up</li></ul><p>区别：</p><ul><li>over 和 out，不考虑子元素，从父元素移动到子元素，对于父元素而言，仍然算作离开。每次移动到新的子元素，都会重新触发父元素事件。</li><li>enter 和 leave，考虑子元素，子元素仍然是父元素的一部分。只要在在父元素中，不会多次触发父元素事件。</li><li>mouseenter 和 mouseleave 不会冒泡。<br><br>若父子元素的事件都是改变背景颜色<br><br>over 事件，子元素触发时会触发父级元素，子元素会获取到父元素的背景色，因为这里事件冒泡了。<br>enter 事件，子元素触发时，父元素改变自己的颜色，子元素改变自己的颜色，因为事件不冒泡。</li></ul><h2 id="获取鼠标距离-位置："><a href="#获取鼠标距离-位置：" class="headerlink" title="获取鼠标距离/位置："></a>获取鼠标距离/位置：</h2><ul><li>page：pageX、pageY，当前鼠标距离页面的横纵坐标</li><li>client: clientX、clientY，鼠标相对于视口的坐标</li><li>offset：offsetX、offsetY，鼠标相对于事件源的内边距的坐标</li><li>screen: screenX、screenY，鼠标相对于屏幕</li><li>x、y，等同于 clientX、clientY</li><li>movement：movementX、movementY，只在鼠标移动事件中有效，相对于上一次鼠标位置，偏移的距离</li></ul><ul><li>注意点</li></ul><ol><li>点击事件执行时：mousedown -&gt; mouseup -&gt;click</li><li>contextmenu 就是右键出菜单事件，他能用到的就是右键取消菜单。</li><li>用 e.button 属性 来区分鼠标的按键。 左：0 右：2 滚轮：1<ul><li>DOM3 标准规定 click 事件只能监听左键，</li><li>只能通过 mousedown 和 mouseup 来判断鼠标键。</li></ul></li><li>如何解决 mousedown 和 click 的冲突 ？<br>利用时间差解决，click 点击快，可在 mousedown 时加时间判断，大于 300 毫秒时解除 click 事件</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">    练习1：拖拽练习</span><br><span class="line">        document.onmousedown &#x3D; function(e) &#123;</span><br><span class="line">    if (e.target&#x3D;&#x3D;xxx) &#123;</span><br><span class="line">        var div &#x3D; e.target || event.srcElement;</span><br><span class="line">        &#x2F;&#x2F; 获取鼠标距离元素边框的距离</span><br><span class="line">        var disX &#x3D; e.offsetX;</span><br><span class="line">        var disY &#x3D; e.offsetY;</span><br><span class="line">        document.onmousemove &#x3D; function(e) &#123;</span><br><span class="line">            &#x2F;&#x2F;鼠标到文档边框的距离-鼠标到元素边框的距离</span><br><span class="line">            var Left &#x3D; e.pageX - disX;</span><br><span class="line">            var Top &#x3D; e.pageY - disY;</span><br><span class="line">            div.style.left &#x3D; Left + &#39;px&#39;;</span><br><span class="line">            div.style.top &#x3D; Top + &#39;px&#39;;</span><br><span class="line">            div.style.zIndex &#x3D; index++;</span><br><span class="line">        &#125;</span><br><span class="line">        document.onmouseup &#x3D; function() &#123;</span><br><span class="line">            document.onmousemove &#x3D; null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    练习2：用button区分左右键</span><br><span class="line">     document.onmousedown &#x3D; function(e)&#123;</span><br><span class="line">        if(e.button &#x3D;&#x3D; 0 )&#123;</span><br><span class="line">            console.log(&#39;left&#39;);</span><br><span class="line">        &#125;else if(e.button &#x3D;&#x3D; 2)&#123;</span><br><span class="line">            console.log(&#39;rigth&#39;);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">        console.log(&#39;center&#39;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h2><ul><li>keydown 按下</li><li>keyup 松开</li><li>keypress 点击</li></ul><p>==注意==：keydown -&gt; keypress -&gt; keyup</p><h3 id="获取点击的按键"><a href="#获取点击的按键" class="headerlink" title="获取点击的按键"></a>获取点击的按键</h3><ul><li>code：得到按键字符串，适配键盘布局</li><li>key：得到按键字符串，不适配键盘布局，能得到打印字符(推荐)</li><li>keyCode、which：得到键盘编码(不推荐)</li></ul><h3 id="keydown-和-keypress-的区别"><a href="#keydown-和-keypress-的区别" class="headerlink" title="keydown 和 keypress 的区别"></a>keydown 和 keypress 的区别</h3><ul><li>keydown 可以响应任意的键盘按键，keypress 只可以响应字符类键盘按键</li><li>keypress 可以返回 ASCII 码，转换成相应字符</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;可以打印键盘的字符</span><br><span class="line">document.onkeypress &#x3D; function(e)&#123;</span><br><span class="line">    console.log(String.fromCharCode(e.charCode));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="input-文本框操作事件"><a href="#input-文本框操作事件" class="headerlink" title="input 文本框操作事件"></a>input 文本框操作事件</h2><ul><li>input 但凡文本有变化，都会触发这个事件</li><li>change 若鼠标获取焦点时的内容和失去焦点时的内容不一样，触发事件</li><li>focus 获取焦点时，触发事件</li><li>blur 失去焦点时，触发事件</li><li>一般文本框使用</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;可以用className来优化性能</span><br><span class="line">    &lt;input type&#x3D;&quot;text&quot; value&#x3D;&quot;请输入用户名&quot;</span><br><span class="line">    style&#x3D;&quot;color:#999&quot; onfocus&#x3D;&quot;if(this.value &#x3D;&#x3D; &#39;请输入用户名&#39;)&#123;</span><br><span class="line">    this.value &#x3D; &#39;&#39;;this.style.color&#x3D;&#39;#424242&#39;&#125;&quot;</span><br><span class="line">    onblur&#x3D;&quot;if(this.value &#x3D;&#x3D; &#39;&#39;)&#123;</span><br><span class="line">        this.value &#x3D;&#39;请输入用户名&#39;;this.style.color&#x3D;&#39;#999&#39;&#125;&quot;&gt;</span><br></pre></td></tr></table></figure><h2 id="窗口操作类（window-上的事件）"><a href="#窗口操作类（window-上的事件）" class="headerlink" title="窗口操作类（window 上的事件）"></a>窗口操作类（window 上的事件）</h2><ul><li>scroll 滚动条滚动，事件触发</li><li>load 当整个页面都加载完毕，才执行里面的事件</li><li>resize 浏览器窗口大小改变触发</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;滚动条滚动触发显示滚动条位置</span><br><span class="line">    window.onscroll &#x3D; function() &#123;</span><br><span class="line">        console.log(window.pageYOffset);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 前端 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript（一） ECMAScript</title>
      <link href="2020/09/30/JavaScript%EF%BC%88%E4%B8%80%EF%BC%89ECMAScript/"/>
      <url>2020/09/30/JavaScript%EF%BC%88%E4%B8%80%EF%BC%89ECMAScript/</url>
      
        <content type="html"><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h2><ul><li><p>原始值：</p><ul><li>Number String Boolean undefined null</li><li>copy 的是值<a id="more"></a></li></ul></li><li><p>引用值：<br>array Object function date RegExp …</p><ul><li><p>copy 的是地址</p><ul><li>原始值（基本数据类型）<ul><li>number<ul><li>NaN(not a number)</li><li>isNaN</li><li>parseInt(Float)</li></ul></li><li>string</li><li>boolean</li><li>null</li><li>undefined</li></ul></li><li>引用值（引用数据类型）<ul><li>对象类型<ul><li>object 对象数据类型-普通对象 格式：let person={key:value}<ul><li>查询<ul><li>person.key</li><li>person[‘key’]</li></ul></li><li>新增修改<ul><li>person.newkey=’value’</li></ul></li><li>删除<ul><li>真删除：属性删除</li><li>delete person.key;</li></ul></li><li>假删除：内容删除<ul><li>person.key = null;</li></ul></li></ul></li><li>数组-特殊对象<ul><li>var arr=[12,’haha’,true,13];</li><li>查询<ul><li>arr.length</li><li>arr[‘length’];</li><li>arr[0]</li><li>新增<ul><li>arr[ary.length]=100 //末尾追加内容</li></ul></li></ul></li></ul></li><li>正则对象</li></ul></li></ul></li><li>Symbol:唯一值</li></ul></li></ul></li></ul><p><strong>小知识：为什么 null 是 object 类型?</strong></p><p>不同的对象在底层原理的存储是用二进制表示的，在 javaScript 中，如果二进制的前三位都为 0 的话，系统会判定为是 Object 类型。null 的存储二进制是 000，也是前三位，所以系统判定 null 为 Object 类型。</p><p><strong>原始值和引用值的区别？</strong></p><ol><li>原始值按值操作，引用值操作的是堆内存的空间地址</li><li>原始值存储地址为栈，引用值存储地址为堆</li><li>原始值不能有属性和方法，引用值可以有</li></ol><h2 id="堆栈内存（stack-amp-heap"><a href="#堆栈内存（stack-amp-heap" class="headerlink" title="堆栈内存（stack&amp;heap)"></a>堆栈内存（stack&amp;heap)</h2><p><strong>栈</strong>：先进后出，赋值是 copy，存原始值和引用值的地址。<br><br><strong>堆</strong>：赋值是引用，存引用值的数据。</p><h2 id="转换为-Boolean-类型为-false-的数据"><a href="#转换为-Boolean-类型为-false-的数据" class="headerlink" title="转换为 Boolean 类型为 false 的数据"></a>转换为 Boolean 类型为 false 的数据</h2><pre><code>undefinednull0falseNaN&#39;&#39;（空字符串）</code></pre><h2 id="amp-amp-and"><a href="#amp-amp-and" class="headerlink" title="&amp;&amp; and ||"></a>&amp;&amp; and ||</h2><p><strong>&amp;&amp;:</strong></p><ul><li>先把表达式的值转化为布尔值，再进行判断<br></li><li>如果第一个表达式为真，返回第二个表达式的值。</li><li>如果第一个表达式的值为假，直接返回第一个表达式的值。</li></ul><p><strong>小知识</strong>：if(a&gt;b){alert(xxx)} == a&gt;b&amp;&amp;alert(xxx)</p><p><strong>||:</strong></p><ul><li>如果有多个值，会一个一个判断，若都为假，返回最后一个值。</li><li>判断到哪个值为真，返回此值，后面不再看。</li></ul><h2 id="typeof-操作符"><a href="#typeof-操作符" class="headerlink" title="typeof 操作符"></a>typeof 操作符</h2><p><strong>可区分 6 种数据类型：</strong></p><p>number（数字）、string（字符串）、boolean（true 和 false）、 undefined（undefined）、 object（数组和对象和 null）、 function（函数）</p><p>==<strong>注意</strong>==</p><p>==1. typeof()返回的值为字符串类型。 2. 若传入未定义变量会返回 undefined，平时直接使用会报错。&lt;br》<br>补充：window 的未定义变量直接调用=》window.foo=undefined;==</p><h2 id="显示类型转换"><a href="#显示类型转换" class="headerlink" title="显示类型转换"></a>显示类型转换</h2><p><strong>转换类型：</strong></p><p>Number、String、Boolean、parseInt、parseFloat、toString、toFixed</p><h3 id="parseInt-详解"><a href="#parseInt-详解" class="headerlink" title="parseInt 详解"></a>parseInt 详解</h3><p><strong>作用一</strong>：把数字转化为整形。<br><br>具体使用：<br></p><ol><li>数字：把数字点数点后面的砍掉。</li><li>字符串（数字开头，无视空格）：从开头往后看，到非数字位停止。然后转换成数字。</li><li>其他值：返回 NAN <br></li></ol><p><strong>作用二</strong>：进制转换<br><br>具体使用：<br></p><ul><li>parseInt(num,x):第一个参数是传入的数字，第二个参数是基底（radix)</li><li>把 num 作为 x 进制的数字，然后转换为 10 进制。</li><li>基底的取值范围是 2-36</li></ul><h3 id="toFixed-详解"><a href="#toFixed-详解" class="headerlink" title="toFixed 详解"></a>toFixed 详解</h3><p>具体使用：<br></p><ul><li>1.123.toFixed(1) == 1.1</li><li>保留小数点后有效数字位，四舍五入。</li></ul><h3 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h3><p>isNaN、++、–、+、-、*、/、%、&amp;&amp;、||、!、==、!=、&gt;、&lt;、&gt;=、&lt;=、===、!===</p><h3 id="运算符种类"><a href="#运算符种类" class="headerlink" title="运算符种类"></a>运算符种类</h3><pre><code>算数运算符  ：+、++、-、--、*、/、%字符串运算符：+、+=逻辑运算符：&amp;&amp;、||、！位运算符：&amp;、^、|、~、&lt;&lt;、&gt;&gt;、&gt;&gt;&gt;赋值运算符：=、+=、-=、*=、/=、%=、&amp;=、^=、|=、&lt;&lt;=、&gt;&gt;=、&lt;&lt;&lt;=比较运算符：==、!=、&gt;、&gt;=、&lt;、&lt;=特殊运算符：?:、，、delete、new、this、typeof、viod冷门知识：算数运算符&gt;比较运算符&amp;&amp; 大于 ||== 大于 &amp;&amp;++大于 == 大于 &amp;&amp; 大于 ||</code></pre><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><ul><li>定义变量方式<ul><li>let</li><li>var</li><li>const</li><li>function(){} //函数类型</li><li>import</li><li>class</li></ul></li><li>命名规范<ul><li>区分大小写</li><li>驼峰命名</li><li>关键字保留字</li></ul></li><li>运行和输出<ul><li>运行方式：浏览器或 NODE</li><li>输出方式<ul><li>console.log();</li><li>alert</li><li>confirm</li><li>prompt</li><li>dir</li><li>table</li></ul></li></ul></li><li>创建过程<ul><li>创建变量</li><li>创建数据</li><li>将两者关联</li></ul></li></ul><h1 id="函数-Function"><a href="#函数-Function" class="headerlink" title="函数 Function"></a>函数 Function</h1><ol><li>所有函数都具有 Function 中的实例成员</li><li>语法：arguments：在函数中使用，获取该函数调用时，传递的所有参数</li><li>arguments 是一个类数组（也称为伪数组：没有通过 Array 构造函数创建的类似于数组结构的对象），伪数组会缺少大量的数组实例方法</li><li>arguments 数组中的值，会与对应的形参映射</li></ol><h2 id="实例成员"><a href="#实例成员" class="headerlink" title="实例成员"></a>实例成员</h2><ul><li>length 属性，得到函数形参数量</li><li>apply 方法：调用函数，同时指定函数中的 this 指向，参数以数组传递</li><li>call 方法：调用函数，同时指定函数中的 this 指向，参数以列表传递</li><li>bind 方法：得到一个新函数，该函数中的 this 始终指向指定的值。</li></ul><p>通常，可以利用 apply、call 方法，将某个伪数组转换伪真数组。</p><h2 id="命名函数表达式（一般不用）"><a href="#命名函数表达式（一般不用）" class="headerlink" title="命名函数表达式（一般不用）"></a>命名函数表达式（一般不用）</h2><p>命名函数表达式的形式是这样的，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var test &#x3D; function abc()&#123;</span><br><span class="line">document.write(&#39;a&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>他会先定义一个变量，变量里边放入函数，这就是函数表达式。但是命名函数表达式 的变量名会替代函数名的作用，意思就是调用函数你必须 test()才可以，假如你 abc() 就会报错，这个 abc 就不起作用了，但是你输出 test.name 会得到 abc。</p><h2 id="匿名函数表达式"><a href="#匿名函数表达式" class="headerlink" title="匿名函数表达式"></a>匿名函数表达式</h2><p>既然函数表达式的函数名不起作用了，后来我们就省掉了，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var test &#x3D; function()&#123;</span><br><span class="line">document.write(&#39;a&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="立即执行函数（匿名函数之自执行函数）"><a href="#立即执行函数（匿名函数之自执行函数）" class="headerlink" title="立即执行函数（匿名函数之自执行函数）:"></a>立即执行函数（匿名函数之自执行函数）:</h2><p>创建一个函数立刻执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(function(n)&#123;...&#125;(100));</span><br></pre></td></tr></table></figure><p><strong>注意点</strong>：</p><ol><li>只有表达式才能被执行符号‘()’执行:text(),var text()=fn..(函数表达式)</li><li>能被执行符号执行的表达式，就成了立即执行函数，这个函数名字就被忽略。</li><li>==<strong>一旦形成函数表达式，就无法再通过函数名找到</strong>==</li><li>==在立即执行函数中，如果该函数有名字，则函数体内所有对这个名字的赋值等操作都无效/无视，且不会提升在 window 中==</li><li>==有函数名的立即执行函数中是可以访问到这个函数的，就像是 arguments.callee==</li></ol><h2 id="形参和实参"><a href="#形参和实参" class="headerlink" title="形参和实参"></a>形参和实参</h2><p>函数()里面的是形参，text(a)里面的 a 是实参。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var test &#x3D; function(a)&#123;</span><br><span class="line">document.write(&#39;a&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JS-不定参"><a href="#JS-不定参" class="headerlink" title="JS 不定参"></a>JS 不定参</h2><p>JavaScript 天生不定参，不是说在一个函数里有几个形参就必须有几个实参，不是这 样的，在 JS 里，形参比实参多，可以，实参比形参多，也行。</p><p>若形参比实参多，未传值的形参为 undefined<br>若实参比形参多，不影响函数，形参会存在 arguments 数组里。</p><h2 id="形参与-arguments-的映射规则"><a href="#形参与-arguments-的映射规则" class="headerlink" title="形参与 arguments 的映射规则"></a>形参与 arguments 的映射规则</h2><p>形参和 arguments 确实是一个变一个跟着变的，确实有这样的绑定规则，但是，他俩 不是同一个变量，系统内部有映射规则，就是这俩我变你也得变，但是他们是两个变量。</p><h2 id="return"><a href="#return" class="headerlink" title="return"></a>return</h2><ul><li>return 的第一个作用就是终止函数。</li><li>return 的第二点作用就是返回值。</li></ul><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>其实递归就是一种找规律和找出口的方法，他特别符合人的思维过程。</p><ol><li>找规律</li><li>找出口</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;n的阶乘</span><br><span class="line">function mul(n)&#123;</span><br><span class="line">    &#x2F;&#x2F;出口</span><br><span class="line">    if(n&#x3D;&#x3D;1||n&#x3D;&#x3D;0)&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    retutn n*mul(n-1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="imply-global-暗示全局变量："><a href="#imply-global-暗示全局变量：" class="headerlink" title="imply global 暗示全局变量："></a>imply global 暗示全局变量：</h2><p>即任何变量，如果变量未经声明就赋值，此变量就为全局变量所有。</p><h2 id="常用方法详解"><a href="#常用方法详解" class="headerlink" title="常用方法详解"></a>常用方法详解</h2><h3 id="toString-方法详解"><a href="#toString-方法详解" class="headerlink" title="toString()方法详解"></a>toString()方法详解</h3><p>toString()本应返回数据类型，为什么原始值会返回字符串？</p><ol><li>Number(123).toString –&gt;”123” ,是因为 Number.prototype 上重写了 Object 的 toString 方法</li><li>Number、Array、Boolean、String 的 prototype 都重写了 toString 方法。所以才能返回数字等等，否则返回[object Number]…</li><li>document.write(obj);,obj 默认调用 toString 方法。</li></ol><h3 id="call-amp-apply"><a href="#call-amp-apply" class="headerlink" title="call()&amp;apply()"></a>call()&amp;apply()</h3><p>功能：==更改 this 指向==<br><br>区别：==传参列表不同==<br><br>call：第二个参数开始依次传入需要的参数。<br><br>apply：第二个参数是一个数组，将所需参数放入数组中。</p><h4 id="call-详解"><a href="#call-详解" class="headerlink" title="call()详解"></a>call()详解</h4><ul><li>任何方法加.call()和不加效果相同。如：text() –&gt;text.call();</li><li>任何一个方法都可以.call(),call()的第一个参数就是 this 指向，后面的参数就是方法的实参。</li><li>通过 call()可以实现借用你的方法，实现我的功能。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">例1：</span><br><span class="line">function Person(name,age) &#123;</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">    this.age &#x3D; age;</span><br><span class="line">    &#125;</span><br><span class="line">var obj &#x3D; &#123;&#125;;</span><br><span class="line">&#x2F;&#x2F;此处就是借用Person方法，给obj进行赋值</span><br><span class="line">Person.call(obj,&#39;cheng&#39;,300);</span><br><span class="line"></span><br><span class="line">例2：(开发常用，注：Student方法必须完美涵盖Person方法 )</span><br><span class="line">function Person(name,age,sex) &#123;</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">    this.age &#x3D; age;</span><br><span class="line">    this.sex &#x3D; sex;</span><br><span class="line">&#125;</span><br><span class="line">function Student(name,age,sex,tel,grade) &#123;</span><br><span class="line">    Person.call(this,name,age,sex);</span><br><span class="line">    this.tel &#x3D; tel;</span><br><span class="line">    this.grade &#x3D; grade;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var student &#x3D; new Student(&#39;sunny&#39;,123,&#39;male&#39;,139,2017);</span><br><span class="line"></span><br><span class="line">例3：这是一辆车，车的各个组件在不同方法，然后制作时通过cail()来组成这辆车。</span><br><span class="line">function Wheel(wheelSize,style) &#123;</span><br><span class="line">    this.wheelSize &#x3D; wheelSize;</span><br><span class="line">    this.style &#x3D; style;</span><br><span class="line">&#125;</span><br><span class="line">function Sit(c,sitColor) &#123;</span><br><span class="line">    this.c &#x3D; c;</span><br><span class="line">    this.sitColor &#x3D; sitColor;</span><br><span class="line">&#125;</span><br><span class="line">function Model(height,width,len) &#123;</span><br><span class="line">    this.height &#x3D; height;</span><br><span class="line">    this.width &#x3D; width;</span><br><span class="line">    this.len &#x3D; len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Car(wheelSize,style,c,sitColor,height,width,len)&#123;</span><br><span class="line">    Wheel.call(this,wheelSize,style);</span><br><span class="line">    Sit.call(this,c,sitColor);</span><br><span class="line">    Model.call(this,height,width,len);</span><br><span class="line">&#125;</span><br><span class="line">var car &#x3D; new Car(100,&quot;花里胡哨的&quot;,&quot;真皮&quot;,&quot;red&quot;,1800,1900,4900);</span><br><span class="line"></span><br><span class="line"> 例4：</span><br><span class="line">&#x2F;&#x2F;获取数组中的最大值和最小值</span><br><span class="line">var  numbers &#x3D; [5, 458 , 120 , -215 ];</span><br><span class="line">var maxInNumbers &#x3D; Math.max.apply(Math, numbers),   &#x2F;&#x2F;458</span><br><span class="line">    maxInNumbers &#x3D; Math.max.call(Math,5, 458 , 120 , -215); &#x2F;&#x2F;458</span><br><span class="line">&#x2F;&#x2F;number 本身没有 max 方法，但是 Math 有，</span><br><span class="line">&#x2F;&#x2F;我们就可以借助 call 或者 apply 使用其方法。</span><br></pre></td></tr></table></figure><h4 id="apply-详解"><a href="#apply-详解" class="headerlink" title="apply()详解"></a>apply()详解</h4><p>本质和 cail()一样，但传参方法不同<br>apply(this,[…])</p><h1 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h1><h2 id="预编译前奏"><a href="#预编译前奏" class="headerlink" title="预编译前奏"></a>预编译前奏</h2><ol><li>函数声明整体提升</li><li>变量 声明提升（只声明提升，直接赋值不提升）</li></ol><h2 id="函数预编译"><a href="#函数预编译" class="headerlink" title="函数预编译"></a>函数预编译</h2><ol><li>创建 A0 对象 Activation Object</li><li>找形参和变量声明，将形参和变量声明作为 AO 属性名，值为 undefined</li><li>将实参值和形参统一</li><li>在函数体内找函数声明(把函数声明的名作为属性值加入 AO)，值赋予函数体</li><li>执行</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">function fn(a)&#123;</span><br><span class="line">    console.log(a);</span><br><span class="line">    var a&#x3D;123;</span><br><span class="line">    console.log(a);</span><br><span class="line">    function a()&#123;&#125;</span><br><span class="line">    console.log(a);</span><br><span class="line">    var b&#x3D;function()&#123;&#125;</span><br><span class="line">    console.log(b);</span><br><span class="line">    function d()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">fn(1);</span><br><span class="line">&#x2F;&#x2F;执行过程</span><br><span class="line">1.创建AO</span><br><span class="line">A0&#123;</span><br><span class="line">&#125;</span><br><span class="line">2.找实参和变量声明，作为AO属性名，值为undefined</span><br><span class="line">AO&#123;</span><br><span class="line">    a:undefined,</span><br><span class="line">    b:undefined</span><br><span class="line">&#125;</span><br><span class="line">3.将实参形参统一</span><br><span class="line">AO&#123;</span><br><span class="line">    a:1,</span><br><span class="line">    b:undefind</span><br><span class="line">&#125;</span><br><span class="line">4.找函数声明，将值赋予函数体</span><br><span class="line">AO&#123;</span><br><span class="line">    a:1,</span><br><span class="line">    b:undefined,</span><br><span class="line">    d:</span><br><span class="line">&#125;</span><br><span class="line">AO&#123;</span><br><span class="line">    a:function a()&#123;&#125;,</span><br><span class="line">    b:undefined,</span><br><span class="line">    d:function()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">5.执行</span><br><span class="line">打印 function a()&#123;&#125;</span><br><span class="line">a&#x3D;123</span><br><span class="line">打印 123</span><br><span class="line">打印 123</span><br><span class="line">b&#x3D;function()&#123;&#125;</span><br><span class="line">打印 function()&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="全局预编译"><a href="#全局预编译" class="headerlink" title="全局预编译"></a>全局预编译</h2><ol><li>创建 G0 对象 Global Object (window)</li><li>找形参和变量声明，将形参和变量声明作为 AO 属性名，值为 undefined</li><li>找函数声明(把函数声明的名作为属性值加入 AO)，值赋予函数体</li><li>执行</li></ol><h4 id="预编译练习题"><a href="#预编译练习题" class="headerlink" title="预编译练习题"></a>预编译练习题</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1.</span><br><span class="line">        function bar() &#123;</span><br><span class="line">            return foo;</span><br><span class="line">            foo &#x3D; 10;</span><br><span class="line"></span><br><span class="line">            function foo() &#123;&#125;</span><br><span class="line">            var foo &#x3D; 11;</span><br><span class="line">        &#125;</span><br><span class="line">        console.log(bar());</span><br><span class="line">2.</span><br><span class="line">        console.log(bar());</span><br><span class="line">        function bar() &#123;</span><br><span class="line">            foo &#x3D; 10;</span><br><span class="line"></span><br><span class="line">            function foo() &#123;&#125;</span><br><span class="line">            var foo &#x3D; 11;</span><br><span class="line">            return foo;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h1 id="作用域与作用域链"><a href="#作用域与作用域链" class="headerlink" title="作用域与作用域链"></a>作用域与作用域链</h1><h2 id="1-执行期上下文（就是我们之前讲的-AO）"><a href="#1-执行期上下文（就是我们之前讲的-AO）" class="headerlink" title="1.执行期上下文（就是我们之前讲的 AO）"></a>1.执行期上下文（就是我们之前讲的 AO）</h2><p>当函数执行的前一刻，会创建一个称为 执行期上下文的内部对象，<br>一个执行期上下文定义了一个函数执行时的环境，<br>函数每次执行时对应的执行期上下文都是独一无二的，<br>所以多次调用一个函数会导致创建多个执行期上下文，<br>当函数执行完毕，他创建的执行期上下文被销毁。</p><pre><code>解释：我们每次执行函数的前一刻系统都会创建 AO 对象，这个 AO 就定义了变量提升 函数提升等，比如说定义了一个函数 test，当你调用他的时候他会创建一个 AO，当你再次调用的时候他还会再次创建另一个 AO，AO只是一个临时的存储对象，当函数执行完毕时，AO 就会被销毁。</code></pre><h2 id="scope-–-gt-作用域"><a href="#scope-–-gt-作用域" class="headerlink" title="[[scope]] –&gt;作用域"></a>[[scope]] –&gt;作用域</h2><p>每个 JavaScript 函数都是一个对象，对象中有些属性我们可以访 问，但有些不可以，这些属性仅供 JavaScript 引擎存取，[[scope]]就是其中一个， [[scope]]指的就是我们所说的作用域，其中存储了运行期上下文的集合。</p><h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><p>[[scope]]中所存储的执行期上下文对象的集合，这个集合呈链式链 接，我们把这种链式链接叫做作用域链。在哪个函数里边查找变量，就去哪个函数的 作用域链顶端依次向下查找</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">function a()&#123;</span><br><span class="line">    function b()&#123;</span><br><span class="line">        function c()&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        c();</span><br><span class="line">    &#125;</span><br><span class="line">    b();</span><br><span class="line">&#125;</span><br><span class="line">a();</span><br><span class="line">解析：</span><br><span class="line">a 函数被定义：a. [[scope]]-------&gt;0：GO</span><br><span class="line">a 函数执行前：a. [[scope]]-------&gt;0：a 的 AO</span><br><span class="line">                                  1：GO</span><br><span class="line"></span><br><span class="line">b 函数被定义：b. [[scope]]-------&gt;0：a 的 AO</span><br><span class="line">                                  1：GO</span><br><span class="line">b 函数执行前：b. [[scope]]-------&gt;0：b 的 AO</span><br><span class="line">                                  1：a 的 AO</span><br><span class="line">                                  2：GO</span><br><span class="line"></span><br><span class="line">c 函数被定义：c. [[scope]]-------&gt;0：b 的 AO</span><br><span class="line">                                  1：a 的 AO</span><br><span class="line">                                  2：GO</span><br><span class="line">c 函数执行前：c. [[scope]]-------&gt;0：c 的 AO</span><br><span class="line">                                  1：b 的 AO</span><br><span class="line">                                  2：a 的 AO</span><br><span class="line">                                  3：GO</span><br></pre></td></tr></table></figure><h2 id="闭包的解决方法"><a href="#闭包的解决方法" class="headerlink" title="闭包的解决方法"></a>闭包的解决方法</h2><p>==在形成闭包的函数外面加一层立即执行函数。==</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function test()&#123;</span><br><span class="line">    var arr &#x3D; [];</span><br><span class="line">    for(var i &#x3D; 0;i &lt; 10;i ++)&#123;</span><br><span class="line">    &lt;!--此处为解决方法--&gt;</span><br><span class="line">       (function (j)&#123;</span><br><span class="line">            arr[j] &#x3D; function ()&#123;</span><br><span class="line">            document.write(j + &quot; &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;(i))</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br><span class="line">var myArr &#x3D; test();</span><br><span class="line">for(var j &#x3D; 0;j &lt; 10;j ++)&#123;</span><br><span class="line">    myArr[j]();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果不加立即执行函数，本想打印出 0123456789，结果会打印十个 10。<ul><li>原理：循环里面的函数会在循环结束后执行，此时 i 的值已经变成了 10.</li></ul></li><li>我们在 for 循环里加一个立即执行函数。<ul><li>原理： 形参传一个 j 进去，实参传 i，把里边 的 i 换成 j 就完美解决了。</li><li>每次形成闭包所绑定的值 j 都是固定的，就这样绑定十次，自然不会出错。</li></ul></li></ul><h1 id="对象-Object"><a href="#对象-Object" class="headerlink" title="对象 Object"></a>对象 Object</h1><h2 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h2><ul><li>keys(某个对象)，得到某个对象的所有属性名数组</li><li>values(某个对象)，得到某个对象的所有属性值数组</li><li>entries(某个对象)，得到某个对象的所有属性名和属性值的数组</li></ul><h2 id="实例成员-1"><a href="#实例成员-1" class="headerlink" title="实例成员"></a>实例成员</h2><blockquote><p>实例成员可以被重写</p></blockquote><p><strong>所有对象，都拥有 Object 的所有实例成员</strong></p><ul><li>toString 方法：得到某个对象的字符串格式<ul><li>默认情况下，该方法返回”[object Object]”;</li></ul></li><li>valueOf 方法：得到某个对象的值<ul><li>默认情况下，返回该对象本身</li></ul></li></ul><blockquote><p>在 JS 中，当自动的进行类型转换时，如果要对一个对象进行转换，实际上是先调用对象的 valueOf 方法，然后调用返回结果的 toString 方法，将得到的结果进行进一步转换。</p></blockquote><h2 id="对象属性的-增删改查"><a href="#对象属性的-增删改查" class="headerlink" title="对象属性的==增删改查=="></a>对象属性的==增删改查==</h2><ul><li>增：如果需要给一个对象增加一个属性，<br>就直接对象.xxx=xxx 即可，例如：mrDeng.wife= ‘xioaliu’;</li><li>删：如果需要删除对象的一个属性，我们需要用到一个关键字叫 delete，delete 后边 跟上对象的属性即可，例如：delete mrDeng.age；你再去访问 mrDeng.age 就会得到 undefined(注意：变量未经声明就使用肯定报错，但是在对象里不会报错，而且输出 undefined)</li><li>改：就是重新赋值，上边讲到了。</li><li>查：就是查看、访问，上边也讲到了。</li></ul><h4 id="对象的创建方法"><a href="#对象的创建方法" class="headerlink" title="对象的创建方法"></a>对象的创建方法</h4><ol><li>var obj={}</li><li>var obj=new Object() -&gt;构造函数</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(1)系统自带的构造函数 var obj&#x3D;new Object() 另外还有Array()、Number()</span><br><span class="line">(2)自定义(注意:凡是构造函数，命名都用大驼峰命名法)</span><br><span class="line">    funciton Person()&#123;</span><br><span class="line">        this.name&#x3D;&#39;bmw&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">    使用： var person&#x3D;new Person();</span><br></pre></td></tr></table></figure><ol start="3"><li>var obj=Object.create(原型)</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">这样通过Object.create也能创建出对象，括号里放的就是原型，你现在访问obj1.name 就是 a。</span><br><span class="line">    var obj &#x3D; &#123;name:&quot;a&quot;&#125;;</span><br><span class="line">    var obj1 &#x3D; Object.create(obj);</span><br><span class="line">+ 两种值：Object或null</span><br><span class="line">+ &#x3D;&#x3D;结论：绝大多数对象最终都继承自 Object.prototype（并不是所有）&#x3D;&#x3D;</span><br></pre></td></tr></table></figure><h2 id="创建一个对象的过程–构造函数内部原理"><a href="#创建一个对象的过程–构造函数内部原理" class="headerlink" title="创建一个对象的过程–构造函数内部原理"></a>创建一个对象的过程–构造函数内部原理</h2><p>隐式的三段式：</p><ol><li>当调用 new 时，在函数的最前边隐式的加上<br>var this = {<br><strong>proto</strong>:Xxx.prototype<br>};</li><li>执行 this.xxx = xxx；</li><li>在最后隐式的返回 this （return this）</li></ol><h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><p>当原始值调用某些属性时，JS 内部会给原始值一个包装类，<br>JS 会通过一系列操作让你实现此方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var str&#x3D; &#39;abc&#39;</span><br><span class="line">console.log(str.length) --&gt;new String(&#39;abc&#39;).length; delete;   &#x2F;&#x2F;返回3</span><br><span class="line">&#x2F;&#x2F;原始值本身没有属性和方法，通过内部生成一个一样的字符串对象，</span><br><span class="line">&#x2F;&#x2F;把length拿到后返回值，然后new的对象销毁</span><br><span class="line">---------------</span><br><span class="line">var num &#x3D; 123;</span><br><span class="line">&#x2F;&#x2F;此处给这个new的对象赋值后会直接销毁</span><br><span class="line">num.abc &#x3D; &#39;abc&#39; -&gt;(隐式操作)new Number(num).abc &#x3D; &#39;abc&#39;; delete;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;解释：当console.log()时会再创建一个对象：new Number(num).abc</span><br><span class="line">&#x2F;&#x2F;因为赋值的对象已经删除，这个num没有abc的属性，所以返回undefined</span><br><span class="line">console.log(num.abc) &#x2F;&#x2F;undefined</span><br></pre></td></tr></table></figure><h2 id="常用对象详解"><a href="#常用对象详解" class="headerlink" title="常用对象详解"></a>常用对象详解</h2><h3 id="Math"><a href="#Math" class="headerlink" title="Math()"></a>Math()</h3><ul><li>random() 随机数：调用一次产生一个随机数，(0,1)</li><li>ceil(x) 向上取整</li><li>floor(x) 向下取整</li><li>round(x) 四舍五入</li></ul><h3 id="详解-Math-random-应用"><a href="#详解-Math-random-应用" class="headerlink" title="详解-Math.random()应用"></a>详解-Math.random()应用</h3><ul><li>Math.random()范围：[0,1)</li><li>设定范围：<ul><li>Math.random()*24 // [0,24)</li><li>12+Math.random()*24 // [12,24)</li></ul></li></ul><h3 id="Date-日期对象"><a href="#Date-日期对象" class="headerlink" title="Date()==日期对象=="></a>Date()==日期对象==</h3><ul><li>var date = new Date();</li><li>setFullYear() ：用来打印年</li><li>setDay</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">获取当前时间：xxxx年xx月xx日 xx:xx:xx</span><br><span class="line">          function showtime() &#123;</span><br><span class="line">              myTime &#x3D; new Date();</span><br><span class="line">              let Year &#x3D; myTime.getFullYear();</span><br><span class="line">              let Month &#x3D; myTime.getMonth() + 1;</span><br><span class="line">              let myDate &#x3D; myTime.getDate();</span><br><span class="line">              let Hours &#x3D; myTime.getHours();</span><br><span class="line">              let Minutes &#x3D; myTime.getMinutes();</span><br><span class="line">              let Seconds &#x3D; myTime.getSeconds();</span><br><span class="line">              let Day &#x3D; myTime.getDay();</span><br><span class="line">              switch (Day) &#123;</span><br><span class="line">                  case 1:</span><br><span class="line">                      Day &#x3D; &#39;星期一&#39;;</span><br><span class="line">                      break;</span><br><span class="line">                  case 2:</span><br><span class="line">                      Day &#x3D; &#39;星期二&#39;;</span><br><span class="line">                      break;</span><br><span class="line">                  case 3:</span><br><span class="line">                      Day &#x3D; &#39;星期三&#39;;</span><br><span class="line">                      break;</span><br><span class="line">                  case 4:</span><br><span class="line">                      Day &#x3D; &#39;星期四&#39;;</span><br><span class="line">                      break;</span><br><span class="line">                  case 5:</span><br><span class="line">                      Day &#x3D; &#39;星期五&#39;;</span><br><span class="line">                      break;</span><br><span class="line">                  case 6:</span><br><span class="line">                      Day &#x3D; &#39;星期六&#39;;</span><br><span class="line">                      break;</span><br><span class="line">                  case 0:</span><br><span class="line">                      Day &#x3D; &#39;星期日&#39;;</span><br><span class="line">                      break;</span><br><span class="line">              &#125;</span><br><span class="line">              if (Hours &lt; 10) Hours &#x3D; &#39;0&#39; + Hours;</span><br><span class="line">              if (Minutes &lt; 10) Minutes &#x3D; &#39;0&#39; + Minutes;</span><br><span class="line">              if (Seconds &lt; 10) Seconds &#x3D; &#39;0&#39; + Seconds;</span><br><span class="line">              let a &#x3D; document.getElementById(&#39;time&#39;);</span><br><span class="line">              var thisdate &#x3D; Year + &#39;年&#39; + Month + &#39;月&#39; +     myDate + &#39;日 &#39;</span><br><span class="line">              + Hours + &#39;:&#39; + Minutes + &#39;:&#39; +     Seconds + &#39; &#39; + Day;</span><br><span class="line">              return thisdate;</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure><h1 id="原型-amp-原型链"><a href="#原型-amp-原型链" class="headerlink" title="原型&amp;原型链"></a>原型&amp;原型链</h1><ul><li>所有对象都是通过<code>new 函数</code>创建</li><li><strong>==所有的函数也是对象==</strong><ul><li>函数中可以有属性</li></ul></li><li>所有对象都是引用类型</li></ul><h2 id="原型-prototype"><a href="#原型-prototype" class="headerlink" title="原型: prototype"></a>原型: prototype</h2><p><strong>==所有函数==</strong> 都有一个属性：prototype，称之为函数原型</p><p>默认情况下，<strong>prototype 是一个普通的 Object 对象</strong>，如：Person.prototype={xxx:xxx};</p><p>默认情况下，prototype 中有一个属性，constructor，它也是一个对象，它指向构造函数本身。</p><p>当有一个对象的时候，一定能知道他的构造函数： obj.<strong>proto</strong>.constructor.name<br><img src="http://47.97.6.61/%E6%9C%89%E9%81%93%E4%BA%91%E5%9B%BE%E7%89%87/%E5%8E%9F%E5%9E%8B%E4%B8%AD%E7%9A%84constructor%E6%8C%87%E5%90%91%E5%87%BD%E6%95%B0%E6%9C%AC%E8%BA%AB.jpg" alt="原型中的constructor指向函数本身"></p><p><strong>特点&amp;作用：可以提取公有属性</strong></p><p>当访问一个对象的成员时：</p><ol><li>看该对象自身是否拥有该成员，如果有直接使用</li><li>在原型链中依次查找是否拥有该成员，如果有直接使用</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype.LastName&#x3D;&#39;deng&#39;;</span><br><span class="line">function Person()&#123;</span><br><span class="line">&#125;</span><br><span class="line">var obj &#x3D; new Person();</span><br><span class="line">obj.LastName &#x3D;&#x3D; &#39;deng&#39;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="隐式原型-proto"><a href="#隐式原型-proto" class="headerlink" title="隐式原型 proto"></a>隐式原型 <strong>proto</strong></h2><p>==<strong>所有对象</strong>== 都有一个属性：<code>__proto__</code>，称之为隐式原型</p><p>默认情况下，隐式原型指向创建该对象的函数的原型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function text()&#123;</span><br><span class="line">&#125;</span><br><span class="line">var obj &#x3D; new test();</span><br><span class="line">&#x2F;&#x2F;obj.__proto__ &#x3D;&#x3D;&#x3D; test.prototype</span><br><span class="line"></span><br><span class="line">function text()&#123;</span><br><span class="line">    return &#123;&#125; &#x2F;&#x2F; -&gt; new Object</span><br><span class="line">&#125;</span><br><span class="line">var obj &#x3D; new test();</span><br><span class="line">&#x2F;&#x2F;obj.__proto__ &#x3D;&#x3D;&#x3D; Object.prototype</span><br></pre></td></tr></table></figure><p>原理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;当调用new时，在函数的最前边隐式的加上</span><br><span class="line">var this &#x3D; &#123;</span><br><span class="line">    __proto__:Person.prototype</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;此时Person的原型是默认的prototype</span><br><span class="line">var obj&#x3D;&#123;</span><br><span class="line">    name:&quot;li&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;如果更改Person的__proto__的属性</span><br><span class="line">person.__proto__&#x3D;obj;</span><br><span class="line">&#x2F;&#x2F;此时Person的原型指向obj</span><br></pre></td></tr></table></figure><p><img src="http://47.97.6.61/%E6%9C%89%E9%81%93%E4%BA%91%E5%9B%BE%E7%89%87/%E9%9A%90%E5%BC%8F%E5%8E%9F%E5%9E%8B%E7%9A%84%E6%8C%87%E5%90%91.jpg" alt="隐式原型的指向"></p><p><strong>注意点：</strong></p><ol><li>对象的最终原型都会指向 Object(null 没有原型)</li><li>在函数原型中加入成员，以增强起对象的功能，但是会导致原型污染，使用需谨慎</li></ol><p><strong>练习题：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">下列代码执行完之后访问 person.name 是啥？</span><br><span class="line">Person.prototype.name &#x3D; &quot;sunny&quot;;</span><br><span class="line">function Person() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">var person &#x3D; new Person;</span><br><span class="line">Person.prototype &#x3D; &#123;</span><br><span class="line">    name:&quot;cherry&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">解析：此时应该是 sunny.</span><br><span class="line">最开始的时候__proto__ 和 Person.prototype 指向的是同一个房间，</span><br><span class="line">后来 Person.prototype 指向了一个新的房间，</span><br><span class="line">但是访问 person.name 他找的是__proto__，</span><br><span class="line">__proto__还是指向原来那个房间啊，所以是 sunny</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p><img src="http://47.97.6.61/%E6%9C%89%E9%81%93%E4%BA%91%E5%9B%BE%E7%89%87/%E9%93%BE%E6%9D%A1%E7%9A%84%E5%85%A8%E8%B2%8C.jpg" alt="链条的全貌"></p><ul><li>所有的函数都是通过 new Function 来产生的</li><li>所有的对象都是通过 new 函数来产生的</li><li>由上可知：自定义对象的隐式原型(<strong>proto</strong>)都指向 Function.prototype</li></ul><p><strong>特殊点</strong></p><ol><li>Function 的<strong>proto</strong>指向自身的 prototype</li><li>Object 的 prototype 的<strong>proto</strong>指向 null</li></ol><p><strong>面试题</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">题目1：</span><br><span class="line">var F &#x3D; function () &#123;&#125;</span><br><span class="line">Object.prototype.a &#x3D; function () &#123;&#125; &#x2F;&#x2F;所有的对象都有</span><br><span class="line">Function.prototype.b &#x3D; function () &#123;&#125;&#x2F;&#x2F;所有的函数都有</span><br><span class="line"></span><br><span class="line">var f &#x3D; new F();</span><br><span class="line"></span><br><span class="line">console.log(f.a, f.b, F.a, F.b);&#x2F;&#x2F;f是对象，F是函数也是对象</span><br><span class="line">&#x2F;&#x2F; fn    undefined    fn    fn</span><br><span class="line"></span><br><span class="line">题目2：</span><br><span class="line">function A() &#123;&#125;</span><br><span class="line">function B(a) &#123;</span><br><span class="line">    this.a &#x3D; a;</span><br><span class="line">&#125;</span><br><span class="line">function C(a) &#123;</span><br><span class="line">    if (a) &#123;</span><br><span class="line">        this.a &#x3D; a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">A.prototype.a &#x3D; 1;</span><br><span class="line">B.prototype.a &#x3D; 1;</span><br><span class="line">C.prototype.a &#x3D; 1;</span><br><span class="line"></span><br><span class="line">console.log(new A().a); &#x2F;&#x2F;1</span><br><span class="line">console.log(new B().a); &#x2F;&#x2F;undefined</span><br><span class="line">console.log(new C(2).a); &#x2F;&#x2F;2</span><br><span class="line"></span><br><span class="line">题目3：</span><br><span class="line">function User() &#123;&#125;</span><br><span class="line">User.prototype.sayHello &#x3D; function() &#123;&#125;</span><br><span class="line"></span><br><span class="line">var u1 &#x3D; new User();</span><br><span class="line">var u2 &#x3D; new User();</span><br><span class="line"></span><br><span class="line">console.log(u1.sayHello &#x3D;&#x3D;&#x3D; u2.sayHello); &#x2F;&#x2F;true</span><br><span class="line">console.log(User.prototype.constructor); &#x2F;&#x2F;User Function</span><br><span class="line">console.log(User.prototype &#x3D;&#x3D;&#x3D; Function.prototype); &#x2F;&#x2F; false</span><br><span class="line">console.log(User.__proto__ &#x3D;&#x3D;&#x3D; Function.prototype); &#x2F;&#x2F; true</span><br><span class="line">console.log(User.__proto__ &#x3D;&#x3D;&#x3D; Function.__proto__); &#x2F;&#x2F; true</span><br><span class="line">console.log(u1.__proto__ &#x3D;&#x3D;&#x3D; u2.__proto__);  &#x2F;&#x2F; true</span><br><span class="line">console.log(u1.__proto__ &#x3D;&#x3D;&#x3D; User.__proto__); &#x2F;&#x2F; false</span><br><span class="line">console.log(Function.__proto__ &#x3D;&#x3D;&#x3D; Object.__proto__); &#x2F;&#x2F; true</span><br><span class="line">console.log(Function.prototype.__proto__ &#x3D;&#x3D;&#x3D; Object.prototype.__proto__); &#x2F;&#x2F; false</span><br><span class="line">console.log(Function.prototype.__proto__ &#x3D;&#x3D;&#x3D; Object.prototype); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure><h2 id="原型链的应用"><a href="#原型链的应用" class="headerlink" title="原型链的应用"></a>原型链的应用</h2><h3 id="基础方法"><a href="#基础方法" class="headerlink" title="基础方法"></a>基础方法</h3><ul><li><p><strong>Object.getPrototypeOf(对象)**：静态方法，获取对象的隐式原型（W3C 不推荐直接使用系统成员</strong>proto**）</p></li><li><p>**Object.setPrototypeOf(对象,对象)**：静态方法，设置对象的隐式原型，将第一个对象的隐式原型设置为第二个参数</p></li><li><p>**Object.prototype.isPrototypeOf(对象)**：判断当前对象(this)是否在指定对象的原型链上</p><ul><li>Function.prototype.isPrototypeOf(对象)：这里就是判断对象是否在 Function 的原型链上</li></ul></li><li><p><strong>对象 instanceof 函数</strong>：判断函数的原型是否在对象的原型链上</p></li><li><p>**Object.create(对象)**：创建一个新对象，其隐式原型指向指定的对象</p></li><li><p><strong>Object.prototype.hasOwnProperty(属性名)**：判断一个对象</strong>自身**是否拥有某个属性</p></li></ul><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ul><li>继承类数组转换为数组<code>Array.prototype.slice.call(arr)</code></li><li>实现继承 （圣杯模式）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> var inherit &#x3D; (function () &#123;</span><br><span class="line">    var F &#x3D; function () &#123;&#125;;</span><br><span class="line">    return function (Origin,Target) &#123;</span><br><span class="line">        F.prototype &#x3D; Origin.prototype;</span><br><span class="line">        Target.prototype &#x3D; new F();</span><br><span class="line">        Target.prototype.constructor &#x3D; Target;</span><br><span class="line">        Target.prototype.uber &#x3D; Origin.prototype;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;())</span><br></pre></td></tr></table></figure></li></ul><h3 id="原型链上的增删改查"><a href="#原型链上的增删改查" class="headerlink" title="原型链上的增删改查:"></a>原型链上的增删改查:</h3><pre><code>+ 增：只能父类自己增加属性，子类无法给父类增加属性。+ 删除/修改属性，只能在父类中修改删除，子类无法修改删除父类属性。- 有一种特殊情况可以修改父类属性，当父类属性为引用值时，可以通过引用值修改。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function Father() &#123;</span><br><span class="line">    this.name &#x3D; &quot;xuming&quot;;</span><br><span class="line">    this.fortune &#x3D; &#123;</span><br><span class="line">        card1:&quot;visa&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;当使用以下方法时，可以改值</span><br><span class="line">son.fortune.card2&#x3D;&quot;master&quot;;</span><br><span class="line"></span><br><span class="line">解释：因为son.fortune 就相当于 fortune 被你取出来了，</span><br><span class="line">取出来之后.name 就相当于 fortune.name 给自己加 东西，</span><br><span class="line">这不算一种赋值的修改，这算一种调用的修改，</span><br><span class="line">这种层面上的修改是可以的， 但是直接给他加值覆盖进去是不行的，</span><br><span class="line">这种修改也仅限于引用值，原始值是不可以的###</span><br></pre></td></tr></table></figure></code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">例子：</span><br><span class="line">Grand.prototype.LastName &#x3D; &quot;Deng&quot;;</span><br><span class="line">function Grand()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">var grand &#x3D; new Grand();</span><br><span class="line"></span><br><span class="line">Father.prototype &#x3D; grand;</span><br><span class="line">function Father()&#123;</span><br><span class="line">    this.name&#x3D;&quot;xiaoming&quot;;</span><br><span class="line">&#125;</span><br><span class="line">var father &#x3D; new Father();</span><br><span class="line">Son.prototype &#x3D; father;</span><br><span class="line">function Son()&#123;</span><br><span class="line">    this.hobbit &#x3D; &quot;smoke&quot;;</span><br><span class="line">&#125;</span><br><span class="line">var son &#x3D; new Son();</span><br></pre></td></tr></table></figure><h1 id="属性描述符"><a href="#属性描述符" class="headerlink" title="属性描述符"></a>属性描述符</h1><h2 id="属性描述符-1"><a href="#属性描述符-1" class="headerlink" title="属性描述符"></a>属性描述符</h2><p>属性描述符的配置参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty</a></p><p>属性描述符：它表达了一个属性的相关信息（元数据），<strong>它本质上是一个对象。</strong></p><p>对象里目前存在的属性描述符有两种主要形式：==<strong>数据描述符</strong>==和==<strong>存取描述符</strong>==。</p><ul><li>数据描述符：是一个具有值的属性，该值可以是可写的，也可以是不可写的。</li><li>存取描述符：是由 getter 函数和 setter 函数所描述的属性。</li><li>==<strong>注意：一个描述符只能是这两者其中之一；不能同时是两者。</strong>==</li></ul><p><img src="http://47.97.6.61/%E6%9C%89%E9%81%93%E4%BA%91%E5%9B%BE%E7%89%87/%E5%B1%9E%E6%80%A7%E6%8F%8F%E8%BF%B0%E7%AC%A6.png" alt="属性描述符"></p><ul><li>value 属性内容，默认为 undefined</li><li>writable 该属性是否可以被重新赋值，当为 true 时，属性的值才能被赋值运算符改变。默认为 false</li><li>enumerable：该属性是否可以被枚举。<ul><li>键值为 true 时，该属性才会出现在对象的枚举属性中。默认为 false。</li><li>会影响到 for-in</li><li>会影响到 Object.keys()</li></ul></li><li>configurable：该属性的描述符是否可写。<ul><li>键值为 true 时，该属性的描述符才能够被改变，同时该属性也能从对应的对象上被删除。默认为 false</li></ul></li></ul><h3 id="数据描述符-具有以下可选键值"><a href="#数据描述符-具有以下可选键值" class="headerlink" title="==数据描述符==具有以下可选键值"></a>==数据描述符==具有以下可选键值</h3><ul><li>value 属性内容，默认为 undefined</li><li>writable 当为 true 时，属性的值才能被赋值运算符改变。默认为 false</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数据描述符</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&quot;x&quot;</span>, &#123;</span><br><span class="line">  value: <span class="number">1</span>,</span><br><span class="line">&#125;); <span class="comment">//相当于 obj.x = 1;</span></span><br></pre></td></tr></table></figure><h3 id="存取描述符-具有以下可选键值"><a href="#存取描述符-具有以下可选键值" class="headerlink" title="==存取描述符==具有以下可选键值"></a>==存取描述符==具有以下可选键值</h3><ul><li>get: function(){} //读取属性时运行此函数</li><li>set: function(){} //设置属性值时运行此函数</li><li><strong>如果配置了存取描述符，value 属性不需配置（无效）</strong></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//存取描述符</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&quot;x&quot;</span>, &#123;</span><br><span class="line">  get: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//当读取属性x的时候，会运行此函数</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;读取属性x&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  set: <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//当设置属性x的时候，会运行此函数</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;给属性赋值为&quot;</span> + val);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">obj.x = <span class="number">3</span>; <span class="comment">//相当于运行了 set(3)</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.x); <span class="comment">//会运行get()方法</span></span><br></pre></td></tr></table></figure><h3 id="其他属性，两种描述符都是对象。它们共享以下可选键值"><a href="#其他属性，两种描述符都是对象。它们共享以下可选键值" class="headerlink" title="其他属性，两种描述符都是对象。它们共享以下可选键值"></a>其他属性，两种描述符都是对象。它们共享以下可选键值</h3><ul><li>configurable：该属性的描述符是否可以修改。</li><li>enumerable：该属性是否可以被枚举。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&quot;x&quot;</span>, &#123;</span><br><span class="line">  value: <span class="number">1</span>,</span><br><span class="line">  configurable: <span class="literal">true</span>, <span class="comment">//可以通过 obj.x=2 来改变</span></span><br><span class="line">  enumerable: <span class="literal">true</span>, <span class="comment">//可以通过遍历找到此属性</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="配置属性描述符"><a href="#配置属性描述符" class="headerlink" title="配置属性描述符"></a>配置属性描述符</h2><ul><li>Object.defineProperty(对象,属性名称,{==<strong>属性描述符</strong>==})</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj,<span class="string">&quot;x&quot;</span>,&#123;</span><br><span class="line">    value: <span class="number">1</span>，</span><br><span class="line">    writable: <span class="literal">true</span></span><br><span class="line">&#125;) <span class="comment">//相当于 obj.x = 1;</span></span><br></pre></td></tr></table></figure><ul><li>Object.defineProperties(对象, 多个属性的描述符)</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, &#123;</span><br><span class="line">  a: &#123;</span><br><span class="line">    value: <span class="number">3</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  b: &#123;</span><br><span class="line">    value: <span class="number">4</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>如果一个属性描述符同时拥有 value 或 writable 和 get 或 set 键，则会产生一个异常。</li></ul><h2 id="得到对象的属性描述符-静态方法"><a href="#得到对象的属性描述符-静态方法" class="headerlink" title="得到对象的属性描述符(静态方法)"></a>得到对象的属性描述符(静态方法)</h2><ul><li><strong>Object.getOwnPropertyDescriptor</strong></li><li>获取某个对象的某个属性的属性描述符 （该属性必须直接属于该对象）</li><li>属性没有设置属性描述符默认为数据描述符</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(obj,<span class="string">&quot;x&quot;</span>);</span><br><span class="line"><span class="comment">//返回描述符对象</span></span><br><span class="line">    &#123;</span><br><span class="line">        value: <span class="number">1</span>,</span><br><span class="line">        configurable:<span class="literal">true</span>, <span class="comment">//可以通过 obj.x=2 来改变</span></span><br><span class="line">        enumerable:<span class="literal">true</span> <span class="comment">//可以通过遍历找到此属性</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="数据属性"><a href="#数据属性" class="headerlink" title="数据属性"></a>数据属性</h2><ul><li>之前学习的所有属性都用的数据属性</li><li>直接赋值来添加的属性[obj.x=1]或者初始化对象时添加的属性都叫数据属性</li></ul><h2 id="存取器属性"><a href="#存取器属性" class="headerlink" title="存取器属性"></a>存取器属性</h2><p>属性描述符中，如果配置了 get 和 set 中的任何一个，则该属性，不再是一个普通属性，而变成了存取器属性。</p><ul><li>当读取该属性时，会运行 get 方法，得到的返回值为属性值</li><li>当赋值该属性时，会运行 set 方法</li><li>存取器属性最大的意义，在于可以控制属性的读取和赋值。</li></ul><h2 id="创建存取器属性（静态方法）"><a href="#创建存取器属性（静态方法）" class="headerlink" title="创建存取器属性（静态方法）"></a>创建存取器属性（静态方法）</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&quot;a&quot;</span>, &#123;</span><br><span class="line">  get() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;运行了属性a的get函数&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> obj._a;</span><br><span class="line">  &#125;,</span><br><span class="line">  set(val) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;运行了属性a的set函数&quot;</span>, val);</span><br><span class="line">    obj._a = val;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">obj.a = <span class="number">20</span> + <span class="number">10</span>; <span class="comment">// set(20 + 10)</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.a); <span class="comment">// console.log(get())</span></span><br></pre></td></tr></table></figure><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>面试题：obj 的 namge 固定为 abc,且不能被重新赋值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="comment">//存取描述符方式</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&quot;name&quot;</span>, &#123;</span><br><span class="line">  get: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//数据描述符方式</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&quot;name&quot;</span>, &#123;</span><br><span class="line">  value: <span class="string">&quot;abc&quot;</span>,</span><br><span class="line">  writable: <span class="literal">false</span>, <span class="comment">//设置不可写，默认也是false</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>使用存取描述符 设置年龄的范围</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">User</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="comment">//年龄的取值范围是 0 - 100</span></span><br><span class="line">  <span class="comment">//如果年龄的值小于了0，则赋值为0，如果年龄的值大于了100，则赋值为100</span></span><br><span class="line">  <span class="keyword">var</span> _age;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(<span class="built_in">this</span>, <span class="string">&quot;age&quot;</span>, &#123;</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> _age;</span><br><span class="line">    &#125;,</span><br><span class="line">    set: <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (val &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        val = <span class="number">0</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &gt; <span class="number">100</span>) &#123;</span><br><span class="line">        val = <span class="number">100</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      _age = val;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> u = <span class="keyword">new</span> User(<span class="string">&quot;abc&quot;</span>, <span class="number">-1</span>); <span class="comment">// 运行get,age = 0</span></span><br><span class="line">u.age = u.age + <span class="number">10000</span>; <span class="comment">//运行set(0 + 10000)</span></span><br><span class="line"><span class="built_in">console</span>.log(u.age); <span class="comment">//运行get ,age = 100</span></span><br></pre></td></tr></table></figure><p>将页面元素于属性描述符关联起来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">    &lt;p&gt;</span><br><span class="line">&lt;span&gt;姓名：&lt;&#x2F;span&gt;</span><br><span class="line">&lt;span id&#x3D;&quot;name&quot;&gt;&lt;&#x2F;span&gt;</span><br><span class="line">    &lt;&#x2F;p&gt;</span><br><span class="line">    &lt;p&gt;</span><br><span class="line">&lt;span&gt;年龄：&lt;&#x2F;span&gt;</span><br><span class="line">&lt;span id&#x3D;&quot;age&quot;&gt;&lt;&#x2F;span&gt;</span><br><span class="line">    &lt;&#x2F;p&gt;</span><br><span class="line">ipt&gt;</span><br><span class="line">const spanName &#x3D; document.getElementById(&quot;name&quot;)</span><br><span class="line">const spanAge &#x3D; document.getElementById(&quot;age&quot;)</span><br><span class="line">const user &#x3D; &#123;&#125;</span><br><span class="line">Object.defineProperties(user, &#123;</span><br><span class="line">    name: &#123;</span><br><span class="line">        get() &#123;</span><br><span class="line">            return spanName.innerText;</span><br><span class="line">        &#125;,</span><br><span class="line">        set(val) &#123;</span><br><span class="line">            spanName.innerText &#x3D; val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    age: &#123;</span><br><span class="line">        get() &#123;</span><br><span class="line">            return +spanAge.innerText;</span><br><span class="line">        &#125;,</span><br><span class="line">        set(val) &#123;</span><br><span class="line">            if (typeof val !&#x3D;&#x3D; &quot;number&quot;) &#123;</span><br><span class="line">                throw new TypeError(&quot;年龄必须是一个数字&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">            if (val &lt; 0) &#123;</span><br><span class="line">                val &#x3D; 0;</span><br><span class="line">            &#125; else if (val &gt; 200) &#123;</span><br><span class="line">                val &#x3D; 200;</span><br><span class="line">            &#125;</span><br><span class="line">            spanAge.innerText &#x3D; val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="继承发展史"><a href="#继承发展史" class="headerlink" title="继承发展史"></a>继承发展史</h2><h3 id="（1）传统方式——原型链"><a href="#（1）传统方式——原型链" class="headerlink" title="（1）传统方式——原型链"></a>（1）传统方式——原型链</h3><pre><code>Grand.prototype.lastName = &quot;ji&quot;;function Grand() &#123;&#125;var grand = new Grand();Father.prototype = grand;function Father() &#123;    this.name = &quot;hehe&quot;;&#125;var father = new Father();Son.prototype = father;function Son() &#123;&#125;var son = new Son();</code></pre><p>弊端：过多的继承了一些没有用的属性，比如说我现在就想让 son 继承顶端的 lastName， 而因为它是原型链，他就把 father 上的，father 原型上的，grand 上的，grand 原型 上的东西全部继承了，那么就有个不好的地方就是我想继承的你继承过来了，不想继 承的你也给继承过来了，这样是很影响效率的，所以第一种方式很快就被放弃掉了</p><h3 id="（2）借用构造函数"><a href="#（2）借用构造函数" class="headerlink" title="（2）借用构造函数"></a>（2）借用构造函数</h3><pre><code>function Person(name,age,sex) &#123;    this.name = name;    this.age = age;    this.sex = sex;&#125;function Student(name,age,sex,tel,grade) &#123;    Person.call(this,name,age,sex);    this.tel = tel;    this.grade = grade;&#125;var student = new Student(&#39;sunny&#39;,123,&#39;male&#39;,139,2017);</code></pre><p>弊端：你只能继承他自己，并不能继承他 的原型，因为原型还是自己的 Student.prototype，而且每次构造函数都要多走一个函数，这么写虽然看着省了点代 码量，但是在执行的时候复杂了，因为他多调用了一个方法的执行，很浪费效率。（虽 然在继承层面上来说这样是不好的，但是实际开发的时候当别人的方法涵盖了你的方 法的话，还是提倡这么用）</p><h3 id="（3）共享原型"><a href="#（3）共享原型" class="headerlink" title="（3）共享原型"></a>（3）共享原型</h3><pre><code>Father.prototype.lastName = &quot;Deng&quot;;function Father()&#123;&#125;function Son()&#123;&#125;Son.prototype = Father.prototype;var son = new Son();var father = new Father();</code></pre><p>弊端：Son 是继承了 Father 的原型，但是这么写假如说 Son 想给自己的原型加东西的话会影响 Father 的原型的。因此产生了圣杯模式。</p><h3 id="（4）-圣杯模式"><a href="#（4）-圣杯模式" class="headerlink" title="（4）==圣杯模式=="></a>（4）==圣杯模式==</h3><p>方法里面的内容，最完美的继承模式，叫做圣杯模式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 写一个继承方法（被继承，集成）</span><br><span class="line">        function inherit(Origin,Target) &#123;</span><br><span class="line">            function F() &#123;&#125;;</span><br><span class="line">            F.prototype &#x3D; Origin.prototype;</span><br><span class="line">            Target.prototype &#x3D; new F();</span><br><span class="line">            Target.prototype.constructor  &#x3D; Target;</span><br><span class="line">            Target.prototype.uber &#x3D; Origin.prototype;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;方法的使用</span><br><span class="line">        F.prototype.lastName &#x3D; &quot;fu&quot;;</span><br><span class="line">        function F() &#123;&#125;</span><br><span class="line">        function S() &#123;&#125;</span><br><span class="line">        inherit(S, F);</span><br><span class="line">&#x2F;&#x2F;注意：此处必须先继承再创建对象，才能继承到父级属性。</span><br><span class="line">&#x2F;&#x2F;关于constructor:</span><br><span class="line">我们知道原型里都有一个属性叫 constructor，</span><br><span class="line">这个 constructor 的作用就是指向构造函数，</span><br><span class="line">但是现在我们访问 son.constructor 会得到ƒ Father()&#123;&#125;，</span><br><span class="line">是因为 son 的原型指向 new F();new F()里没有这个属性，</span><br><span class="line">就去 Father.prototype 里找到了这个属性，这就造成了指向紊乱，</span><br><span class="line">我们手 动的给他归一下位即可（即constructor的那条语句）</span><br><span class="line">&#x2F;&#x2F;关于uber（自己起的名字，用来存储真正继承的父类）：</span><br><span class="line">假如说你真正想知道 他继承自谁就可以查看 uber，是一个信息的储存。</span><br></pre></td></tr></table></figure><h3 id="以上是最通俗写法，还有个高大上写法-YUI-库写法-推荐使用"><a href="#以上是最通俗写法，还有个高大上写法-YUI-库写法-推荐使用" class="headerlink" title="以上是最通俗写法，还有个高大上写法(YUI 库写法)(推荐使用)"></a>以上是最通俗写法，还有个高大上写法(YUI 库写法)(推荐使用)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    var inherit &#x3D; (function () &#123;</span><br><span class="line">        var F &#x3D; function () &#123;&#125;;</span><br><span class="line">        return function (Origin,Target) &#123;</span><br><span class="line">            F.prototype &#x3D; Origin.prototype;</span><br><span class="line">            Target.prototype &#x3D; new F();</span><br><span class="line">            Target.prototype.constructor &#x3D; Target;</span><br><span class="line">            Target.prototype.uber &#x3D; Origin.prototype;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;())</span><br><span class="line">解释：最后我们会把 return 的东西(就是 return 后边的函数体)传给变量 inherit，</span><br><span class="line">那么， 里边的功能我们都知道了，唯一的问题就是 F 哪去了？</span><br><span class="line">不是真正没有了，是形成闭包 了，成了 return 后边函数里的私有化变量了，</span><br><span class="line">而这么写是非常好的写法，因为本来这</span><br><span class="line">个 F 就是起到过度的作用，没有太大用处，</span><br><span class="line">我们就放到闭包里作为私有化变量，看起来更好，语义化也好一点。</span><br></pre></td></tr></table></figure><h1 id="对象的枚举-遍历"><a href="#对象的枚举-遍历" class="headerlink" title="对象的枚举(遍历)"></a>对象的枚举(遍历)</h1><h2 id="（1）for-in-循环"><a href="#（1）for-in-循环" class="headerlink" title="（1）for .. in .. 循环"></a>（1）for .. in .. 循环</h2><pre><code>- 如果对象里面有原型（__proto__:&#123;...&#125;)，也会把属性拿出。</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123;</span><br><span class="line">    name : &#39;du&#39;,</span><br><span class="line">    num : 1</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;for...in... 循环</span><br><span class="line">for(var prop in obj)&#123;</span><br><span class="line">   &#x2F;&#x2F;  如果使用 obj.prop，会变成这样obj[&#39;prop&#39;]，返回undefined</span><br><span class="line">        console.log(obj[prop]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="（2）hasOwnProperty：判断是否是自己的属性和方法"><a href="#（2）hasOwnProperty：判断是否是自己的属性和方法" class="headerlink" title="（2）hasOwnProperty：判断是否是自己的属性和方法"></a>（2）hasOwnProperty：判断是否是自己的属性和方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123;</span><br><span class="line">        name: &#39;du&#39;,</span><br><span class="line">        num: 999,</span><br><span class="line">        __proto__: &#123;</span><br><span class="line">            lastName: &#39;deng&#39;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">for (var prop in obj) &#123;</span><br><span class="line">&#x2F;&#x2F;判断属性方法是否是自己的属性和方法，是的话打印，原型的属性就不打印。</span><br><span class="line">    if (obj.hasOwnProperty(prop))</span><br><span class="line">        console.log(obj[prop]);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;只打印name和num</span><br></pre></td></tr></table></figure><h2 id="（3）in"><a href="#（3）in" class="headerlink" title="（3）in"></a>（3）in</h2><p>in 只能判断这个属性到底可不可以被这个对 象访问到，并不能判断这个属性属不属于这个对象。</p><pre><code>例：&quot;height&quot; in obj 得到 true（属性是字符串形式的，必须 加上引号，不加会报错的）（ in 基本不用，但是考试有时候会考到）</code></pre><h2 id="（4）instanceof-判断是否为构造方法的属性"><a href="#（4）instanceof-判断是否为构造方法的属性" class="headerlink" title="（4）instanceof : 判断是否为构造方法的属性"></a>（4）instanceof : 判断是否为构造方法的属性</h2><p>a instanceof b：看 A 对象的原型链上有没有 B 的原型。</p><pre><code>例：[] instanceof Array -&gt;true[] instanceof Object -&gt;true</code></pre><h2 id="思考：如何判断一个变量是数组还是对象。"><a href="#思考：如何判断一个变量是数组还是对象。" class="headerlink" title="思考：如何判断一个变量是数组还是对象。"></a>思考：如何判断一个变量是数组还是对象。</h2><ul><li><strong>方法一</strong>：arr.constructor，如果返回 function Array(){}就是数组，返回 function Object(){}就是对象。</li><li><strong>方法二</strong>：arr instanceof Array，如果返回 true 就是数组，返回 false 就是对象。</li><li>**方法三(无 BUG,推荐)**：调用 Object.prototype.toString.call(arr),数组返回”[object Array]”， 对象返回”[object Object]”</li></ul><h1 id="this-的使用"><a href="#this-的使用" class="headerlink" title="this 的使用"></a>this 的使用</h1><h2 id="this-的四大特点"><a href="#this-的四大特点" class="headerlink" title="this 的四大特点"></a>this 的四大特点</h2><ul><li>1.预编译 this –&gt; window</li><li>2.谁调用 this 指向谁</li><li>3.call apply 改变指向</li><li>4.全局 this –&gt;Window <br><br>==注意==：function()前面没有“xxx.”，就是全局调用，this 指向 window</li></ul><h2 id="new-test-和-test-区别"><a href="#new-test-和-test-区别" class="headerlink" title="new test()和 test()区别"></a>new test()和 test()区别</h2><pre><code>练习：运行 test()和 new test()的结果分别是什么？var a = 5;function test() &#123;    a = 0;    alert(a);    alert(this.a);    var a;    alert(a);&#125;解析：运行 test()的时候 alert 的结果是 0  5  0，因为第二个 alert 里的 this 指向 全局 window。运行 new test()的时候输出 0  undefined  0，因为你 new 了，this 就代表一个对象了，对象里没有 a，所以就是 undefined。注意：new test();时，里面隐式创建var this=Object.create(test.prototype)[也就是Object]。this这个对象里面没有a，所以返回undefined。</code></pre><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="定义数组"><a href="#定义数组" class="headerlink" title="定义数组"></a>定义数组</h2><ul><li>var arr = [1,2,3,4,5];</li><li>var arr = new Array(1,2,3,4,5);</li><li>当 new Array(10),中只有一位的时候，会默认为一个长度为 10 的空数组</li><li>arr[10]=”abc” , 会把 abc 赋值给数组的第十位</li></ul><h3 id="添加数组项"><a href="#添加数组项" class="headerlink" title="添加数组项"></a>添加数组项</h3><ul><li>数组[长度] = 数据：向数组末尾添加一个数据</li><li>push(数据) //从数组最后一位添加数据(可添加多个)，并返回组长度</li><li>unshift(数据) //在数组的第一位添加数据(可添加多个)，并返数组长度</li><li>==splice==() //添加新数据[及切除数据]</li></ul><h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><ul><li>delete 数组[下标]: 这种做法不会导致数组其他的属性发生变化，因此，该做法会导致产生稀松数组，所以不推荐使用该做法。</li></ul><ul><li>pop() //删除数组最后一位，并返回此值。(传参无效)</li><li>shift() //删除数组的第一位，并返回此值。(传参无效)</li><li>splice() //切除数据[及添加新数据]。</li></ul><h3 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h3><ul><li>数组排序：sort()</li><li>数组清空<ul><li>数组.splice(0, 数组.length);</li><li>数组.length = 0;</li></ul></li><li>查找数组中某一项的下标<ul><li>数组.indexOf(数据) 找到返回坐标，找不到返回-1</li><li>数组.lastIndexOf(数据) 找到最后一个匹配的下标</li></ul></li><li>遍历<ul><li>普通 for</li><li>foreach</li><li>for-in(遍历对象)</li></ul></li><li>过滤 filter</li><li>更多往下看…</li></ul><h3 id="语法补充"><a href="#语法补充" class="headerlink" title="语法补充"></a>语法补充</h3><ul><li>in 关键字，判断某个属性在对象中是否存在<ul><li>属性名 in 对象</li></ul></li></ul><h2 id="静态方法-Array-直接调用的方法"><a href="#静态方法-Array-直接调用的方法" class="headerlink" title="静态方法(Array 直接调用的方法)"></a>静态方法(Array 直接调用的方法)</h2><ul><li>from 方法：可以将一个伪数组转换为真数组<ul><li>使用：Array.from 方法(arguments)</li></ul></li><li>isArray 方法：判断一个给定的数据，是否为一个真数组<ul><li>使用：Array.isArray(arguments)</li></ul></li><li>of 方法：类似于中括号创建数组，依次赋予数组每一项的值<ul><li>使用：Array.of(1,2,3) == [1,2,3]</li></ul></li></ul><h2 id="实例方法-数组对象调用的方法"><a href="#实例方法-数组对象调用的方法" class="headerlink" title="实例方法(数组对象调用的方法)"></a>实例方法(数组对象调用的方法)</h2><ul><li>push(数据) //从数组最后一位添加数据(可添加多个)，并返回组长度</li><li>pop() //删除数组最后一位，并返回此值。(传参无效)</li><li>reverse() //数值反转(传参无效)</li><li>shift() //删除数组的第一位，并返回此值。(传参无效)</li><li>==sort==() //数组升序排列。[可自定义][降序加.reverse()]</li><li>unshift(数据) //在数组的第一位添加数据(可添加多个)，并返数组长度</li><li>fill()：将数组内容全部替换为()里面的内容<ul><li>数组.fill(数据)：将数组的所有项，填充为指定的数据</li><li>数组.fill(数据, 开始下标): 将数组从开始下标起，到数组的末尾，填充为指定的数据</li><li>数组.fill(数组, 开始下标，结束下标): 将数组从开始下标起，到数组的结束下标（取不到），填充为指定的数据</li></ul></li><li>==splice==() //切除数据[及添加新数据]。(从第几位开始，截取长度，在切口处添加新的数据)，返回被切除的数据。</li></ul><h3 id="纯函数，无副作用方法（不改变原数组）"><a href="#纯函数，无副作用方法（不改变原数组）" class="headerlink" title="纯函数，无副作用方法（不改变原数组）"></a>纯函数，无副作用方法（不改变原数组）</h3><ul><li>concat：把另一个数组拼接到数组<ul><li>使用：var newArr = arr1.concat(arr2,arr3)</li></ul></li><li>includes: 数组中是否包含满足条件的元素<ul><li>使用：arr.includes(查找数据[,开始查找的坐标])，返回布尔值</li></ul></li><li>join：可以把数组连成一个字符串<ul><li>arr.join(“-“)：”1-2-3”。默认’,’连接</li></ul></li><li>toString()//把数组转化成字符串<ul><li>使用:arr.toString(),”1,2,3”</li></ul></li><li>split：把字符串按传参拆分成一个数组。<ul><li>使用：str.split(‘-‘)：[“1”,”2”,”3”]</li></ul></li><li>**arr.indexOf(x)**，判断数组是否存在 x,若存在返回 x 在 arr 中的位置，没有则返回-1</li><li>arr.contains(‘xx’) 判断集合中是否含有 xx</li><li>slice() //截取 arr.slice(开始的坐标,结束的坐标) ，返回截取内容<ul><li>arr.slice() :空截，可以把类数组转换为数组</li><li>可以写负数</li><li>不写结束下标默认到末尾</li></ul></li><li>indexOf 传入数组数据，找到返回坐标，找不到返回-1</li><li>lastIndexOf(数据) 找到最后一个匹配的下标</li><li>forEach: 遍历数组<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr.forEach(function(item,index,arr)&#123;</span><br><span class="line">    &#x2F;&#x2F;分别是 数组项，下标，数组本身</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li>every：是否所有元素都满足条件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr.every(function(item,index,arr)&#123;</span><br><span class="line">    return item &gt; 100;&#x2F;&#x2F;如果所有项都满足条件返回true</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li>some：是否至少有一个元素满足条件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr.every(function(item,index,arr)&#123;</span><br><span class="line">    return item &gt; 100;&#x2F;&#x2F;如果所有项都满足条件返回true</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><ul><li>filter：过滤，得到满足条件的元素组成的新数组<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr.filter(function(item)&#123;</span><br><span class="line">    return item&gt;100;&#x2F;&#x2F;返回所有满足条件的项组成的数组</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li>find: 查找第一个满足条件的元素，返回元素本身，如果没有找到，返回 undefined<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var arr[&#123;xxx:60&#125;,&#123;xxx:60&#125;];</span><br><span class="line">arr.find(function(item)&#123;</span><br><span class="line">    return item.score &gt;&#x3D; 60;&#x2F;&#x2F;返回满足条件的item</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li>findIndex: 查找第一个满足条件的元素，返回元素的下标<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr.findIndex(function(item)&#123;</span><br><span class="line">    return item.score &gt;&#x3D; 60;</span><br><span class="line">    &#x2F;&#x2F;返回第一个满足条件的元素下标。这种实现indexOf无法办到</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li>map：映射，将数组的每一项映射称为另外一项<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;得到一个新数组，新数组的每一项是一个对象</span><br><span class="line">&#x2F;&#x2F;对象包含两个属性：name、score</span><br><span class="line">arr.map(function(item,i)&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        name:&quot;学生&quot;+(i+1),</span><br><span class="line">        score:item</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F;得到一个学生的姓名数组</span><br><span class="line">arr.map(function(item)&#123;</span><br><span class="line">    return item.name;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li>reduce：统计，累计<ul><li>执行原理：把数组内的值依次放入函数里，得到的结果为 s，然后继续将 s 和下一个值进行计算</li><li>如果数组只有一个参数，此函数不会运行</li><li>如果没有参数，此函数会报错</li><li>可以加初始值处理上面的问题 arr.reduce(function(s, item){},0)<ul><li>如果不传参不会报错，如果传一个参数会和默认值进行运算<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var sum &#x3D; arr.reduce(function(s, item)&#123;</span><br><span class="line">    return s+item; &#x2F;&#x2F;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li>数组链式编程<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var arr &#x3D; [22,33,44,55,66,77,88];</span><br><span class="line">&#x2F;&#x2F;对数组进行随机排序</span><br><span class="line">&#x2F;&#x2F;只取及格分数</span><br><span class="line">&#x2F;&#x2F;得到学生对象的数组（每个学生对象包含姓名和分数）</span><br><span class="line">var result &#x3D; arr.sort(function()&#123;</span><br><span class="line">    return Math.random() - 0.5;</span><br><span class="line">&#125;).filter(function(item)&#123;</span><br><span class="line">    return item &gt;&#x3D; 60;</span><br><span class="line">&#125;).map(function(item, i)&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        name:&#96;学生&#96;$&#123;i+1&#125;,</span><br><span class="line">        score:item</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(result); &#x2F;&#x2F;返回及格学生数组</span><br></pre></td></tr></table></figure></li><li>一些常见用法：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">splice()常见用法。</span><br><span class="line">var arr &#x3D; [1,2,3,4]</span><br><span class="line">&#x2F;&#x2F;用法1：切除数据</span><br><span class="line">arr.splice(0,1) &#x2F;&#x2F;[2,3,4]</span><br><span class="line">arr.splice(-1,1) &#x2F;&#x2F;[1,2,3]  &#x2F;&#x2F;原理：num +&#x3D; num &gt; 0 ? 0 :this.length;</span><br><span class="line">&#x2F;&#x2F;用法2：更改数据</span><br><span class="line">arr.splice(0,1,9) &#x2F;&#x2F;[9,2,3,4]</span><br><span class="line">&#x2F;&#x2F;用法3：插入数据</span><br><span class="line">arr.splice(0,0,9) &#x2F;&#x2F;[9,1,2,3,4]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;sort()自定义方法（sort()方法预留的接口）</span><br><span class="line">规则：</span><br><span class="line">1.必须写俩形参</span><br><span class="line">2.看返回值，</span><br><span class="line">    (1)返回值为负数时，前面数在前。</span><br><span class="line">    (2)返回值为正数行，后面数在前。</span><br><span class="line">    (3)为0，不动</span><br><span class="line">    arr.sort(function(a,b)&#123;</span><br><span class="line">        &#x2F;&#x2F;里面可以自己写规则。</span><br><span class="line">        &#x2F;&#x2F; return a-b;  升序(冒泡排序)</span><br><span class="line">        &#x2F;&#x2F; return b-a;  降序(冒泡排序)</span><br><span class="line">        return b-a;</span><br><span class="line">    &#125;);</span><br><span class="line">&#x2F;&#x2F; 数组乱序排列</span><br><span class="line">        arr.sort(function() &#123;</span><br><span class="line">            return Math.random() - 0.5;</span><br><span class="line">        &#125;);</span><br><span class="line">&#x2F;&#x2F; 对象数组根据属性排序</span><br><span class="line">    var a1 &#x3D; &#123;</span><br><span class="line">        age: 11</span><br><span class="line">    &#125;</span><br><span class="line">    var a2 &#x3D; &#123;</span><br><span class="line">        age: 18</span><br><span class="line">    &#125;</span><br><span class="line">    var a3 &#x3D; &#123;</span><br><span class="line">        age: 15</span><br><span class="line">    &#125;</span><br><span class="line">    var arr &#x3D; [a1, a2, a3]</span><br><span class="line">    arr.sort(function(a, b) &#123;</span><br><span class="line">        return b.age - a.age</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><h2 id="数组的遍历"><a href="#数组的遍历" class="headerlink" title="数组的遍历"></a>数组的遍历</h2><ul><li><p>方法一：普通 for 循环</p></li><li><p>方法二：for..in..</p><ul><li>for-in 和 for 的区别：for 是遍历下标[可以循环到每一个项]，for-in 是遍历对象属性[循环不到没有值的项]</li></ul></li><li><p>方法二：forEach 循环：arr.forEach(fn)：把数组的每一位都放入函数进行运行</p></li><li><p>for 效率 大于 foreach 原因：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for 循环没有任何额外的函数调用栈和上下文；</span><br><span class="line"></span><br><span class="line">forEach函数签名实际上是</span><br><span class="line"></span><br><span class="line">array.forEach(function(currentValue, index, arr), thisValue)</span><br><span class="line"></span><br><span class="line">它不是普通的 for 循环的语法糖，还有诸多参数和上下文需要在执行的时候考虑进来，这里可能拖慢性能；</span><br></pre></td></tr></table></figure><h2 id="类数组"><a href="#类数组" class="headerlink" title="类数组"></a>类数组</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ol><li>属性要为索引（数字）属性</li><li>必须要有 length 属性</li><li>最好加上 push 方法</li><li>splice 可以让类数组的样子像数组[]</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123;</span><br><span class="line">    &quot;0&quot;: &quot;a&quot;,</span><br><span class="line">    &quot;1&quot;: &quot;b&quot;,</span><br><span class="line">    &quot;2&quot;: &quot;c&quot;,</span><br><span class="line">    name: &quot;du&quot;,</span><br><span class="line">    age: 18,</span><br><span class="line">    length: 3,</span><br><span class="line">    push: Array.prototype.push,</span><br><span class="line">    splice: Array.prototype.splice</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类数组转换为数组的方法"><a href="#类数组转换为数组的方法" class="headerlink" title="类数组转换为数组的方法"></a>类数组转换为数组的方法</h3><ul><li>方法一：Array.from(arguments);。</li><li>方法二：Array.prototype.slice.call(arguments);</li></ul><h3 id="arguments-传入参数列表，一个类数组对象"><a href="#arguments-传入参数列表，一个类数组对象" class="headerlink" title="arguments :传入参数列表，一个类数组对象"></a>arguments :传入参数列表，一个类数组对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function printArgs() &#123;</span><br><span class="line">    console.log(arguments);</span><br><span class="line">&#125;</span><br><span class="line">printArgs(&quot;A&quot;, &quot;a&quot;, 0, &#123; foo: &quot;Hello&quot; &#125;);</span><br><span class="line">执行结果：[&quot;A&quot;, &quot;a&quot;, 0, Object] &#x2F;&#x2F;arguments 是个类数组对象</span><br></pre></td></tr></table></figure><h1 id="try-catch（异常处理）"><a href="#try-catch（异常处理）" class="headerlink" title="try-catch（异常处理）"></a>try-catch（异常处理）</h1><h2 id="写法及属性：name-和-message"><a href="#写法及属性：name-和-message" class="headerlink" title="写法及属性：name 和 message"></a>写法及属性：name 和 message</h2><pre><code> try&#123;    console.log(&quot;a&quot;);&#125;catch(e)&#123;    console.log(e.name + &quot;:&quot; + e.message)&#125;</code></pre><h2 id="Error-name-六种值对应的错误信息："><a href="#Error-name-六种值对应的错误信息：" class="headerlink" title="Error.name 六种值对应的错误信息："></a>Error.name 六种值对应的错误信息：</h2><p>（1）EvalError：eval()的使用与定义不一致 <br><br>解释：这个 eval 是不允许我们用的，如果用了的话他就会显示这个错误信息。 <br><br>（2）RangeError：数值越界 <br><br>解释：这个很少见，以后遇到了会讲的。<br><br>（3）☆ ReferenceError：非法或不能识别的引用数值 <br><br>解释：当一个变量未经声明就使用或者当一个函数未经声明就调用就会显示这个。<br><br>（4）☆ SyntaxtError：发生语法解析错误 <br><br>解释：代码在执行前系统先通篇扫描一遍，如果有低级语法错误就显示这个，<br><br>例如写了一个中文，少写一个括号等等。 <br><br>（5）TypeError：类型操作错误 <br><br>解释：比如说用数组方法操作对象了就会显示这个，后边遇到了再说。 <br><br>（6）URIError：URI 处理函数使用不当 <br><br>解释：引用地址发生错误，后面遇到再说。 <br></p><h2 id="自定义报错信息"><a href="#自定义报错信息" class="headerlink" title="自定义报错信息"></a>自定义报错信息</h2><p>throw new Error(“报错内容”);</p><h1 id="es5-0-严格模式"><a href="#es5-0-严格模式" class="headerlink" title="es5.0 严格模式"></a>es5.0 严格模式</h1><p>当启用 es5.0 严格模式时，es3.0 和 es5.0 产生冲突的部分就使用 es5.0 方法，否则会使用 es3.0 方法</p><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>在 JS 代码最上方写：”use strict”;</p><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><ul><li>全局严格模式：在 js 代码最上方写时，是全局 es5.0 严格模式</li><li>局部函数内严格模式（推荐）：也可以写在方法里面，必须是方法里面的第一行，这样是局部 es5.0 严格模式</li></ul><h2 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h2><ul><li>不支持 with()、arguments.callee、func.caller</li><li>变量赋值前必须声明</li><li>局部 this 必须被赋值（Person.call(null/undefined)赋值什么就是什么）</li><li>拒绝重复属性和参数</li></ul><h1 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>JSON 是一种传输数据的格式（以对象为样板，本质上就是对象，但用途有区别，对象是本地用的，json 是用来传输的）</p><h2 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h2><ul><li>JSON.parse(); string -&gt; json</li><li>JSON.stringify(); json -&gt; string</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123;name:&#39;du&#39;,age:18&#125;;</span><br><span class="line">JSON.parse(obj)   -&gt; json格式</span><br><span class="line">JSON.stringify(obj)   -&gt;string格式</span><br></pre></td></tr></table></figure><h1 id="RegExp-正则表达式"><a href="#RegExp-正则表达式" class="headerlink" title="RegExp 正则表达式"></a>RegExp 正则表达式</h1><h2 id="课前补充"><a href="#课前补充" class="headerlink" title="课前补充"></a>课前补充</h2><ul><li>转义字符：\<ul><li>特殊转义字符：\n、\t、\r(行结束符)</li><li>代码多行字符串换行：\。(代码字符串过长时可以加\换到下一行)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var test &#x3D; &quot;\ &lt;div&gt;&lt;&#x2F;div&gt;\ &lt;span&gt;&lt;&#x2F;span&gt;\ &quot;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><ul><li><p>作用：匹配特殊字符或有特殊搭配原则的字符的最佳选择</p></li><li><p>创建方法</p><ul><li>var reg = /abc/g;</li><li>var reg = new RegExp(“abc”,”g”);</li><li>var reg = new RegExp(reg);</li></ul></li><li><p>常用方法</p><ul><li>reg.text(str); //判断 str 里面是否有符合规则的字符串</li><li>str.match(reg); //返回一个符合规则的字符串数组</li></ul></li><li><p>修饰符</p><ul><li>i -&gt;忽略大小写</li><li>g -&gt;执行全局匹配（查找所有匹配而非找到第一个匹配后停止）</li><li>m -&gt;执行多行匹配</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var reg &#x3D; &#x2F;a&#x2F;g;</span><br><span class="line">var str &#x3D; &#39;abca&#39;;</span><br><span class="line">reg.text(str);&#x2F;&#x2F;true</span><br><span class="line">str.match(reg);&#x2F;&#x2F;[&#39;a&#39;,&#39;a&#39;];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;理解m的作用</span><br><span class="line">var reg &#x3D; &#x2F;^a&#x2F;gm;    ^ -&gt;代表第一个字符是a</span><br><span class="line">var str &#x3D; &#39;abca\nabc&#39;;</span><br><span class="line">str.match(reg);&#x2F;&#x2F;[&#39;a&#39;,&#39;a&#39;];</span><br></pre></td></tr></table></figure></li></ul><h2 id="表达式-用方括号-括起来的就是表达式"><a href="#表达式-用方括号-括起来的就是表达式" class="headerlink" title="表达式(用方括号[]括起来的就是表达式)"></a>表达式(用方括号[]括起来的就是表达式)</h2><p>==注意==：一个表达式代表一位。</p><ul><li>[abc]：查找方括号之间的任何字符。例：[0-9]、[A-z]、[0-9A-z]</li><li>[^abc]：查找任何不在方括号之间的数字，^在==表达式里面==是非的意思</li><li>(abc|bcd)：|是表达式里面的 或，()和数学一样，优先计算</li></ul><h2 id="元字符-和表达式一个东西"><a href="#元字符-和表达式一个东西" class="headerlink" title="元字符(和表达式一个东西)"></a>元字符(和表达式一个东西)</h2><pre><code>+ .  === [^\r\n]：代表一切，除了换行和行结束符+ \w === [0-9A-z_]+ \W === [^\w]+ \d === [0-9]+ \D === [^\d]+ \s === [\n\f\r\t\v ] 查找空白字符+ \S === [^\s]+ \b === 单词边界  &quot;abc def&quot; -&gt; [\babc\b]+ \B === 非单词边界+ \u0000 : 查找以16进制数xxxx规定的Unicode字符（可用于中    文）+ \1 === /(\w)\1\1/ ,反向引用第一个表达式中的值，例：   [&quot;aaa&quot;,&quot;bbb&quot;]+ &quot;aabb&quot;： /(\w)\1(\w)\2/g+ [\d\D]: 类似这样的，代表所有字符</code></pre><h2 id="量词-代表数量的词"><a href="#量词-代表数量的词" class="headerlink" title="量词(代表数量的词)"></a>量词(代表数量的词)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">特点：贪婪匹配原则（能多就多）例：&quot;abc&quot;</span><br><span class="line"></span><br><span class="line">+ n+    :匹配任何包含至少一个n的字符串。  &#x2F;\w+&#x2F;g -&gt; [&quot;abc&quot;]</span><br><span class="line">+ n*    :匹配任何包含零个或多个n的字符串。&#x2F;\d*&#x2F;g -&gt;[&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;]</span><br><span class="line">+ n?    :匹配任何包含零个或一个n的字符。 &#x2F;\w?&#x2F;g -&gt;[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;&quot;]</span><br><span class="line">+ n&#123;X&#125;  :匹配包含X个n的序列的字符串。 &#x2F;\w&#123;3&#125;&#x2F;g  -&gt; [&quot;abc&quot;] :三个三个匹配</span><br><span class="line">+ n&#123;X,Y&#125;:匹配包含X至Y个n的序列的字符串。&#x2F;\w&#123;3,5&#125;&#x2F;g -&gt; [&quot;abc&quot;] : 能5个就不3个，由多向少</span><br><span class="line">+ n&#123;X,&#125; :匹配包含至少X个n的序列的字符串。 &#x2F;\w&#123;3,&#125;&#x2F;g  -&gt;3到正无穷</span><br><span class="line">+ ^n    :以n开头的字符串</span><br><span class="line">+ n$    :以n结尾的字符串   &#x2F;abc$&#x2F;g  -&gt;[&quot;abc&quot;]</span><br><span class="line">+ ?&#x3D;n   :匹配任何其后紧跟字符串n的字符串正向预查（正向）。&#x2F;a(?&#x3D;b)&#x2F;g</span><br><span class="line">+ ?!n   :匹配任何其后没有紧跟字符串n的字符串。&#x2F;a(?!b)&#x2F;g</span><br><span class="line">+ 非贪婪匹配: &#x2F;a+?&#x2F;g、&#x2F;a&#123;1,3&#125;?&#x2F;g... 量词后面加?，(能少就少)。两个??时，能取0不取1。</span><br></pre></td></tr></table></figure><h2 id="RegExp-正则表达式对象属性"><a href="#RegExp-正则表达式对象属性" class="headerlink" title="RegExp 正则表达式对象属性"></a>RegExp 正则表达式对象属性</h2><ul><li>global :RegExp 是否具有标志 g</li><li>ignoreCase:RegExp 是否具有标志 i</li><li>multiline :RegExp 是否具有标志 m</li><li>source :正则表达式的源文本</li><li>==lastIndex :一个整数，标示下一次匹配的字符位置。==</li></ul><h2 id="RegExp-正则表达式对象方法"><a href="#RegExp-正则表达式对象方法" class="headerlink" title="RegExp 正则表达式对象方法"></a>RegExp 正则表达式对象方法</h2><ul><li>comepile :编译正则表达式</li><li>test :检索字符串中指定的值。返回 true 或 false</li><li>==exec：检索字符串中指定的值。返回找到的值，并确定其位置。==</li></ul><p>==注意==：reg.lastIndex 和 reg.exec(str)是相匹配的。<br><br>reg.lastIndex 的值就是 reg.exec(str)下一次的 index 值。<br><br>如果改动 reg.lastIndex 的值，reg.exec(str)下一次的值会跟着改变。</p><h2 id="支持正则表达式的-String-对象的方法"><a href="#支持正则表达式的-String-对象的方法" class="headerlink" title="支持正则表达式的 String 对象的方法"></a>支持正则表达式的 String 对象的方法</h2><ul><li>match ：找到一个或多个正则表达式的匹配</li><li>search ：检索与正则表达式相匹配的值</li><li>split : 按正则表达式拆分</li><li>==replace(a,b)== :a 替换成 b（最常用）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">replace()详解：</span><br><span class="line">小知识点：$可以引用到子表达式。</span><br><span class="line">用法1：</span><br><span class="line">var str&#x3D;&#39;aa&#39;;</span><br><span class="line">str.replace(&#39;a&#39;,&#39;b&#39;);&#x2F;&#x2F;ba</span><br><span class="line"></span><br><span class="line">用法2：</span><br><span class="line">var str&#x3D;&#39;aa&#39;;</span><br><span class="line">var reg&#x3D;&#x2F;a&#x2F;g;</span><br><span class="line">str.replace(reg,&#39;b&#39;);&#x2F;&#x2F;bb</span><br><span class="line"></span><br><span class="line">用法3：</span><br><span class="line">var str&#x3D;&#39;aabb&#39;;</span><br><span class="line">var reg&#x3D;&#x2F;(\w)\1(\w)\2&#x2F;g;</span><br><span class="line">str.replace(reg,&#39;$2$2$1$1&#39;);&#x2F;&#x2F;bbaa</span><br><span class="line"></span><br><span class="line">用法4：高端写法</span><br><span class="line">&#x2F;&#x2F;更灵活：  $属性是系统需要，必须传（名字随便起）</span><br><span class="line">str.replace(reg, function($,$1,$2)&#123;</span><br><span class="line">    return $2+$2+$1+$1;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">练习1：将 the-first-name 转换成 theFirstName</span><br><span class="line"></span><br><span class="line">    var reg &#x3D; &#x2F;-(\w)&#x2F;g;</span><br><span class="line">    var str &#x3D; &#39;the-first-name&#39;</span><br><span class="line">    console.log(str.replace(reg, function($, $1) &#123;</span><br><span class="line">        return $1.toUpperCase();</span><br><span class="line">    &#125;));</span><br><span class="line"></span><br><span class="line">练习2：字符串去重</span><br><span class="line"></span><br><span class="line">    var str&#x3D;&#39;aaaabbcccccd&#39;;</span><br><span class="line">    var reg&#x3D;&#x2F;(\w)\1*&#x2F;g;</span><br><span class="line">    console.log(str.replace(reg,&quot;$1&quot;));</span><br><span class="line"></span><br><span class="line">练习3：给把1000000000转换成100.000.000.000</span><br><span class="line"></span><br><span class="line">    var str &#x3D; &quot;100000000000&quot;;</span><br><span class="line">    var reg &#x3D; &#x2F;(?&#x3D;(\B)(\d&#123;3&#125;)+$)&#x2F;g;</span><br><span class="line">    console.log(str.replace(reg, &quot;.&quot;))</span><br></pre></td></tr></table></figure><h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><h2 id="浏览器常驻线程"><a href="#浏览器常驻线程" class="headerlink" title="浏览器常驻线程"></a>浏览器常驻线程</h2><p>js 引擎线程（解释执行 js 代码、用户输入、网络请求）</p><p>GUI 线程（绘制用户界面，与 js 主线程是互斥的）</p><p>http 网络请求线程（处理用户的 get、post 等请求，等返回结果后将回调函数推入任务队列）</p><p>定时触发器线程（setTimeout、setInterval 等待时间结束后把执行函数推入任务队列）</p><p>浏览器事件处理线程（将 click、mouse 等交互事件发生后讲这些事件放入事件队列中）</p><p><strong>注意：js 引擎线程和 GUI 线程-互斥</strong></p><h2 id="js-执行机制："><a href="#js-执行机制：" class="headerlink" title="js 执行机制："></a>js 执行机制：</h2><pre><code>JavaScript是基于单线程运行，同时又是可以异步执行的。任务进入执行栈--&gt;同步任务还是异步任务        --&gt;同步     -&gt;主线程    -&gt;任务全部执行完毕     -&gt;读取任务队列中的结果，进入主线程执行。        --&gt;异步     -&gt;Event Table   -&gt;Event Queue  -&gt;进入主线程。。。</code></pre><p><img src="http://47.97.6.61/%E6%9C%89%E9%81%93%E4%BA%91%E5%9B%BE%E7%89%87/js%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6.png" alt="js执行机制"></p><h3 id="同步任务"><a href="#同步任务" class="headerlink" title="同步任务"></a>同步任务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function foo(ot)&#123;</span><br><span class="line">    function bar(it)&#123;</span><br><span class="line">        console.log(it);</span><br><span class="line">    &#125;</span><br><span class="line">    bar(20);</span><br><span class="line">    console.log(ot);</span><br><span class="line">&#125;</span><br><span class="line">foo(20);</span><br><span class="line">&#x2F;&#x2F;20  10  先执行外面的，再执行里面的</span><br><span class="line"></span><br><span class="line">0.代码没有被执行的时候，执行栈为空栈。</span><br><span class="line">1.foo函数执行时，创建了一帧，这帧中包含了形参、局部变量（预编译过程）然后把这一帧压入栈中。</span><br><span class="line">2.然后执行foo函数内代码，执行bar函数。</span><br><span class="line">3.创建新帧，同样有形参、局部变量、压入栈中。</span><br><span class="line">4.bar函数执行完毕，弹出栈。</span><br><span class="line">5.foo函数执行完毕，弹出栈。</span><br><span class="line">6.执行栈为空</span><br><span class="line">执行栈其实相当于js主线程</span><br></pre></td></tr></table></figure><h3 id="异步任务"><a href="#异步任务" class="headerlink" title="异步任务"></a>异步任务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    url:&#39;localhost:&#x2F;js&#x2F;demo.json&#39;,</span><br><span class="line">    data:&#123;&#125;,</span><br><span class="line">    success:function(data)&#123;</span><br><span class="line">        console.log(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">Ajax进入Event Table,注册回调函数success</span><br><span class="line">执行console.log(&#39;run&#39;)</span><br><span class="line">ajax时间完成http网络请求线程把任务放入Event Queue中</span><br><span class="line">主线程(调用栈)读取任务下执行auccess函数</span><br></pre></td></tr></table></figure><h1 id="零碎而重要的知识点"><a href="#零碎而重要的知识点" class="headerlink" title="零碎而重要的知识点"></a>零碎而重要的知识点</h1><h2 id="防抖＆-节流"><a href="#防抖＆-节流" class="headerlink" title="防抖＆ 节流"></a>防抖＆ 节流</h2><p>在开发过程中，有一部分的用户行为会频繁的出发时间执行，而对于 DOM 操作、资源加载等耗费性能的处理，很可能造成界面卡顿，甚至浏览器的崩溃。防抖（debounce）和节流（throttle）函数就是为了解决类似需求应运而生的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">防抖：若会多次触发某函数，会在最后一次触发时，1 time 以后执行触发事件。</span><br><span class="line">&#x2F;&#x2F; 封装一个防抖函数（fn,time）</span><br><span class="line">function debounce(handler, delay) &#123;</span><br><span class="line">    var timer &#x3D; null;</span><br><span class="line">    return function() &#123;</span><br><span class="line">        var _self &#x3D; this,</span><br><span class="line">            _arg &#x3D; arguments;</span><br><span class="line">        clearInterval(timer);</span><br><span class="line">        timer &#x3D; setTimeout(function() &#123;</span><br><span class="line">            handler.apply(_self, _arg);</span><br><span class="line">        &#125;, delay);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;直接处理防抖（此处是jq代码，主要看思路）</span><br><span class="line">var timer &#x3D; null;</span><br><span class="line">$(&#39;#search-inp&#39;).on(&#39;input&#39;, function() &#123;</span><br><span class="line">    var val &#x3D; $(this).val();</span><br><span class="line">    clearTimeout(timer);</span><br><span class="line">    if (val) &#123;</span><br><span class="line">        timer &#x3D; setTimeout(function() &#123;</span><br><span class="line">            getData(val);</span><br><span class="line">        &#125;, 500)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">节流：若连续多次触发某事件，在每个等待时间内只执行一次事件</span><br><span class="line">        &#x2F;&#x2F; 封装一个节流函数（throttle）(fn,等待时间)</span><br><span class="line">        function throttle(handler, wait) &#123;</span><br><span class="line">            var lastTime &#x3D; 0;</span><br><span class="line">            return function(e) &#123;</span><br><span class="line">                var nowTime &#x3D; new Date().getTime();</span><br><span class="line">                if (nowTime - lastTime &gt; wait) &#123;</span><br><span class="line">                    handler.apply(this, arguments);</span><br><span class="line">                    lastTime &#x3D; nowTime;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h2 id="异步加载-JS"><a href="#异步加载-JS" class="headerlink" title="==异步加载 JS=="></a>==异步加载 JS==</h2><ul><li>js 加载的缺点：加载工具包没必要阻塞文档，使得 js 加载影响页面效率，一旦网速不好，那么整个页面将等待 js 加载而不进行后续渲染等工作。</li><li>有些工具方法需要按需加载，用到在加载，不用不加载。</li></ul><h3 id="异步加载-JS-三种实现方法"><a href="#异步加载-JS-三种实现方法" class="headerlink" title="异步加载 JS 三种实现方法"></a>异步加载 JS 三种实现方法</h3><ul><li>1.defer 异步加载，但要等到 dom 文档全部解析完后才会被执行，只有 IE 能用，可以将代码写入内部。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head --&gt;  &lt;script type....  defer &#x3D; &quot;defer&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><ul><li>2.async 异步加载，加载完就执行，async 只能加载外部脚本，不能将 js 写在 js 块里面。使用方法同上。<ul><li>W3C 标准，加载完立即执行。IE9 以下不兼容</li></ul></li><li>3.==动态加载 JS（最常用）==：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;在js代码中动态加载外部js文件</span><br><span class="line">var script&#x3D;document.createElement(&#39;script&#39;);</span><br><span class="line">script.type&#x3D;&quot;text&#x2F;javascript&quot;;</span><br><span class="line">script.src&#x3D;&quot;demo.js&quot;;</span><br><span class="line">&lt;!--当添加到页面里后执行--&gt;</span><br><span class="line">document.head.appendChild(script);</span><br><span class="line">注意：添加到页面后js文件可能还没下载完成，所以直接调用文件里面的方法会报错。</span><br><span class="line">      这时就用到load事件(等文件加载完成后执行,IE不支持 )。</span><br><span class="line">script.onload &#x3D; function()&#123;</span><br><span class="line">        test();</span><br><span class="line">    &#125;</span><br><span class="line">注意：ie支持方法：readystatechange事件(当readyState状态码发生改变时触发此事件)</span><br><span class="line"> script.onreadystatechange &#x3D; function()&#123;</span><br><span class="line">        if(script.readState &#x3D;&#x3D; &quot;complete&quot;||script.readyState &#x3D;&#x3D; &quot;loaded&quot;)&#123;</span><br><span class="line">            test();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>封装一个异步加载函数</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;封装一个异步加载方法(最终)，可根据实际情况更改（js文件路径，执行方法)</span><br><span class="line">第一种：放一个匿名函数。</span><br><span class="line"></span><br><span class="line">    function loadScript(url, callback) &#123;</span><br><span class="line">        var script &#x3D; document.createElement(&quot;script&quot;);</span><br><span class="line">        script.type &#x3D; &quot;text&#x2F;javascript&quot;;</span><br><span class="line">        if (script.readyState) &#123;</span><br><span class="line">            script.onreadystatechange &#x3D; function () &#123;</span><br><span class="line">                if (script.readyState &#x3D;&#x3D; &quot;complete&quot; || script.readyState &#x3D;&#x3D; &quot;loaded&quot;) &#123;</span><br><span class="line">                    callback();&#x2F;&#x2F;备注</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            script.onload &#x3D; function () &#123;</span><br><span class="line">            callback();&#x2F;&#x2F;备注</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;先绑定事件，再进行下载，否则若下载过快，IE事件反应不过来就改变了</span><br><span class="line">        script.src &#x3D; url;</span><br><span class="line">        &#x2F;&#x2F;加入head后开始执行</span><br><span class="line">        document.head.appendChild(script);</span><br><span class="line">    &#125;</span><br><span class="line">    调用：</span><br><span class="line">    loadScript(&quot;index.js&quot;, function () &#123;</span><br><span class="line">        test();</span><br><span class="line">    &#125;);</span><br><span class="line">    调用的时候放一个匿名函数，他是一个引用，</span><br><span class="line">    在解析的时候他也不知道里边装的是啥，</span><br><span class="line">    执行的时候才会看，里边让 test 执行就可以了，按需加载。</span><br><span class="line"></span><br><span class="line">第二种： 需结合js来用(把js的方法放到一个对象中)</span><br><span class="line">    var tools &#x3D;&#123;</span><br><span class="line">        test : function()&#123;</span><br><span class="line">        console.log(&#39;a&#39;);</span><br><span class="line">         &#125;,</span><br><span class="line">         dome : function()&#123;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function loadScripe(url, callback) &#123;</span><br><span class="line">        var script &#x3D; document.createElement(&#39;script&#39;);</span><br><span class="line">        script.type &#x3D; &quot;text&#x2F;javascript&quot;;</span><br><span class="line">        if (script.readyState) &#123;</span><br><span class="line">            script.onreadystatechange &#x3D; function() &#123;</span><br><span class="line">                if (script.readState &#x3D;&#x3D; &quot;complete&quot; || script.readyState &#x3D;&#x3D; &quot;loaded&quot;) &#123;</span><br><span class="line">                    toole[callback]();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            script.onload &#x3D; function() &#123;</span><br><span class="line">                toole[callback]();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        script.src &#x3D; url;</span><br><span class="line">        document.head.appendChild(script);</span><br><span class="line">    &#125;</span><br><span class="line">    调用  ：loadScripe(&#39;demo.js&#39;,&quot;test&quot;);</span><br></pre></td></tr></table></figure><h2 id="时间线（优化程序有用，背过）"><a href="#时间线（优化程序有用，背过）" class="headerlink" title="时间线（优化程序有用，背过）"></a>时间线（优化程序有用，背过）</h2><h3 id="时间线"><a href="#时间线" class="headerlink" title="时间线"></a>时间线</h3><ul><li>1.==<strong>创建 Document 对象</strong>==，开始解析 web 页面。这个阶段==document.readyState = ‘loadding’==。</li><li>2.遇到 link 外部 css，创建线程加载，并继续解析文档。</li><li>3.遇到 script 外部 js,并且没有异步加载，浏览器加载并阻塞，等待 js 加载并执行完该脚本</li><li>4.遇到 script 外部 js,并且==有异步加载==，浏览器==创建线程加载，并继续解析文档==，对 async 属性的脚本，加载完后立即执行。（异步加载禁止使用 document.write())</li><li>5.遇到 img 等，先正常解析 DOM 结构，然后浏览器异步加载 src,并继续解析文档。</li><li>6.==<strong>当文档解析完成</strong>==，==document.readyState = ‘interactive’==。</li><li>7.==<strong>文档解析完成后</strong>==，所有设置有==defer 的脚本会按照顺序执行==。</li><li>8.document 对象触发 DOMContentLoaded 事件，这也标志着程序执行从同步脚本执行阶段，转化为事件驱动阶段。</li><li>9.当所有 adync 的脚本加载并执行后、img 等加载完成后，document.readyState = ‘complete’,==window 对象触发 load 事件==。</li><li>10.从此以异步响应方式处理用户输入、网络事件等。</li></ul><h3 id="小知识点："><a href="#小知识点：" class="headerlink" title="小知识点："></a>小知识点：</h3><pre><code>其实最好的方法就是等文档全部解析完在执行 js&lt;script type=&quot;text/javascript&quot;&gt;document.addEventListener(&quot;DOMContentLoaded&quot;, function () &#123;var div   = document.getElementsByTagName(&quot;div&quot;)[0];console.log(div);&#125;, false)&lt;/script&gt;这样你把 script 写在上边就可以了，千万别用 window.onload，太慢了，他要等文档 全部加载完才执行，假如有 1kb 没下载下来他都不会执行的，而这个 DOMContentLoaded 等文档解析完就执行了，效率是最高的，不过还是建议把 script 写在下面哈!</code></pre><h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器:"></a>定时器:</h2><h3 id="种类"><a href="#种类" class="headerlink" title="种类"></a>种类</h3><ul><li>setInterval: //每多少秒执行一次</li><li>setTimeout ：//多少秒之后执行</li></ul><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><ul><li>var timer = setInterval(function(){},1000);</li><li>var timer = setInterval(“console.log(‘haha’)”,1000);</li></ul><h3 id="执行原理"><a href="#执行原理" class="headerlink" title="执行原理"></a>执行原理</h3><p>setTimeout 的等待时间结束后并不是直接执行的而是先推入浏览器<br>的一个任务队列，<br><br>在同步队列结束后在依次调用任务队列中的任务。<br><br>setTimeout(function(){},0)Js 主线程中的执行栈为空时，0 毫秒实际上也达不到的，<br><br>根据 HTML 标准，最低 4 毫秒。<br><br>setInterval 是每隔一段时间把任务放到 EventQueue 之中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function sleep(time) &#123;</span><br><span class="line">           while (1) &#123;</span><br><span class="line">               console.log(1);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       console.log(&#39;顺序执行&#39;);</span><br><span class="line">       setTimeout(function() &#123;</span><br><span class="line">           console.log(&#39;100毫秒后执行&#39;);</span><br><span class="line">       &#125;, 100)</span><br><span class="line">       sleep(10000)</span><br><span class="line"></span><br><span class="line">   执行到setTimeout的时候，他本身会100毫秒后执行，</span><br><span class="line">   然后在这100毫秒内执行到了死循环，然后setTimeout到时间的时候，</span><br><span class="line">   线程已经被死循环堵住了，所以就执行不了，</span><br></pre></td></tr></table></figure><h2 id="callee、caller"><a href="#callee、caller" class="headerlink" title="callee、caller"></a>callee、caller</h2><p><strong>arguments.callee ：指向自身函数引用，也就是它自己。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var num &#x3D; (function (n) &#123;</span><br><span class="line">    if(n &#x3D;&#x3D; 1)&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return n * arguments.callee(n - 1);</span><br><span class="line">&#125;(20))</span><br><span class="line">此时访问 num 就得到 2432902008176640000，</span><br><span class="line">这里用递归的话，他必须调用自身才可以递归。</span><br><span class="line">但是立即执行函数连名字都没有，</span><br><span class="line">就用 arguments.callee 来表示它自己。</span><br></pre></td></tr></table></figure><p><strong>func.caller</strong></p><p>谁调用的自己，caller 就指向谁。(没什么用)。</p><h2 id="克隆对象"><a href="#克隆对象" class="headerlink" title="克隆对象"></a>克隆对象</h2><pre><code>//遍历对象 for(var prop in obj)//1.判断是不是原始值 typeof()--&gt;object,若不是object，基本就是原始值(可以是null)//2.判断是数组还是对象   toString(推荐)、instanceof、constructor//3.建立相应的数组或对象//4.递归</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;深度克隆对象的方法(被克隆对象，克隆对象)</span><br><span class="line">function deepClone(origin, target) &#123;</span><br><span class="line">        var target &#x3D; target || &#123;&#125;,</span><br><span class="line">            toStr &#x3D; Object.prototype.toString,</span><br><span class="line">            arrStr &#x3D; &quot;[object Array]&quot;;</span><br><span class="line"></span><br><span class="line">        for (var prop in origin) &#123;</span><br><span class="line">            if (origin.hasOwnProperty(prop)) &#123;</span><br><span class="line">                if (origin[prop] !&#x3D;&#x3D; null &amp;&amp; typeof(origin[prop]) &#x3D;&#x3D; &#39;object&#39;) &#123;</span><br><span class="line">                    if (toStr.call(origin[prop]) &#x3D;&#x3D; arrStr) &#123;</span><br><span class="line">                        target[prop] &#x3D; [];</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        target[prop] &#x3D; &#123;&#125;;</span><br><span class="line">                    &#125;</span><br><span class="line">                    deepClone(origin[prop], target[prop]);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    target[prop] &#x3D; origin[prop]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return target;</span><br><span class="line">    &#125;</span><br><span class="line">&#x2F;&#x2F;使用</span><br><span class="line">var a &#x3D; deepClone(obj);</span><br><span class="line">deppClone(obj,a);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;浅克隆:同地址，你改我也改</span><br><span class="line">var obj &#x3D; &#123;name : &quot;du&quot; &#125;</span><br><span class="line">var obj1 &#x3D; &#123;&#125;</span><br><span class="line">for(var prop in obj)&#123;</span><br><span class="line">    obj1[prop] &#x3D; obj&#123;prop&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现链式调用"><a href="#实现链式调用" class="headerlink" title="实现链式调用"></a>实现链式调用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var du &#x3D; &#123;</span><br><span class="line">    a1 : function()&#123;</span><br><span class="line">        console.log(&#39;a1..........&#39;);</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line">    a2 : function()&#123;</span><br><span class="line">        console.log(&#39;a2..........&#39;);</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line">    a3 : function()&#123;</span><br><span class="line">        console.log(&#39;a3..........&#39;);</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;调用</span><br><span class="line">        du.a1().a2().a3();</span><br><span class="line">解释：如果不return this;的话，隐式返回undefined;也就无法调用后面的方法。</span><br></pre></td></tr></table></figure><h2 id="属性表示方法（两种）"><a href="#属性表示方法（两种）" class="headerlink" title="属性表示方法（两种）"></a>属性表示方法（两种）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">obj.name  --&gt;  obj[&#39;name&#39;]</span><br><span class="line"></span><br><span class="line">var du &#x3D; &#123;</span><br><span class="line">    wife1 : &#123;name : &quot;小王&quot;&#125;，</span><br><span class="line">    wife2 : &#123;name : &quot;小杜&quot;&#125;，</span><br><span class="line">    wife3 : &#123;name : &quot;小刘&quot;&#125;，</span><br><span class="line">    wife4 : &#123;name : &quot;小张&quot;&#125;，</span><br><span class="line">    sayWife : function (num)&#123;</span><br><span class="line">        return this[&#39;wife&#39;+num];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;调用</span><br><span class="line">du.sayWife(2);</span><br></pre></td></tr></table></figure><h2 id="字符串和数字之间的比较大小"><a href="#字符串和数字之间的比较大小" class="headerlink" title="字符串和数字之间的比较大小=="></a>字符串和数字之间的比较大小==</h2><pre><code>&quot;10&quot;&gt;9   字符串和数字比较会先把字符串转成数字&quot;10&quot;&lt;&quot;9&quot;  两个字符串比较会从前往后比较ascii码值。一位不同即出结果。</code></pre><h2 id="属性的可配置性和不可配置性"><a href="#属性的可配置性和不可配置性" class="headerlink" title="属性的可配置性和不可配置性"></a>属性的可配置性和不可配置性</h2><p>在全局 window 里，一旦经历了 var 的操作所得出的属性，这种属性叫做不可配置的属性，不可配置的属性，delete 不掉。</p><h2 id="引用值的类型转换"><a href="#引用值的类型转换" class="headerlink" title="引用值的类型转换"></a>引用值的类型转换</h2><p>引用值的类型转换比较复杂，以后基本用不上，我们不做深入的研究，这里只写几个 特殊的：[] + “”= “”; [] + 1 = “1”; [] – 1 = -1; Number([]) = 0;{} + 1 = 1;Number({}) = NaN;</p><h2 id="with-和-eval-–-gt-不宜使用"><a href="#with-和-eval-–-gt-不宜使用" class="headerlink" title="with() 和 eval() –&gt;不宜使用"></a>with() 和 eval() –&gt;不宜使用</h2><ul><li>with() : 是一种命名空间的用法：效率太低，不宜使用。es5.0 不允许使用</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function c()&#123;</span><br><span class="line">    name : &quot;li&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    function a()&#123;</span><br><span class="line">        name : &quot;du&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    with(c)&#123;</span><br><span class="line">        console.log(name);&#x2F;&#x2F;li</span><br><span class="line">    &#125;</span><br><span class="line">    with(a)&#123;</span><br><span class="line">        console.log(name);&#x2F;&#x2F;du</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>eval() ：有性能和安全性的问题，并且使得代码更难阅读。es3.0 就不推荐使用，es5.0 不允许使用</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;可以把eval()里面的字符串当做代码来使用</span><br><span class="line">eval(&quot;console.log(&#39;hello&#39;)&quot;);</span><br></pre></td></tr></table></figure><h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h2><pre><code>作用：改变this指向。bind()把一个函数改变this指向，然后返回一个新的函数。不改变原函数。和call、apply的区别：前者是直接使用的，bind是在某个事件触发时执行时使用，他是返回一个函数等待你去执行。使用：fn.bind(obj,参数)</code></pre><p>题目 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">    list&#x3D;&#123;</span><br><span class="line">        init:function()&#123;</span><br><span class="line">            this.ms&#x3D;&#39;duyi&#39;;</span><br><span class="line">            this.dom&#x3D;document.getElementById(&#39;btn&#39;);</span><br><span class="line">            this.bindEvent();</span><br><span class="line">        &#125;,</span><br><span class="line">        bindEvent:function()&#123;</span><br><span class="line">            this.dom.onclick&#x3D;this.showMessage.bind(this,&#39;hello&#39;,&#39;world&#39;);</span><br><span class="line">        &#125;,</span><br><span class="line">        showMessage:function(info1,info2)&#123;</span><br><span class="line">            console.log(this.ms,info1,info2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    list.init();</span><br><span class="line">题目2:</span><br><span class="line">    var x&#x3D;10;</span><br><span class="line">    function show(a,b)&#123;</span><br><span class="line">        console.log(this.x,a,b);</span><br><span class="line">    &#125;</span><br><span class="line">    show(&#39;a&#39;,&#39;b&#39;);&#x2F;&#x2F;10 &#39;a&#39; &#39;b&#39;</span><br><span class="line">    var Duyi&#x3D;&#123;</span><br><span class="line">        x:20</span><br><span class="line">    &#125;</span><br><span class="line">    var newShow&#x3D;show.bind(Duyi,&#39;c&#39;,&#39;d&#39;);</span><br><span class="line">    newShow();&#x2F;&#x2F;20 &#39;c&#39; &#39;d&#39;</span><br><span class="line">    &#x2F;&#x2F;若:</span><br><span class="line">    var newShow&#x3D;show.bind(Duyi,&#39;c&#39;);</span><br><span class="line">    newShow(&#39;d&#39;);&#x2F;&#x2F;20 &#39;c&#39; &#39;d&#39;</span><br></pre></td></tr></table></figure><pre><code>bind总结：1.函数A调用bind方法时，需要传递参数o、x、y、z......2.返回新的函数。3.函数B在执行的时候，具体的功能实际上还是使用A，只不过this指向了o4.函数B在执行的时候，传递的参数，会拼接到x,y,z后面，一并在内部传递给A执行5.new B();  构造函数依旧是A，而且o不会起到任何作用</code></pre><h2 id="属性和特性"><a href="#属性和特性" class="headerlink" title="属性和特性"></a>属性和特性</h2><p>特性：type value id class（也是属性的一部分，本身就有的）<br>属性：data …(自定义的)</p><p>特性：就是存在映射关系的属性，与标签一一映射。存在映射关系。<br>属性：无法直接通过 div.data 的方式获取和更改。与标签不存在映射关系。<br><br><br>==<strong>涉及方法：setAttribute() getAttribute()</strong>==<br><br>==<strong>dataset.xxx 可以读写 data-xxx 上的属性</strong>==<br><br>==总结==：<br></p><ol><li>存在映射关系的属性，用.xxx 来读写</li><li>不存在映射关系的属性，用 setAttribute()、getAttribute()来读写</li></ol><h2 id="预加载-amp-懒加载"><a href="#预加载-amp-懒加载" class="headerlink" title="预加载&amp;懒加载"></a>预加载&amp;懒加载</h2><h3 id="预加载"><a href="#预加载" class="headerlink" title="预加载"></a>预加载</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 预加载,图片显示之前，先加载出来。</span><br><span class="line">     var oImg &#x3D; new Image();</span><br><span class="line">     oImg.src &#x3D; &#39;https:&#x2F;&#x2F;www.baidu.com&#x2F;img&#x2F;bd_logo1.png&#39;;</span><br><span class="line">     oImg.onload &#x3D; function() &#123;</span><br><span class="line">             var oDiv &#x3D; document.getElementById(&#39;demo&#39;);</span><br><span class="line">             oDiv.appendChild(this);</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure><h3 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h3><ul><li>==懒加载==：先加载所看到的内容，后面区域按需加载。(有 demo)</li><li>元素属性值：==offsetTop==：元素到页面顶部的距离。</li></ul><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">+ 懒加载</span><br><span class="line">+ 懒加载实现原理：</span><br><span class="line">    - 当window.innerHeight+window.pageYoffset &#x3D;&#x3D; div.offsetTop时，就代表元素到达了位置，</span><br><span class="line">简单来说就是当前页面到文档顶部的距离+窗口高度&#x3D;元素offsetTop相等时，就执行懒加载。</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        body &#123;</span><br><span class="line">            height: 3000px;</span><br><span class="line">        &#125;</span><br><span class="line">        div &#123;</span><br><span class="line">            width: 100px;</span><br><span class="line">            height: 100px;</span><br><span class="line">            position: absolute;</span><br><span class="line">            top: 1500px;</span><br><span class="line">            background-color: red;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;&#x2F;style&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;demo&quot; style&#x3D;&quot;opacity: 0.3;&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        &#x2F;&#x2F; 懒加载</span><br><span class="line">        function check(_id) &#123;</span><br><span class="line">            var oDiv &#x3D; document.getElementById(_id);</span><br><span class="line">            if (oDiv.offsetTop &lt;&#x3D; window.pageYOffset + window.innerHeight) &#123;</span><br><span class="line">                oDiv.timer &#x3D; setInterval(function() &#123;</span><br><span class="line">                    if (oDiv.style.opacity &#x3D;&#x3D; &#39;1&#39;) &#123;</span><br><span class="line">                        clearInterval(oDiv.timer);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        oDiv.style.opacity &#x3D; parseFloat(oDiv.style.opacity) + 0.01;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, 60);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        window.onscroll &#x3D; function() &#123;</span><br><span class="line">            check(&#39;demo&#39;);</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure><h2 id="详解-文档碎片-虚拟-DOM"><a href="#详解-文档碎片-虚拟-DOM" class="headerlink" title="详解-文档碎片-虚拟 DOM"></a>详解-文档碎片-虚拟 DOM</h2><ul><li>文档碎片</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">当频繁添加元素时，可以这么操作，但是并不能实际提升性能。</span><br><span class="line">1.先创建这么一个容器</span><br><span class="line">var oF&#x3D;document.createDocumentFragment();</span><br><span class="line">2.把添加的元素添加到oF</span><br><span class="line">3.最后把oF添加到页面</span><br></pre></td></tr></table></figure><ul><li>字符串拼接，能提升一定的性能(当前推荐使用)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var htmlStr&#x3D;&#39;&lt;ul&gt;xxx&lt;&#x2F;ul&gt;&#39;</span><br></pre></td></tr></table></figure><ul><li>虚拟 DOM。。。</li></ul><h1 id="JavaScript-运动"><a href="#JavaScript-运动" class="headerlink" title="JavaScript 运动"></a>JavaScript 运动</h1><h2 id="01-匀速运动-s-vt"><a href="#01-匀速运动-s-vt" class="headerlink" title="01 匀速运动 s=vt"></a>01 匀速运动 s=vt</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;匀速运动函数  s&#x3D;vt</span><br><span class="line">        function startMove(dom, target) &#123;</span><br><span class="line">            clearInterval(timer);</span><br><span class="line">            var step &#x3D; target - dom.offsetLeft &gt; 0 ? 8 : -8;</span><br><span class="line">            timer &#x3D; setInterval(function() &#123;</span><br><span class="line">                if (Math.abs(target - dom.offsetLeft) &lt; Math.abs(step)) &#123;</span><br><span class="line">                    clearInterval(timer);</span><br><span class="line">                    dom.style.left &#x3D; target + &#39;px&#39;;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    dom.style.left &#x3D; dom.offsetLeft + step + &#39;px&#39;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, 40);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h2 id="02-缓冲运动"><a href="#02-缓冲运动" class="headerlink" title="02 缓冲运动"></a>02 缓冲运动</h2><p>物体的速度距离目标点越近，就越小，当到达目标点的时候 速度减少为 0(悬浮窗 demo)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;缓冲运动 物体的速度，距离目标点越近 就越小</span><br><span class="line">       function startMove(dom, target) &#123;</span><br><span class="line">           clearInterval(timer);</span><br><span class="line">           var step &#x3D; null;</span><br><span class="line">           timer &#x3D; setInterval(function() &#123;</span><br><span class="line">               step &#x3D; (target - dom.offsetLeft) &#x2F; 10;</span><br><span class="line">               step &#x3D; step &gt; 0 ? Math.ceil(step) : Math.floor(step);</span><br><span class="line">               if (dom.offsetLeft &#x3D;&#x3D; target) &#123;</span><br><span class="line">                   clearInterval(timer);</span><br><span class="line">               &#125; else &#123;</span><br><span class="line">                   dom.style.left &#x3D; dom.offsetLeft + step + &#39;px&#39;;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;, 30);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><h2 id="03-多物体运动"><a href="#03-多物体运动" class="headerlink" title="03 多物体运动"></a>03 多物体运动</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;获取元素样式</span><br><span class="line">function getStyle(elem, prop) &#123;</span><br><span class="line">            if (window.getComputedStyle) &#123;</span><br><span class="line">                return window.getComputedStyle(elem, null)[prop];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return elem.currentStyle[prop];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#x2F;&#x2F;多物体运动</span><br><span class="line">    function startMove(dom, target) &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果有定时器就清除</span><br><span class="line">        clearInterval(dom.timer);</span><br><span class="line">        &#x2F;&#x2F; 定义记录当前信息和每次变化值的变量</span><br><span class="line">        var data &#x3D; null,</span><br><span class="line">            step &#x3D; null;</span><br><span class="line">        dom.timer &#x3D; setInterval(function() &#123;</span><br><span class="line">            data &#x3D; parseInt(getStyle(dom, &#39;width&#39;));</span><br><span class="line">            step &#x3D; (target - data) &#x2F; 10;</span><br><span class="line">            step &#x3D; step &gt; 0 ? Math.ceil(step) : Math.floor(step);</span><br><span class="line">            if (data &#x3D;&#x3D; target) &#123;</span><br><span class="line">                clearInterval(timer);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                dom.style.width &#x3D; data + step + &#39;px&#39;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, 30)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="04-多物体不同值运动"><a href="#04-多物体不同值运动" class="headerlink" title="04 多物体不同值运动"></a>04 多物体不同值运动</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;获取元素样式</span><br><span class="line">function getStyle(elem, prop) &#123;</span><br><span class="line">           if (window.getComputedStyle) &#123;</span><br><span class="line">               return window.getComputedStyle(elem, null)[prop];</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               return elem.currentStyle[prop];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#x2F;&#x2F; 多物体不同值运动</span><br><span class="line">       function startMove(dom, attr, target) &#123;</span><br><span class="line">           clearInterval(dom.timer);</span><br><span class="line">           var step &#x3D; null;</span><br><span class="line">           var data &#x3D; null;</span><br><span class="line">           dom.timer &#x3D; setInterval(function() &#123;</span><br><span class="line">               if (attr &#x3D;&#x3D; &#39;opacity&#39;) &#123;</span><br><span class="line">                   data &#x3D; parseFloat(getStyle(dom, attr)) * 100;</span><br><span class="line">               &#125; else &#123;</span><br><span class="line">                   data &#x3D; parseInt(getStyle(dom, attr));</span><br><span class="line">               &#125;</span><br><span class="line">               step &#x3D; (target - data) &#x2F; 10;</span><br><span class="line">               step &#x3D; step &gt; 0 ? Math.ceil(step) : Math.floor(step);</span><br><span class="line">               if (data &#x3D;&#x3D; target) &#123;</span><br><span class="line">                   clearInterval(dom.timer);</span><br><span class="line">               &#125; else &#123;</span><br><span class="line">                   if (attr &#x3D;&#x3D; &#39;opacity&#39;) &#123;</span><br><span class="line">                       dom.style[attr] &#x3D; (data + step) &#x2F; 100;</span><br><span class="line">                   &#125; else &#123;</span><br><span class="line">                       dom.style[attr] &#x3D; data + step + &#39;px&#39;;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;, 30);</span><br></pre></td></tr></table></figure><h2 id="05-多物体多值运动-回调机制"><a href="#05-多物体多值运动-回调机制" class="headerlink" title="05 多物体多值运动+回调机制"></a>05 多物体多值运动+回调机制</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;获取元素样式</span><br><span class="line">function getStyle(elem, prop) &#123;</span><br><span class="line">            if (window.getComputedStyle) &#123;</span><br><span class="line">                return window.getComputedStyle(elem, null)[prop];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return elem.currentStyle[prop];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 多物体多值运动</span><br><span class="line">        function startMove(dom, attrObj, callback) &#123;</span><br><span class="line">            clearInterval(dom.timer);</span><br><span class="line">            var step &#x3D; null,</span><br><span class="line">                data &#x3D; null;</span><br><span class="line">            dom.timer &#x3D; setInterval(function() &#123;</span><br><span class="line">                var stop &#x3D; true;</span><br><span class="line">                for (var attr in attrObj) &#123;</span><br><span class="line">                    if (attr &#x3D;&#x3D; &#39;opacity&#39;) &#123;</span><br><span class="line">                        data &#x3D; parseFloat(getStyle(dom, attr)) * 100;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        data &#x3D; parseInt(getStyle(dom, attr));</span><br><span class="line">                    &#125;</span><br><span class="line">                    step &#x3D; (attrObj[attr] - data) &#x2F; 10;</span><br><span class="line">                    step &#x3D; step &gt; 0 ? Math.ceil(step) : Math.floor(step);</span><br><span class="line">                    if (attr &#x3D;&#x3D; &#39;opacity&#39;) &#123;</span><br><span class="line">                        dom.style[attr] &#x3D; (data + step) &#x2F; 100;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        dom.style[attr] &#x3D; data + step + &#39;px&#39;;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (data !&#x3D; attrObj[attr]) &#123;</span><br><span class="line">                        stop &#x3D; false;</span><br><span class="line">                        console.log(attr);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (stop) &#123;</span><br><span class="line">                    clearInterval(dom.timer);</span><br><span class="line">                    typeof(callback) &#x3D;&#x3D; &#39;function&#39; &amp;&amp; callback();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, 30);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        调用：</span><br><span class="line">           startMove(div, &#123;</span><br><span class="line">                width: 100,</span><br><span class="line">                height: 100,</span><br><span class="line">                left: 500,</span><br><span class="line">                top: 100,</span><br><span class="line">                opacity: 100</span><br><span class="line">            &#125;,function()&#123;&#125;);</span><br></pre></td></tr></table></figure><h2 id="01-加速度运动"><a href="#01-加速度运动" class="headerlink" title="01 加速度运动"></a>01 加速度运动</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 加速度不变的加速运动，运动方向是向右</span><br><span class="line">     &#x2F;&#x2F; 加速度不变的减速运动，运动方向是向左</span><br><span class="line"> function startMove(dom) &#123;</span><br><span class="line">     clearInterval(dom.timer);</span><br><span class="line">     var a &#x3D; 2;&#x2F;&#x2F;负数就是减速</span><br><span class="line">     var step &#x3D; 20;</span><br><span class="line">     dom.timer &#x3D; setInterval(function() &#123;</span><br><span class="line">         step &#x3D; step + a;</span><br><span class="line">         dom.style.left &#x3D; dom.offsetLeft + step + &#39;px&#39;;</span><br><span class="line">     &#125;, 30)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="02-弹性运动"><a href="#02-弹性运动" class="headerlink" title="02 弹性运动"></a>02 弹性运动</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;弹性运动  位置-&gt;力-&gt;速度</span><br><span class="line"> function startMove(dom, target) &#123;</span><br><span class="line">     clearInterval(dom.timer);</span><br><span class="line">     &#x2F;&#x2F;正 -&gt;  反 &lt;-</span><br><span class="line">     var a &#x3D; 3;</span><br><span class="line">     var step &#x3D; 0;</span><br><span class="line">     dom.timer &#x3D; setInterval(function() &#123;</span><br><span class="line">         a &#x3D; (target - dom.offsetLeft) &#x2F; 5;</span><br><span class="line">         step +&#x3D; a;</span><br><span class="line">         step *&#x3D; 0.8;</span><br><span class="line">         &#x2F;&#x2F;近似绝对值少于1时，速度设置为0，</span><br><span class="line">         if (Math.abs(step) &lt; 1 &amp;&amp; (Math.abs(target - dom.offsetLeft) &lt; 1)) &#123;</span><br><span class="line">             clearInterval(dom.timer);</span><br><span class="line">             dom.style.left &#x3D; target + &#39;px&#39;;</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">             dom.style.left &#x3D; dom.offsetLeft + step + &#39;px&#39;;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;, 30);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="03-弹性运动-demo"><a href="#03-弹性运动-demo" class="headerlink" title="03 弹性运动 demo"></a>03 弹性运动 demo</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        * &#123;</span><br><span class="line">            margin: 0;</span><br><span class="line">            padding: 0;</span><br><span class="line">        &#125;</span><br><span class="line">        ul &#123;</span><br><span class="line">            list-style: none;</span><br><span class="line">            margin: 0 auto;</span><br><span class="line">            width: 400px;</span><br><span class="line">            position: relative;</span><br><span class="line">        &#125;</span><br><span class="line">        li &#123;</span><br><span class="line">            text-align: center;</span><br><span class="line">            border: 1px solid black;</span><br><span class="line">            float: left;</span><br><span class="line">            width: 98px;</span><br><span class="line">            height: 98px;</span><br><span class="line">            background-color: orange;</span><br><span class="line">        &#125;</span><br><span class="line">        .bg &#123;</span><br><span class="line">            position: absolute;</span><br><span class="line">            background-color: #f00;</span><br><span class="line">            opacity: 0.5;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;&#x2F;style&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">        &lt;li class&#x3D;&quot;ele&quot;&gt;li1&lt;&#x2F;li&gt;</span><br><span class="line">        &lt;li class&#x3D;&quot;ele&quot;&gt;li2&lt;&#x2F;li&gt;</span><br><span class="line">        &lt;li class&#x3D;&quot;ele&quot;&gt;li3&lt;&#x2F;li&gt;</span><br><span class="line">        &lt;li class&#x3D;&quot;ele&quot;&gt;li4&lt;&#x2F;li&gt;</span><br><span class="line">        &lt;li class&#x3D;&quot;bg&quot;&gt;&lt;&#x2F;li&gt;</span><br><span class="line">    &lt;&#x2F;ul&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        var oLiArray &#x3D; document.getElementsByTagName(&#39;li&#39;);</span><br><span class="line">        var oLiBg &#x3D; oLiArray[oLiArray.length - 1];</span><br><span class="line">        for (var i &#x3D; 0; i &lt; oLiArray.length - 1; i++) &#123;</span><br><span class="line">            oLiArray[i].onmouseenter &#x3D; function() &#123;</span><br><span class="line">                startMove(oLiBg, this.offsetLeft);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;弹性运动  位置-&gt;力-&gt;速度</span><br><span class="line">        function startMove(dom, target) &#123;</span><br><span class="line">            clearInterval(dom.timer);</span><br><span class="line">            &#x2F;&#x2F;正 -&gt;  反 &lt;-</span><br><span class="line">            var a &#x3D; 3;</span><br><span class="line">            var step &#x3D; 0;</span><br><span class="line">            dom.timer &#x3D; setInterval(function() &#123;</span><br><span class="line">                a &#x3D; (target - dom.offsetLeft) &#x2F; 5;</span><br><span class="line">                step +&#x3D; a;</span><br><span class="line">                step *&#x3D; 0.8;</span><br><span class="line">                &#x2F;&#x2F;近似绝对值少于1时，速度设置为0，</span><br><span class="line">                if (Math.abs(step) &lt; 1 &amp;&amp; (Math.abs(target - dom.offsetLeft) &lt; 1)) &#123;</span><br><span class="line">                    clearInterval(dom.timer);</span><br><span class="line">                    dom.style.left &#x3D; target + &#39;px&#39;;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    dom.style.left &#x3D; dom.offsetLeft + step + &#39;px&#39;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, 30);</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><h2 id="04-模拟重力场"><a href="#04-模拟重力场" class="headerlink" title="04 模拟重力场"></a>04 模拟重力场</h2><p>多方向运动+碰撞检测+重力加速度+能量损失</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">有demo</span><br><span class="line">  function startMove(dom) &#123;</span><br><span class="line">            clearInterval(dom.timer);</span><br><span class="line">            var stepX &#x3D; 6;</span><br><span class="line">            var stepY &#x3D; 8;</span><br><span class="line">            var g &#x3D; 3; &#x2F;&#x2F;重力加速度</span><br><span class="line">            dom.timer &#x3D; setInterval(function() &#123;</span><br><span class="line">                stepY +&#x3D; g;</span><br><span class="line">                var newTop &#x3D; dom.offsetTop + stepY;</span><br><span class="line">                var newLeft &#x3D; dom.offsetLeft + stepX;</span><br><span class="line">                &#x2F;&#x2F; 墙壁判断</span><br><span class="line">                if (newTop &gt;&#x3D; document.documentElement.clientHeight - dom.clientHeight) &#123;</span><br><span class="line">                    stepY *&#x3D; -1;</span><br><span class="line">                    &#x2F;&#x2F; 碰撞损耗</span><br><span class="line">                    stepY *&#x3D; 0.8;</span><br><span class="line">                    stepX *&#x3D; 0.8;</span><br><span class="line">                    newTop &#x3D; document.documentElement.clientHeight - dom.clientHeight;</span><br><span class="line">                &#125;</span><br><span class="line">                if (newTop &lt;&#x3D; 0) &#123;</span><br><span class="line">                    stepY *&#x3D; -1;</span><br><span class="line">                    stepY *&#x3D; 0.8;</span><br><span class="line">                    stepX *&#x3D; 0.8;</span><br><span class="line">                    newTop &#x3D; 0;</span><br><span class="line">                &#125;</span><br><span class="line">                if (newLeft &gt;&#x3D; document.documentElement.clientWidth - dom.clientWidth) &#123;</span><br><span class="line">                    stepX *&#x3D; -1;</span><br><span class="line">                    stepY *&#x3D; 0.8;</span><br><span class="line">                    stepX *&#x3D; 0.8;</span><br><span class="line">                    newLeft &#x3D; document.documentElement.clientWidth - dom.clientWidth;</span><br><span class="line">                &#125;</span><br><span class="line">                if (newLeft &lt;&#x3D; 0) &#123;</span><br><span class="line">                    stepX *&#x3D; -1;</span><br><span class="line">                    stepY *&#x3D; 0.8;</span><br><span class="line">                    stepX *&#x3D; 0.8;</span><br><span class="line">                    newLeft &#x3D; 0;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (Math.abs(stepX) &lt; 1) &#123;</span><br><span class="line">                    stepX &#x3D; 0;</span><br><span class="line">                &#125;</span><br><span class="line">                if (Math.abs(stepY) &lt; 1) &#123;</span><br><span class="line">                    stepY &#x3D; 0;</span><br><span class="line">                &#125;</span><br><span class="line">                if (stepX &#x3D;&#x3D; 0 &amp;&amp; stepY &#x3D;&#x3D; 0 &amp;&amp; newTop &#x3D;&#x3D; document.documentElement.clientHeight - dom.clientHeight) &#123;</span><br><span class="line">                    clearInterval(dom.timer);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    dom.style.top &#x3D; newTop + &#39;px&#39;;</span><br><span class="line">                    dom.style.left &#x3D; newLeft + &#39;px&#39;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, 30)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h2 id="05-拖拽实例"><a href="#05-拖拽实例" class="headerlink" title="05 拖拽实例"></a>05 拖拽实例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;</span><br><span class="line">    &lt;title&gt;拖拽实例&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        div &#123;</span><br><span class="line">            width: 100px;</span><br><span class="line">            height: 100px;</span><br><span class="line">            position: absolute;</span><br><span class="line">            background-color: red;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;&#x2F;style&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        var domDiv &#x3D; document.getElementsByTagName(&#39;div&#39;)[0];</span><br><span class="line">        domDiv.onmousedown &#x3D; function(e) &#123;</span><br><span class="line">            clearInterval(this.timer);</span><br><span class="line">            var e &#x3D; e || window.event;</span><br><span class="line">            &#x2F;&#x2F;鼠标到元素边框距离</span><br><span class="line">            var disX &#x3D; e.clientX - this.offsetLeft;</span><br><span class="line">            var disY &#x3D; e.clientY - this.offsetTop;</span><br><span class="line">            &#x2F;&#x2F;保存自己</span><br><span class="line">            var self &#x3D; this;</span><br><span class="line">            &#x2F;&#x2F;记录上一个X、Y值</span><br><span class="line">            var lastX &#x3D; 0;</span><br><span class="line">            var lastY &#x3D; 0;</span><br><span class="line">            &#x2F;&#x2F;记录速度</span><br><span class="line">            var stepX &#x3D; 0;</span><br><span class="line">            var stepY &#x3D; 0;</span><br><span class="line">            document.onmousemove &#x3D; function(e) &#123;</span><br><span class="line">                var e &#x3D; e || window.event;</span><br><span class="line">                &#x2F;&#x2F;最新的点：鼠标位置-鼠标距离元素边框</span><br><span class="line">                var newLeft &#x3D; e.clientX - disX;</span><br><span class="line">                var newTop &#x3D; e.clientY - disY;</span><br><span class="line">                &#x2F;&#x2F; 速度：最新点-上一个点</span><br><span class="line">                stepX &#x3D; newLeft - lastX;</span><br><span class="line">                stepY &#x3D; newTop - lastY;</span><br><span class="line">                &#x2F;&#x2F; 最新的点 &#x3D;&#x3D; 新的上一个点</span><br><span class="line">                lastX &#x3D; newLeft;</span><br><span class="line">                lastY &#x3D; newTop;</span><br><span class="line">                &#x2F;&#x2F;把最新的点赋值</span><br><span class="line">                self.style.left &#x3D; newLeft + &#39;px&#39;;</span><br><span class="line">                self.style.top &#x3D; newTop + &#39;px&#39;;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 等到松手</span><br><span class="line">            document.onmouseup &#x3D; function() &#123;</span><br><span class="line">                document.onmouseup &#x3D; null;</span><br><span class="line">                document.onmousemove &#x3D; null;</span><br><span class="line">                &#x2F;&#x2F;把自己和两个方向的初始速度传进去</span><br><span class="line">                startMove(self, stepX, stepY);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        function startMove(dom, stepX, stepY) &#123;</span><br><span class="line">            clearInterval(dom.timer);</span><br><span class="line">            var g &#x3D; 3; &#x2F;&#x2F;重力加速度</span><br><span class="line">            dom.timer &#x3D; setInterval(function() &#123;</span><br><span class="line">                stepY +&#x3D; g;</span><br><span class="line">                var newTop &#x3D; dom.offsetTop + stepY;</span><br><span class="line">                var newLeft &#x3D; dom.offsetLeft + stepX;</span><br><span class="line">                &#x2F;&#x2F; 墙壁判断</span><br><span class="line">                if (newTop &gt;&#x3D; document.documentElement.clientHeight - dom.clientHeight) &#123;</span><br><span class="line">                    stepY *&#x3D; -1;</span><br><span class="line">                    &#x2F;&#x2F; 碰撞损耗</span><br><span class="line">                    stepY *&#x3D; 0.8;</span><br><span class="line">                    stepX *&#x3D; 0.8;</span><br><span class="line">                    newTop &#x3D; document.documentElement.clientHeight - dom.clientHeight;</span><br><span class="line">                &#125;</span><br><span class="line">                if (newTop &lt;&#x3D; 0) &#123;</span><br><span class="line">                    stepY *&#x3D; -1;</span><br><span class="line">                    stepY *&#x3D; 0.8;</span><br><span class="line">                    stepX *&#x3D; 0.8;</span><br><span class="line">                    newTop &#x3D; 0;</span><br><span class="line">                &#125;</span><br><span class="line">                if (newLeft &gt;&#x3D; document.documentElement.clientWidth - dom.clientWidth) &#123;</span><br><span class="line">                    stepX *&#x3D; -1;</span><br><span class="line">                    stepY *&#x3D; 0.8;</span><br><span class="line">                    stepX *&#x3D; 0.8;</span><br><span class="line">                    newLeft &#x3D; document.documentElement.clientWidth - dom.clientWidth;</span><br><span class="line">                &#125;</span><br><span class="line">                if (newLeft &lt;&#x3D; 0) &#123;</span><br><span class="line">                    stepX *&#x3D; -1;</span><br><span class="line">                    stepY *&#x3D; 0.8;</span><br><span class="line">                    stepX *&#x3D; 0.8;</span><br><span class="line">                    newLeft &#x3D; 0;</span><br><span class="line">                    console.log(&#39;over&#39;);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (Math.abs(stepX) &lt; 1) &#123;</span><br><span class="line">                    stepX &#x3D; 0;</span><br><span class="line">                &#125;</span><br><span class="line">                if (Math.abs(stepY) &lt; 1) &#123;</span><br><span class="line">                    stepY &#x3D; 0;</span><br><span class="line">                &#125;</span><br><span class="line">                if (stepX &#x3D;&#x3D; 0 &amp;&amp; stepY &#x3D;&#x3D; 0 &amp;&amp; newTop &#x3D;&#x3D; document.documentElement.clientHeight - dom.clientHeight) &#123;</span><br><span class="line">                    clearInterval(dom.timer);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    dom.style.top &#x3D; newTop + &#39;px&#39;;</span><br><span class="line">                    dom.style.left &#x3D; newLeft + &#39;px&#39;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, 30)</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 前端 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS3详解</title>
      <link href="2020/09/30/CSS3%E8%AF%A6%E8%A7%A3/"/>
      <url>2020/09/30/CSS3%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="CSS3"><a href="#CSS3" class="headerlink" title="CSS3"></a>CSS3</h1><h2 id="css-属性查找网站"><a href="#css-属性查找网站" class="headerlink" title="css 属性查找网站"></a>css 属性查找网站</h2><p>参考手册：reference manual website: <a href="http://css.doyoe.com/">http://css.doyoe.com</a><br><br>权威网站（实时）：Authoritative inquiry website : <a href="http://www.caniuse.com/">http://www.caniuse.com</a></p><a id="more"></a><h2 id="处理兼容性的插件"><a href="#处理兼容性的插件" class="headerlink" title="处理兼容性的插件"></a>处理兼容性的插件</h2><p>antoprefixer<br><br>写完代码后可以把有兼容性问题的代码自动补齐。（是一种后处理器）</p><h2 id="预处理器和后处理器"><a href="#预处理器和后处理器" class="headerlink" title="预处理器和后处理器"></a>预处理器和后处理器</h2><h3 id="pre-processor（预处理器）"><a href="#pre-processor（预处理器）" class="headerlink" title="pre-processor（预处理器）"></a>pre-processor（预处理器）</h3><p><strong>作用</strong>：用它的编写方式写代码，然后解析成标准的 css 代码执行。<br><br>插件：less/sass cssNext <br><br>cssNext：用来实现一些未来的标准的插件（未完全在各大浏览器实现的）</p><h3 id="post-processor-（后处理器）"><a href="#post-processor-（后处理器）" class="headerlink" title="post-processor （后处理器）"></a>post-processor （后处理器）</h3><p><strong>作用</strong>：先用标准 css 语法去写，它会帮我们补充代码，比如兼容性。<br><br>插件：antoprefixer<br></p><h3 id="postCss"><a href="#postCss" class="headerlink" title="postCss"></a>postCss</h3><p><strong>介绍</strong>：<br><br>是一个工具。用 js 实现的 css 的抽象的语法树 AST(Abstract Syntax Tree)。<br><br>会和很多插件相配合，最典型的就是 cssNext 和 autoprefixer。<br><br><strong>作用</strong>：<br><br>做==前半部分==的事，把 css 解析成一个语法树，可以在语法树上定义自己的功能。剩下的事留给后人来做。<br><br>==后半部分==由各式各样的插件来完成(充分体现了扩展性，200 多个)。</p><h2 id="CSS3-Selector"><a href="#CSS3-Selector" class="headerlink" title="CSS3 Selector"></a>CSS3 Selector</h2><h3 id="Relationship-Selectors"><a href="#Relationship-Selectors" class="headerlink" title="Relationship Selectors"></a>Relationship Selectors</h3><h4 id="E-gt-F：直接子元素选择器"><a href="#E-gt-F：直接子元素选择器" class="headerlink" title="E &gt; F：直接子元素选择器"></a>E &gt; F：直接子元素选择器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">div &gt; p &#123;</span><br><span class="line">div下一级子元素中的p元素</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="E-F：下一个满足条件的兄弟元素节点"><a href="#E-F：下一个满足条件的兄弟元素节点" class="headerlink" title="E + F：下一个满足条件的兄弟元素节点"></a>E + F：下一个满足条件的兄弟元素节点</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">div + p&#123;</span><br><span class="line">    下一个兄弟元素节点，而且必须是p</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="E-F：下一群满足条件的兄弟元素节点"><a href="#E-F：下一群满足条件的兄弟元素节点" class="headerlink" title="E ~ F：下一群满足条件的兄弟元素节点"></a>E ~ F：下一群满足条件的兄弟元素节点</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">div + p&#123;</span><br><span class="line">下一群是p的兄弟元素节点，</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Attribute-Selectors"><a href="#Attribute-Selectors" class="headerlink" title="Attribute Selectors"></a>Attribute Selectors<br></h3><p><strong>CSS2</strong>：<br></p><h4 id="E-data-”a”"><a href="#E-data-”a”" class="headerlink" title="E[data~=”a”]"></a>E[data~=”a”]</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">div[data~&#x3D;&quot;a&quot;]&#123;</span><br><span class="line">    元素为div且data属性中有a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="E-data-’a’"><a href="#E-data-’a’" class="headerlink" title="E[data|=’a’]"></a>E[data|=’a’]</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">div[data|&#x3D;&#39;a&#39;]&#123;</span><br><span class="line">    选择data属性为a或者a-xxx的元素</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>CSS3 新增</strong><br></p><h4 id="E-data-’a’-1"><a href="#E-data-’a’-1" class="headerlink" title="E[data^=’a’]"></a>E[data^=’a’]<br></h4><p>data 属性以 a 开头</p><h4 id="E-data-’a’-2"><a href="#E-data-’a’-2" class="headerlink" title="E[data$=’a’]"></a>E[data$=’a’]<br></h4><p>data 属性以 a 结尾</p><h4 id="E-data-’a’-3"><a href="#E-data-’a’-3" class="headerlink" title="E[data*=’a’]"></a>E[data*=’a’]<br></h4><p>data 属性只要存在 a</p><h3 id="Pseudo-Element-Selectors"><a href="#Pseudo-Element-Selectors" class="headerlink" title="Pseudo-Element Selectors"></a>Pseudo-Element Selectors</h3><h4 id="E-placeholder"><a href="#E-placeholder" class="headerlink" title="E::placeholder"></a><strong>E::placeholder</strong><br></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type&#x3D;&quot;text&quot; placeholder&#x3D;&quot;请输入用户名&quot;&gt;</span><br><span class="line">input::placeholder&#123;</span><br><span class="line">    color:red;&#x2F;&#x2F;目前只能改颜色。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="E-selection：元素选中后的样式"><a href="#E-selection：元素选中后的样式" class="headerlink" title="E::selection：元素选中后的样式"></a><strong>E::selection</strong>：元素选中后的样式<br></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;我很棒&lt;&#x2F;p&gt;</span><br><span class="line">p:selection&#123;</span><br><span class="line">    color:red;&#x2F;&#x2F;文字颜色</span><br><span class="line">    background-color:white;&#x2F;&#x2F;背景颜色</span><br><span class="line">    text-shadow:1px 5px red;&#x2F;&#x2F;文字阴影。横向1px 纵向5px 颜色红色</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Pseudo-Classes-Selectors"><a href="#Pseudo-Classes-Selectors" class="headerlink" title="Pseudo-Classes Selectors"></a>Pseudo-Classes Selectors</h3><h4 id="E-not-s"><a href="#E-not-s" class="headerlink" title="E:not(s)"></a><strong>E:not(s)</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">div:not(.text&#x2F;[class&#x3D;&quot;text&quot;]&#x2F;..)&#123;</span><br><span class="line">    选中不含not中属性的元素</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="E-root-根节点-html、xml"><a href="#E-root-根节点-html、xml" class="headerlink" title="E:root:根节点(html、xml)"></a><strong>E:root</strong>:根节点(html、xml)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:root&#123;</span><br><span class="line"> 一般都这么来用</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="E-target：元素身上的锚点被锚点链接选中时，使用此样式。"><a href="#E-target：元素身上的锚点被锚点链接选中时，使用此样式。" class="headerlink" title="E:target：元素身上的锚点被锚点链接选中时，使用此样式。"></a><strong>E:target</strong>：元素身上的锚点被锚点链接选中时，使用此样式。<br></h4><p>当选中锚点链接为 box1 的 a 元素时，锚点为 box1 的 div 背景变为红色。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href&#x3D;&quot;#box1&quot;&gt;&lt;&#x2F;a&gt;</span><br><span class="line">&lt;a href&#x3D;&quot;#box2&quot;&gt;&lt;&#x2F;a&gt;</span><br><span class="line">&lt;div id&#x3D;&quot;box1&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div id&#x3D;&quot;box2&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">div:target&#123;</span><br><span class="line">    background-color:red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="E-ﬁrst-child-E-last-child-E-only-child-E-nth-child-n-E-nthlast-child-n"><a href="#E-ﬁrst-child-E-last-child-E-only-child-E-nth-child-n-E-nthlast-child-n" class="headerlink" title="E:ﬁrst-child E:last-child E:only-child E:nth-child(n) E:nthlast-child(n)"></a><strong>E:ﬁrst-child E:last-child E:only-child E:nth-child(n) E:nthlast-child(n)</strong><br></h4><p>==<strong>必须条件：</strong>==</p><ol><li>元素为 E</li><li>是兄弟元素中的第 n 个</li></ol><ul><li>E:ﬁrst-child 第一个元素</li><li>E:last-child 最后一个元素，两个条件都成立才可以<br><br>注意：<br> 1)若选第一个 p 元素，不同父级元素内的第一个 p 元素都会被选中<br> 2)若使用 p:first-child，<strong>第一个元素为 p</strong> 才能生效。<br></li><li>E:only-child 只有元素为独生子的前提下才能被选中<br></li><li>E:nth-child(n) 可以通过设置 n 的公式来批量选元素（在所有子元素中查数） <br></li><li>E:nth-last-child(n) 倒着数，功能同上<br><br>注意<br><br>1）n 从 0 开始查数，css 从 1 开始数，比如 nth-child(1)就是指第一个元素。<Br><br>2）奇偶数可以直接用 odd 和 even<br></li></ul><h5 id="注意-：这五种写法都考虑其他元素对他们的影响。比如前面插入一个元素。所以并不是很常用。"><a href="#注意-：这五种写法都考虑其他元素对他们的影响。比如前面插入一个元素。所以并不是很常用。" class="headerlink" title="**==注意==**：这五种写法都考虑其他元素对他们的影响。比如前面插入一个元素。所以并不是很常用。"></a>**==注意==**：这五种写法都考虑其他元素对他们的影响。比如前面插入一个元素。所以并不是很常用。<br></h5><h4 id="E-ﬁrst-of-type-E-last-of-type-E-only-of-pyte-E-nth-of-type-n-E-nth-of-lastpyte-n-常用"><a href="#E-ﬁrst-of-type-E-last-of-type-E-only-of-pyte-E-nth-of-type-n-E-nth-of-lastpyte-n-常用" class="headerlink" title="E:ﬁrst-of-type E:last-of-type E:only-of-pyte E:nth-of-type(n) E:nth-of-lastpyte(n) [常用]"></a><strong>E:ﬁrst-of-type E:last-of-type E:only-of-pyte E:nth-of-type(n) E:nth-of-lastpyte(n) [常用]</strong></h4><ul><li>E:first-of-type 所选元素中的第一个元素。</li><li>E:last-of-type 所选元素中的最后一个元素。</li><li>E:only-of-pyte 选中元素中此类元素只有一个。</li><li>E:nth-of-type(n) 可以通过设置 n 的公式来批量选元素（在所选子元素中查数）</li><li>E:nth-of-lastpyte(n)倒着数，功能同上</li></ul><p>这五种写法都无需考虑其他元素对他们的影响。很常用。</p><p>==<strong>注意:</strong>== E:nth-of-type(n)选取必须满足以下两个条件</p><ol><li>是兄弟元素中第 n 个元素(元素之间必须是兄弟关系)</li><li>元素为 E</li></ol><p>==踩坑记录：==</p><p>6 个 li 下面的<code>.img</code>元素，则要获取<code>li:nth-of-type(n) .img</code>，而不是<code>li .img:nth-of-type(n)</code></p><h4 id="E-empty-E-checked-E-enabled-E-disabled"><a href="#E-empty-E-checked-E-enabled-E-disabled" class="headerlink" title="E:empty E:checked E:enabled E:disabled"></a>E:empty E:checked E:enabled E:disabled</h4><ul><li>E:empty 内容为空的元素。</li><li>E:checked 为选中状态的元素（input)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type&#x3D;&quot;checkbox&quot; name&#x3D;&quot;&quot; id&#x3D;&quot;&quot;&gt;</span><br><span class="line">&lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line"></span><br><span class="line">input:checked+span::after &#123;</span><br><span class="line">       content: &quot;有内鬼，终止交易！&quot;;</span><br><span class="line">       background-color: green;</span><br><span class="line">       color: #fff;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul><li>E:enabled 启用状态的元素</li><li>E:disabled 禁用状态的元素</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">用法1：</span><br><span class="line">&lt;input type&#x3D;&quot;text&quot; disabled&#x2F;enabled&gt; 禁用&#x2F;启用元素</span><br><span class="line">用法2:</span><br><span class="line">input:disabled&#x2F;enabled&#123;</span><br><span class="line">   给含disabled&#x2F;enabled属性的input添加样式</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="E-read-only-E-read-write"><a href="#E-read-only-E-read-write" class="headerlink" title="E:read-only E:read-write"></a>E:read-only E:read-write</h4><ul><li>E:read-only 可读状态的元素</li><li>E:read-write 可写状态的元素</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">用法1：</span><br><span class="line">&lt;input type&#x3D;&quot;text&quot; readonly&#x2F;readwrite value&#x3D;&quot;hahah&quot;&gt; 文本框可读&#x2F;可写</span><br><span class="line">用法2:</span><br><span class="line">input:readonly&#x2F;readwrite&#123;</span><br><span class="line">   给含readonly&#x2F;readwrite属性的input添加样式</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="border-amp-background"><a href="#border-amp-background" class="headerlink" title="border&amp;background"></a>border&amp;background</h2><h3 id="border"><a href="#border" class="headerlink" title="border"></a>border</h3><h4 id="border-radius"><a href="#border-radius" class="headerlink" title="border-radius"></a>border-radius</h4><ul><li>原理：在正方形的四个角放一个半径为 n 的圆形来进行切割。</li><li>一般写法：border-radius:10px -</li><li>升级写法：border-radius:10px 10px 10px 10px</li><li>最高级别：border-top-left-radius:10px 10px</li><li>最高级别简化写法：border-radius:10px 10px 10px 10px / 10px 10px 10px 10px;<br> 前面值和后面值一一对应。</li></ul><h4 id="box-shadow-阴影"><a href="#box-shadow-阴影" class="headerlink" title="box-shadow 阴影"></a>box-shadow 阴影</h4><p>inset：内阴影，默认外阴影<br><br>color：背景颜色<br><br><strong>box-shadow: offsetX offsetY blur spread ** <br><br>**横向偏移量/垂直偏移量/模糊值(边框两边加像素)/扩散(四个方向加像素)</strong><br><br>**==多值应用==**：就是加多层阴影，可以任意层，相同参数的阴影会加重<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    box-shadow:</span><br><span class="line">    inset 5px 0px 10px #F00,</span><br><span class="line">    5px 0px 10px #F00,</span><br><span class="line">    0px 5px 5px #Ff0,</span><br><span class="line">    -5px 0px 5px #0f0,</span><br><span class="line">    0px -5px 5px #00f;</span><br><span class="line">注意：越往前，z-index越高。</span><br></pre></td></tr></table></figure><p><img src="http://47.97.6.61/%E6%9C%89%E9%81%93%E4%BA%91%E5%9B%BE%E7%89%87/css3-1.png" alt="avatar"></p><h4 id="border-image-边框背景图片"><a href="#border-image-边框背景图片" class="headerlink" title="border-image 边框背景图片"></a>border-image 边框背景图片</h4><h5 id="border-image-source-边框背景图片资源"><a href="#border-image-source-边框背景图片资源" class="headerlink" title="==border-image-source 边框背景图片资源=="></a>==border-image-source 边框背景图片资源==</h5><p>可填写的值</p><ul><li>url()</li><li>linear-gradient(#000,#fff);</li></ul><h5 id="brder-image-slice：切割"><a href="#brder-image-slice：切割" class="headerlink" title="==brder-image-slice：切割=="></a>==brder-image-slice：切割==</h5><p><img src="http://47.97.6.61/%E6%9C%89%E9%81%93%E4%BA%91%E5%9B%BE%E7%89%87/css3-2.png" alt="avatar"></p><ul><li>注意：此属性必填，一般填 border 宽度。</li><li>可分开填 4 个值：10 10 10 10，代表四条分割线的位置</li></ul><ul><li>数字代表像素，但是不让填 px</li><li>还可以填一个值 fill，代表把内容区填充（完全可以用背景代替，一般不用）</li><li>默认值 100%，四个角会填充整个背景图片</li></ul><h5 id="border-image-width-背景图片显示的宽度"><a href="#border-image-width-背景图片显示的宽度" class="headerlink" title="border-image-width 背景图片显示的宽度"></a>border-image-width 背景图片显示的宽度</h5><ul><li>默认值为 1（和 border 宽度一样，一般不改动）</li><li>auto 会拿 border-image-sclice 值，但是会加上 px。</li><li>border-image-width 填的数字是 border 宽度的倍数，n*border 宽度</li><li>自定义一般填 px</li></ul><h5 id="borderimage-outset-背景图片往外延伸，就是把背景图片挤出-border-区域（不常用）"><a href="#borderimage-outset-背景图片往外延伸，就是把背景图片挤出-border-区域（不常用）" class="headerlink" title="borderimage-outset 背景图片往外延伸，就是把背景图片挤出 border 区域（不常用）"></a>borderimage-outset 背景图片往外延伸，就是把背景图片挤出 border 区域（不常用）</h5><h5 id="border-image-repeat"><a href="#border-image-repeat" class="headerlink" title="==border-image-repeat=="></a>==border-image-repeat==</h5><ul><li>stretch 拉伸</li><li>repeat 平铺</li><li>round 特殊平铺：当放不下第二个背景图片的时候，拉伸，当满足第二个背景图片一半宽度时，整体压缩，把第二个放进去。</li><li>space 特殊平铺：当放不下第二个背景图片时，只显示一个，剩余空间空白填充，当能放下第二个背景图片时，再放进去。</li></ul><h5 id="整体写法"><a href="#整体写法" class="headerlink" title="整体写法"></a>整体写法</h5><ul><li>border-image:source slice repeat;这三个一般放一起写。</li><li>border-image-width 和 outset 一般单独写出来</li><li>为什么 slice 不让填 px 而 width 有 px 呢，因为放在一起写的时候可以区分开。</li></ul><h3 id="background"><a href="#background" class="headerlink" title="background"></a>background</h3><p>复习：</p><ul><li>background-color</li><li>background-image</li><li>background-position<ul><li>如果只指定一个值，那么第二个值默认为 center 。</li></ul></li><li>background-repeat</li><li>background-size<ul><li>常见宽高</li><li>cover 用一张图片，把容器填满而不改变图片比例</li><li>containe 在不改变图片比例的情况下，让容器包裹一张图片</li></ul></li><li>==<strong>注意</strong>==：设置多个背景图片属性时用逗号分隔<br></li></ul><h4 id="background-image-背景图片"><a href="#background-image-背景图片" class="headerlink" title="background-image 背景图片"></a>background-image 背景图片</h4><ul><li>url(),url()… 可添多个 url()</li><li>可通过设置 position 同时显示多张背景图片</li><li>可以设置渐变色。</li><li>公司常见写法：<ul><li>background-image:url(../),url(../容错图片.jpg);</li><li>如果第一张图片没加载出来，或者出错，就会去加载第二种图片，有一个容错机制。</li><li>一般来说第二张图片会非常小，一两 k，防止第二张加载不出。</li><li>若第二张加载不出，会留下一个白框。</li></ul></li></ul><h4 id="background-origin-背景图片坐标摆放位置"><a href="#background-origin-背景图片坐标摆放位置" class="headerlink" title="background-origin 背景图片坐标摆放位置"></a>background-origin 背景图片坐标摆放位置</h4><ul><li>padding-box:默认，背景图片摆放位置以 padding 区域为参考。</li><li>border-box:背景图片摆放位置以 border 区域为参考。</li><li>content-box:背景图片摆放位置以 content 区域为参考。</li></ul><h4 id="background-clip-背景图片截断位置"><a href="#background-clip-背景图片截断位置" class="headerlink" title="background-clip 背景图片截断位置"></a>background-clip 背景图片截断位置</h4><ul><li>padding-box：padding 区域以外背景图片截断（不显示）</li><li>border-box：border 区域以外背景图片截断（不显示）</li><li>content-box:：content 区域以外背景图片截断（不显示）</li><li>text 文字区域显示背景（文字的颜色变成背景）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">text具体用法</span><br><span class="line">-webkit-background-clip:text;</span><br><span class="line">background-clip:text;</span><br><span class="line">-webkit-text-fill-color:transparent;</span><br><span class="line">text-fill-color:transparent;</span><br></pre></td></tr></table></figure><h4 id="background-repeat"><a href="#background-repeat" class="headerlink" title="background-repeat"></a>background-repeat</h4><ul><li>repeat</li><li>no-repeat</li><li>repeat-x</li><li>repeat-y</li><li>round 平铺，容下一半宽度时放入，否则拉伸</li><li>space 平铺，容下整个宽度时放入，否则空白填充</li><li>round space ,垂直 round,水平 space</li></ul><h4 id="background-attachment-背景图片的定位方式"><a href="#background-attachment-背景图片的定位方式" class="headerlink" title="background-attachment 背景图片的定位方式"></a>background-attachment 背景图片的定位方式</h4><ul><li>只对有滚动条容器有效果</li><li>scroll 相对于容器 fiexd 定位，容器滚动背景图片不动。</li><li>local 容器滚动背景图片跟着滚动。</li><li>fiexd 相对页面进行 fiexd 定位（没卵用）</li></ul><h4 id="背景图片固定显示"><a href="#背景图片固定显示" class="headerlink" title="背景图片固定显示"></a>背景图片固定显示</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">background-image: url(&quot;.&#x2F;assets&#x2F;img&#x2F;bg.png&quot;);</span><br><span class="line">background-repeat: no-repeat;</span><br><span class="line">background-position: right bottom;</span><br><span class="line">background-attachment: fixed;</span><br></pre></td></tr></table></figure><h3 id="filter-滤镜"><a href="#filter-滤镜" class="headerlink" title="filter 滤镜"></a>filter 滤镜</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filter:blur(10px); &#x2F;&#x2F;高斯模糊</span><br></pre></td></tr></table></figure><p>如何设置背景模糊内容清晰？</p><p>可以设置一个和内容同级的元素，将模糊设置到这个元素上</p><p>注意 z-index 的层级</p><p>如果 bg 在兄弟元素的最前面，则不需要加层级，后面的会覆盖在它上面</p><p>如果 bg 在兄弟元素的后面需要将层级设置为-1，将父元素层级设置为 0</p><h3 id="渐变色"><a href="#渐变色" class="headerlink" title="渐变色"></a>渐变色</h3><h4 id="linear-gradient-线性渐变"><a href="#linear-gradient-线性渐变" class="headerlink" title="linear-gradient()线性渐变"></a>linear-gradient()线性渐变</h4><ul><li>linear-gradient(#fff,#000)（默认从上向下）</li><li>linear-gradient(to right,#fff,#000)（向右）</li><li>linear-gradient(to top right,#fff,#000)（向右上）</li><li>linear-gradient(30deg right,#fff,#000)（自定义角度，30 度）</li><li>linear-gradient(#fff 30px,#000 50px)（颜色起止位置。#fff 从 30px 开始往后去渐变为#000,最多渐变到 50px 变为#000）</li><li>注意，层级再背景之上</li></ul><h4 id="radial-gradient-镜像渐变"><a href="#radial-gradient-镜像渐变" class="headerlink" title="radial-gradient()镜像渐变"></a>radial-gradient()镜像渐变</h4><ul><li>radial-gradient(#fff,#000)（默认向外变色）</li><li>radial-gradient(#fff 20px,#000 40px)（颜色起始位置，从圆心开始 20px 往后开始渐变）</li><li>radial-gradient(circle at 100px 0px ,#fff,#000)设置圆形圆心位置：left:100px top:0px</li><li>radial-gradient(ellipse at 100px 0px,#fff,#000)设置椭圆圆心位置：left:100px top:0px</li><li>radial-gradient(#fff,#000)（默认向外变色）</li><li>注意，层级再背景之上</li></ul><p><strong>ellipse 椭圆的一些其他属性</strong></p><ul><li>ellipse closest-corner at 100px 0px ：放射边界到最近的角就截止</li><li>closest-side at 100px 0px ：放射边界到到最近的边就截止</li><li>farthest-corner at 100px 0px ：放射边界到到最远的角就截止</li><li>farthest-side at 100px 0px ：放射边界到到最远的边就截止<br><br>==<strong>注意</strong>==:</li></ul><ol><li>使用这些属性时可以不写 ellipse</li><li>椭圆就是于可变化宽高的圆形</li></ol><h3 id="color"><a href="#color" class="headerlink" title="color"></a>color</h3><p>前面学过：</p><ul><li>rgb()</li><li>rgba()</li><li>#000<br></li><li><strong>hsla（新加）</strong>:<br><br>H:Hue(色调)。0（或 360）表示红色，120 表示绿色，240 表示蓝色。取值范围 0-360 <br><br>S:stauration(饱和度).取值范围 0.0% - 100.0% <br><br>L:Lightness(亮度)。取值范围 0.0% - 100.0% <br><br>A:Alpha 透明度。取值 0 - 1 之间。<br><br><strong>注意</strong>:hsl 也可以用。</li><li>currentColor 中转颜色。<ul><li>解释：不写 border-color 的时候，默认 currentColor,指向文本的颜色。</li></ul></li></ul><h2 id="text"><a href="#text" class="headerlink" title="text"></a>text</h2><h3 id="复习："><a href="#复习：" class="headerlink" title="复习："></a>复习：</h3><ul><li>font<ul><li>font-size</li><li>font-family</li><li>font-color</li><li>font-weight</li></ul></li><li>text - text-align 文本对齐方式 - text-overflow 文本超出部分处理 - text-indent:2em;(文本缩进) - text-decoration:underline;(下划线)<br>开始：<br></li></ul><h3 id="text-shadow-阴影"><a href="#text-shadow-阴影" class="headerlink" title="text-shadow 阴影"></a>text-shadow 阴影</h3><h4 id="基本用法："><a href="#基本用法：" class="headerlink" title="基本用法："></a>基本用法：</h4><p>text-shadow:x 偏移 y 偏移 模糊度 颜色;</p><h4 id="浮雕效果"><a href="#浮雕效果" class="headerlink" title="浮雕效果"></a>浮雕效果</h4><p>text-shadow:1px 1px #000,-1px -1px #fff;</p><h4 id="镂刻效果"><a href="#镂刻效果" class="headerlink" title="镂刻效果"></a>镂刻效果</h4><p>text-shadow:-1px -1px #000;</p><h4 id="霓虹灯效果-火焰效果-红蓝错乱效果-文字背景显示图片"><a href="#霓虹灯效果-火焰效果-红蓝错乱效果-文字背景显示图片" class="headerlink" title="霓虹灯效果/火焰效果/红蓝错乱效果/文字背景显示图片"></a>霓虹灯效果/火焰效果/红蓝错乱效果/文字背景显示图片</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">text-shadow: 0px 0px 10px #0ff, 0px 0px 20px #0ff;</span><br><span class="line">text-shadow:    0px 0px 10px #f00,</span><br><span class="line">                0px 0px 20px #f00,</span><br><span class="line">                0px -5px 10px #f00,</span><br><span class="line">                0px -10px 20px #f00,</span><br><span class="line">                0px -10px 20px #f00,</span><br><span class="line">                0px -15px 30px #f00;</span><br><span class="line">text-shadow:    0px 0px 10px #f00,</span><br><span class="line">                0px 0px 20px #f00,</span><br><span class="line">                0px -5px 10px #f00,</span><br><span class="line">                0px -10px 20px #f00,</span><br><span class="line">                0px -10px 20px #f00,</span><br><span class="line">                0px -15px 30px #f00;</span><br><span class="line"></span><br><span class="line">text-shadow:    -10px -10px 3px rgba(255,0,255,.2),</span><br><span class="line">                5px 5px 3px  rgba(0,255,255,.2);</span><br><span class="line">                background-image: url(&quot;..&#x2F;img&quot;);</span><br><span class="line">                -webkit-background-clip: text;设置背景显示在text上</span><br><span class="line">                background-clip: text;</span><br><span class="line">                -webkit-text-fill-color: transparent;</span><br><span class="line">                text-fill-color: transparent; 设置文字填充颜色</span><br></pre></td></tr></table></figure><h3 id="webkit-text-stroke-描边效果"><a href="#webkit-text-stroke-描边效果" class="headerlink" title="-webkit-text-stroke 描边效果"></a>-webkit-text-stroke 描边效果</h3><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p>-webkit-text-stroke:1px red; 1px 的红色边框</p><h4 id="有趣玩法-文字有电路图效果（试了好像不行）"><a href="#有趣玩法-文字有电路图效果（试了好像不行）" class="headerlink" title="有趣玩法:文字有电路图效果（试了好像不行）"></a>有趣玩法:文字有电路图效果（试了好像不行）</h4><p>color:transparent;<br>font-family:simsun;<br>-webkit-text-stroke:1px green;</p><h3 id="white-space-pre-格式化文本"><a href="#white-space-pre-格式化文本" class="headerlink" title="white-space: pre; 格式化文本"></a>white-space: pre; 格式化文本</h3><h3 id="word-break"><a href="#word-break" class="headerlink" title="word-break:"></a>word-break:</h3><ul><li>keep-all;不换行</li><li>break-all;到边界就强制换行</li><li>break-word;尽可能保留单词的完整性</li></ul><h3 id="word-wrap-overflow-wrap"><a href="#word-wrap-overflow-wrap" class="headerlink" title="word-wrap/overflow-wrap"></a>word-wrap/overflow-wrap</h3><ul><li>break-word;尽可能保留单词的完整性</li></ul><h3 id="columns-多列"><a href="#columns-多列" class="headerlink" title="columns 多列"></a>columns 多列</h3><p>columns:300px 4 // 300px 宽，4 列</p><p>column-count:3;3 列 <br><br>column-gap:30px;空隙，30 像素宽，默认 16px <br><br>column-rule:solid;分割线,和 border 一样可以填任意属性值 <br><br>cloumn-width:200px; 一列的宽度，会随父级宽度变化去自动拉伸压缩。常用方法是固定父级宽度。<br>p 标签使用：<br>column-span:all;//贯穿整行。<br></p><h3 id="引入外部字体"><a href="#引入外部字体" class="headerlink" title="引入外部字体"></a>引入外部字体</h3><ul><li>用法：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@font-face &#123;</span><br><span class="line">    font-family: &#39;diyfont&#39;;</span><br><span class="line">    src: url(&#39;diyfont.eot&#39;); &#x2F;* IE9+ *&#x2F;</span><br><span class="line">    src: url(&#39;diyfont.eot?#ieﬁx&#39;) format(&#39;embedded-opentype&#39;), &#x2F;* IE6-IE8 *&#x2F;</span><br><span class="line">    url(&#39;diyfont.woff&#39;) format(&#39;woff&#39;), &#x2F;* chrome、ﬁrefox *&#x2F;</span><br><span class="line">    url(&#39;diyfont.ttf&#39;) format(&#39;truetype&#39;), &#x2F;* chrome、ﬁrefox、opera、Safari, Android, iOS 4.2+*&#x2F;      url(&#39;diyfont.svg#fontname&#39;) format(&#39;svg&#39;); &#x2F;* iOS 4.1- *&#x2F;</span><br><span class="line">&#125;</span><br><span class="line">div&#123;</span><br><span class="line">    font-family:&quot;diyfont&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注意：</li></ul><ol><li>如果是英文网站，字体包也就需要 1m 左右，可以引入。但是中文有几万个字，如果是全部字体改变的字体包，可能 10m 左右，一般不会用来引入。</li><li>一般引入字体包的情况，是字体包中只有需要的艺术字，而非全部的文字。<br><br>详解：<br><br>下面是一些历史进程，文字格式的问题，大致了解就好<br><br>对应的字体格式类型 字体格式.后<br><br>truetype 微软 苹果 .ttf<br><br>poentype 升级版 .opt<br><br>woff 上面两个压缩版 .woff .eat ..svg<br><br>其实是浏览器执行一种 MIME 协议，然后通过请求系统打开这些文件显示到浏览上显示 format（字体格式提示器）猜测是从电脑系统里面建立一种映射，来打开这些字体格式。</li></ol><h2 id="BOX"><a href="#BOX" class="headerlink" title="BOX"></a>BOX</h2><p><strong>复习</strong><br><br>正常盒子组成：border+padding+content<br><br>计算方式：boxWidth = width + border<em>2 + padding</em>2</p><h3 id="overflow"><a href="#overflow" class="headerlink" title="overflow"></a>overflow</h3><ul><li>overflow-x</li><li>overflow-y<br></li><li>注意： - 只要-x 或者-y 设置了非 visible 的值，另一个属性默认值会设置为 auto - 一般分开设置 x 和 y - 常用 overflow-x:auto; - 为什么用 auto 不用 scroll，因为用 scroll 时，若超出，则两个方向都会显示。<br>还可以填的值：<Br></li><li>visible 不处理，默认</li><li>hidden 隐藏溢出部分，且不出现滚动条</li><li>scroll 隐藏溢出部分，且出现滚动条</li><li>auto 当内容没有溢出时不出现滚动条，溢出了出现滚动条。</li></ul><h3 id="resize-让用户调节大小"><a href="#resize-让用户调节大小" class="headerlink" title="resize 让用户调节大小"></a>resize 让用户调节大小</h3><ul><li>none 不可调节</li><li>both 两个方向</li><li>horizontal 水平</li><li>vertical 垂直方向</li><li>注意 1：必须设置 overflow 属性。</li><li>注意 2：会使页面重排，尽量不要用</li></ul><h3 id="IE6-混杂模式盒子"><a href="#IE6-混杂模式盒子" class="headerlink" title="IE6 混杂模式盒子"></a>IE6 混杂模式盒子</h3><p>启动方式：box-sizing:border-box;<br><br><strong>和原先盒子的区别：计算方式不同</strong><br><br>boxWidth = width;<br><br>contentWidth = width - border<em>2 - padding</em>2<br><br>—和创建 bfc 区域有点类型</p><h3 id="flex-弹性盒子"><a href="#flex-弹性盒子" class="headerlink" title="flex 弹性盒子"></a>flex 弹性盒子</h3><h4 id="设置一个弹性盒子："><a href="#设置一个弹性盒子：" class="headerlink" title="设置一个弹性盒子："></a>设置一个弹性盒子：</h4><p>dispaly:flex / inline-flex;</p><h4 id="可用的属性值"><a href="#可用的属性值" class="headerlink" title="可用的属性值"></a>可用的属性值</h4><h5 id="写到父级的属性"><a href="#写到父级的属性" class="headerlink" title="写到父级的属性"></a>写到父级的属性</h5><ul><li>flex-direction:row;主轴方向<ul><li>row(默认，主轴为水平方向，自左向右)</li><li>row-reverse(主轴为水平方向，自右向左)</li><li>column(主轴为垂直方向，自上向下)</li><li>column-reverse(主轴为垂直方向，自下向上)</li></ul></li><li>flex-wrap:换行<ul><li>no-wrap(默认不换行)</li><li>wrap（换行）</li><li>wrap-reverse (倒着换行，456 / 123)</li></ul></li><li>flex-flow:flex-direction flex-wrap;</li><li>justify-content:对齐<ul><li>flex-start 基于主轴头部对齐</li><li>flex-end 基于主轴尾部对齐</li><li>flex-center 基于主轴居中对齐。</li><li>space-between 两边必须有元素，中间自适应。</li><li>space-around 元素均匀分配空隙，两测的边距为元素间距的一半。</li></ul></li><li>align-items: 交叉轴位置<ul><li>center/flex-start/end; 交叉轴（纵轴）位置居中/靠上/靠下显示</li><li>stretch; （这个是默认值，当内部元素不设置宽高的时候，会把元素拉伸）</li><li>注意：当出现多行时，每行元素会平均分配高度</li></ul></li><li>align-content: 交叉轴位置<ul><li>注意：<ol><li>单行时和 align-items 效果相同</li><li>多行时，每行元素会根据属性，依次排列，不会平均分配高度。</li><li>多行设置 nowrap 时，nowrap 生效，content 失效</li></ol></li><li>flex-start;元素依照交叉轴靠上显示</li><li>flex-end;元素依照交叉轴靠下显示</li><li>flex-center;元素依照交叉轴居中显示</li><li>space-between 两边必须有元素，中间自适应。</li><li>space-around 元素均匀分配空隙，两测的边距为元素间距的一半。</li></ul></li></ul><p><img src="http://47.97.6.61/%E6%9C%89%E9%81%93%E4%BA%91%E5%9B%BE%E7%89%87/flex1.png" alt="avatar"></p><p><img src="http://47.97.6.61/%E6%9C%89%E9%81%93%E4%BA%91%E5%9B%BE%E7%89%87/flex2.png" alt="avatar"></p><h5 id="设置到子项的属性"><a href="#设置到子项的属性" class="headerlink" title="设置到子项的属性"></a>设置到子项的属性</h5><ul><li>order:number; 数字大的往前排，尽量填负数，默认值为 0，但是填 1 也会排在没写此属性元素的后面。</li><li>align-self:子项相对交叉轴的位置（父 align-content&gt;子 align-self&gt;父&gt;align-items）<ul><li>center;</li><li>flex-start;</li><li>flex-end;</li><li>stretch; （这个是默认值，当内部元素不设置宽高的时候，会把元素拉伸）</li></ul></li></ul><p>==<strong>flex 伸缩属性</strong>==</p><ul><li>flex-grow:1; 盒子把主轴方向上剩余的空间按照设置比例给瓜分掉。默认为 0，不瓜分</li><li>flex-shrink:1;压缩比例 默认为 1</li><li>flex-basis:50px; 可以覆盖 whidth 值。默认 auto，就是计算 width 的宽度。</li><li><strong>flex-shrink 详解</strong>：<ul><li>1.一旦内容宽度超出了容器，flex-grow 就会失效，成为 0 的状态</li><li>2.<strong>公式</strong>：假设 3 个容器宽度为 200px,200px,400px,压缩比例为 1：1：3，<ul><li>(1) 先计算加权值：200px<em>1 + 200px</em>1 + 400px*3 = 1600px</li><li>(2) 三个容器所分的像素： 200px*1/1600(比例)*200px=25px，所以此容器压缩 25px，以此类推。</li><li>(3) 总结：(内容区大小)*shrink + … = 加权值</li></ul></li><li>3.默认 1，可以设置为 0，不参与压缩</li><li>4.<strong>格外注意</strong>：公式计算的容器像素，计算的是 content 的宽度，所以加 border 或 padding 的时候会出现精度不准的问题。</li><li>5.无论什么情况，被内容撑开的容器不参与运算。</li><li>6.标准盒子和弹性盒子都是此公式。</li></ul></li><li>==**flex-basis 和 width 的注意点 **==<ul><li>1.flex-basis 权重高于 width</li><li>2.只写 basis 或者 basis 大于 width 的时候，flex-basis 代表容器最小宽度</li><li>3.当两个属性都有并且 basis 小于 width 的时候，flex-basis 代表容器最小宽度，width 代表容器的最大宽度。</li></ul></li><li><strong>如果想让内容区正常的话，最好加上 word-break:break-word;可以防止英文撑大容器导致出错</strong></li></ul><p>==<strong>flex 简写</strong>==</p><ul><li>默认：flex:0 1 auto;</li><li>flex:1; -》 flex:1 1 0%;</li><li>flex:auto -》flex:1 1 auto;</li><li>flex:none -》 flex:0 0 auto;</li><li>flex: 0 auto 或者 flex:initial -&gt; flex:0 1 auto(即初始值);</li></ul><h4 id="弹性盒子应用"><a href="#弹性盒子应用" class="headerlink" title="弹性盒子应用"></a>弹性盒子应用</h4><p>demo</p><h2 id="transition-过度"><a href="#transition-过度" class="headerlink" title="transition 过度"></a>transition 过度</h2><h3 id="transition-property-过渡属性"><a href="#transition-property-过渡属性" class="headerlink" title="transition-property 过渡属性"></a>transition-property 过渡属性</h3><ul><li>all 所有具备动画过渡的元素</li><li>width,height… 可以规定特定值进行过渡</li></ul><h3 id="transition-duration-时间间隔"><a href="#transition-duration-时间间隔" class="headerlink" title="transition-duration 时间间隔"></a>transition-duration 时间间隔</h3><h3 id="transition-timing-function-运动状态函数"><a href="#transition-timing-function-运动状态函数" class="headerlink" title="transition-timing-function 运动状态函数"></a>transition-timing-function 运动状态函数</h3><h4 id="贝塞尔曲线-cubic-beseir-1-1-1-1-匀速运动"><a href="#贝塞尔曲线-cubic-beseir-1-1-1-1-匀速运动" class="headerlink" title="贝塞尔曲线 cubic-beseir(1, 1 , 1 , 1); 匀速运动"></a>贝塞尔曲线 cubic-beseir(1, 1 , 1 , 1); 匀速运动</h4><ul><li>linear 线性过渡。等同于贝塞尔曲线 （0,0,1,1)</li><li>ease 平滑过渡。等同于贝塞尔曲线 （0.25,0.1,0.25,1)</li><li>ease-in 由慢到快。等同于贝塞尔曲线 （0.42,0,0.58,1)</li><li>ease-out 由快到慢。等同于贝塞尔曲线（0,0,0.58,1)</li><li>ease-in-out:由慢到快再到慢。等同于贝塞尔曲线（0.42,0,0.58,1.0)</li></ul><h5 id="三次贝塞尔曲线详解"><a href="#三次贝塞尔曲线详解" class="headerlink" title="三次贝塞尔曲线详解"></a>三次贝塞尔曲线详解</h5><ul><li>cubic-besier(0,0,1,1)<ul><li>贝塞尔曲线的起点和终点是固定的</li><li>三次贝塞尔曲线有两个控制点，n 次贝塞尔曲线有 n-1 个控制点</li><li>0,0,1,1 代表的是两个控制点的坐标 (x,y)(x,y)</li><li>曲线的斜率代表运动的速度，斜率越大，速度越快。</li><li>可以通过浏览器来调试贝塞尔曲线</li><li>公式：B(t) = P₀(1 - t)³ + 3P₁t(1 - t)² + 3P₂t²(1 - t) + P₃t³ ,t ∈ [0,1]</li><li>注意点 1：x 轴区间为[0,1] ,y 轴可以任意取</li><li>注意点 2：y 轴小于 0 的时候，斜率会出现负值，这时会反方向运动一段距离。y 轴大于 0 的时候，会冲出一段距离，再回到终点。</li></ul></li></ul><h3 id="transition-delay-等待-xx-秒后执行"><a href="#transition-delay-等待-xx-秒后执行" class="headerlink" title="transition-delay 等待 xx 秒后执行"></a>transition-delay 等待 xx 秒后执行</h3><h3 id="组合使用：transition-all-1s-swing-1s-…-可以多值"><a href="#组合使用：transition-all-1s-swing-1s-…-可以多值" class="headerlink" title="组合使用：transition:all .1s swing 1s,….可以多值;"></a>组合使用：transition:all .1s swing 1s,….可以多值;</h3><h2 id="Transform-变换"><a href="#Transform-变换" class="headerlink" title="Transform: 变换"></a>Transform: 变换</h2><h3 id="transform"><a href="#transform" class="headerlink" title="transform:"></a>transform:</h3><h4 id="translate-平移"><a href="#translate-平移" class="headerlink" title="translate() 平移"></a>translate() 平移</h4><ul><li><p>translate(x,y) 元素相对自身位置向 x 轴 y 轴移动一定距离。</p></li><li><p>translateX(-50%) 相对自身位置向左移动自身一半的距离。</p></li><li><p>translateY(-50%) 相对自身位置向上移动自身一半的距离。</p></li><li><p>translateZ(-50%) 相对自身位置向后移动自身一半的距离。</p><ul><li>3d 效果：transfrom : rotatey(..) translatez(..)</li><li>使用 z 轴时需要父级元素加景深</li></ul></li><li><p>translate3d(x,y,z) 上面组合</p></li><li><p><strong>==注意==</strong><br></p><ul><li>可用于居中:left:50%;top:50%;transfrom:translate(-50%,-50%),在不知道元素宽高的情况下，这个就很好用。</li><li>知道自身宽度时直接 left:calc(50% - 50px);</li><li>使用此 translate()后，坐标轴会跟着变化， 所以在 translate 后面加 rotate 属性无效，因为轴已经跟着变了，应该讲 rotate 属性放前面。</li></ul></li></ul><h4 id="rotate-旋转"><a href="#rotate-旋转" class="headerlink" title="rotate() 旋转"></a>rotate() 旋转</h4><ul><li>rotate(45deg) 默认沿 z 轴旋转 45 度（即平面旋转）</li><li>rotatex() 沿 x 轴旋转</li><li>rotatey() 沿 y 轴旋转</li><li>rotatez() 沿 z 轴旋转</li><li>==rotate3d(x,y,z,0deg)==<ul><li>x,y,z 设置的比值，就是这个矢量的方向，也就是轴的朝向。</li><li>比如 rotate3d(1,1,1,90deg);图像的轴指向就是平面指向右下角，垂直斜角指向 45 度，然后在这个轴上旋转 90 度。</li><li>3 个数的大小不重要，重要的是比例。x=1,y=1。轴的方向就是指向右下。x 在点 1 的位置，y 在点 1 的位置，从(0,0)到(1,1)就是轴的位置</li></ul></li><li>注意：<ul><li>transfrom:rotatey(90deg) rotatex(45deg);</li><li>transfrom:rotatex(45deg) rotatey(90deg) ;</li><li>旋转的先后顺序不同，效果不同</li></ul></li></ul><h4 id="scale-伸缩"><a href="#scale-伸缩" class="headerlink" title="scale() 伸缩"></a>scale() 伸缩</h4><ul><li>scale(x,y) //大于 0 放大，小于 0 压缩</li><li>scalex(1.5)</li><li>scaley()</li><li>scalez()</li><li>scale3d(x,y,z)</li><li>==注意点 1：伸缩的是此元素的变化坐标轴的刻度，不是元素本身==<ul><li>也就是说，在元素上进行像素值等操作时，无需顾忌是否被伸缩</li></ul></li><li>==注意点 2：可以进行叠加操作，即从改变后的基础上继续操作==</li><li>==<strong>注意点 3</strong>：配合 rotate()使用会出现的情况==<ul><li>scale 伸缩轴会跟着旋转来变动。特点：雁过留声，就是没旋转时伸缩，再进行旋转时伸缩比例还是旋转前的，先旋转再伸缩时，伸缩轴就会跟着旋转轴来一直变化，也就出现了图片比例在一直变化的情况。</li><li>transfrom:rotate(45deg) scale(1,2) //旋转时图片缩放比例为设置比例（正常）</li><li>transfrom:scale(1,2) rotate(45deg) //旋转时图片比例随时在变化，x 轴和 y 轴缩放比例一直保持 1：2</li></ul></li><li>==<strong>注意点 4（踩坑）：</strong>== 缩放背景图片时可能会出现轻微抖动，加上 translatez(0),让 gpu 来控制动画可以解决。</li></ul><h4 id="skew-倾斜"><a href="#skew-倾斜" class="headerlink" title="skew 倾斜"></a>skew 倾斜</h4><ul><li>skew(xdeg,ydeg)</li><li>倾斜的是坐标轴。</li><li><strong>==倾斜的时候，也被拉伸了==</strong></li></ul><h4 id="perspective-800px-在元素自身上加景深"><a href="#perspective-800px-在元素自身上加景深" class="headerlink" title="perspective(800px) 在元素自身上加景深"></a>perspective(800px) 在元素自身上加景深</h4><pre><code>- 写的话最好填在开头位置 transform:perspective(800px) ...，若不填在开头位置，在一些浏览器上可能会不识别- 不能调节origin的值</code></pre><h4 id="backface-visibility-hidden-visible-设置图片背面不显示，默认可以"><a href="#backface-visibility-hidden-visible-设置图片背面不显示，默认可以" class="headerlink" title="backface-visibility:hidden/visible;设置图片背面不显示，默认可以"></a>backface-visibility:hidden/visible;设置图片背面不显示，默认可以</h4><h4 id="3d-旋转-bug：隐藏背面不管用，后面图片会投到前面，设置个背景颜色就好了"><a href="#3d-旋转-bug：隐藏背面不管用，后面图片会投到前面，设置个背景颜色就好了" class="headerlink" title="==3d 旋转 bug：隐藏背面不管用，后面图片会投到前面，设置个背景颜色就好了=="></a>==3d 旋转 bug：隐藏背面不管用，后面图片会投到前面，设置个背景颜色就好了==</h4><h4 id="图片变换的底层原理：matrix-矩阵"><a href="#图片变换的底层原理：matrix-矩阵" class="headerlink" title="==图片变换的底层原理：matrix() 矩阵=="></a>==图片变换的底层原理：matrix() 矩阵==</h4><ul><li>矩阵就是 transform 给咱们选中的计算规则</li><li>向矩阵传入参数，通过系统的计算得出需要的结果</li><li>transform 的基础就是把图像上的每一个点进行变换</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">原理公式</span><br><span class="line">| a,c,e |   | x |   | ax + cy + e |</span><br><span class="line">| b,d,f | * | y | &#x3D; | bx + dy + f |</span><br><span class="line">| 0,0,1 |   | 1 |   | 0 + 0 + 1   |  &#x2F;&#x2F;这一排是系统方便计算用的，不用管</span><br><span class="line"></span><br><span class="line">第一个矩阵用来传入参数，有些值可能给固定了</span><br><span class="line">第二个矩阵的x和y就相当于图片的每一个点的原始坐标</span><br><span class="line">第三个矩阵就相当于我们最终想要的位置</span><br><span class="line"></span><br><span class="line">2d平移公式：</span><br><span class="line">| 1,0,e |   | x |   | x + e |</span><br><span class="line">| 0,1,f | * | y | &#x3D; | y + f |</span><br><span class="line">| 0,0,1 |   | 1 |   1           &#x2F;&#x2F;这一排是系统方便计算用的，不用管</span><br><span class="line">参数只能传e和f，所以图像会根据e和f来移动x和y的坐标</span><br><span class="line">把他翻译到功能函数中就这么写：</span><br><span class="line">matrix(1,0,0,1,e,f) &#x3D;&#x3D;&#x3D; translate(x,y);</span><br><span class="line"></span><br><span class="line">其他方法的矩阵原理:</span><br><span class="line">scale()伸缩  矩阵公式</span><br><span class="line">| a,0,0 |   | x |   | ax |</span><br><span class="line">| 0,d,0 | * | y | &#x3D; | dy |</span><br><span class="line">| 0,0,1 |   | 1 |   1           &#x2F;&#x2F;这一排是系统方便计算用的，不用管</span><br><span class="line">matrix(a,0,0,d,0,0) &#x3D;&#x3D;&#x3D; scale(x,y);</span><br><span class="line"></span><br><span class="line">rotate()旋转 矩阵公式</span><br><span class="line">| cos(*),-sin(*),e |   | x |</span><br><span class="line">| sin(*),cos(*) ,f | * | y |</span><br><span class="line">| 0     ,0      ,1 |   | 1 |</span><br><span class="line">matrix(cos(*),sin(*),-sin(*),cos(*),0,0) &#x3D;&#x3D;&#x3D; rotate(*) &#x2F;&#x2F;直接写rotate()更简单</span><br><span class="line"></span><br><span class="line">3d原理公式</span><br><span class="line">| a,c,g |   | x |   | ax + cy + g |</span><br><span class="line">| b,d,h | * | y |   | bx + dy + h |</span><br><span class="line">| e,f,i | * | z | &#x3D; | ex + fy + i |</span><br><span class="line">| 0,0,1 |   | 1 |   | 0 + 0 + 1   |  &#x2F;&#x2F;这一排是系统方便计算用的，不用管</span><br><span class="line"></span><br><span class="line">matrix(1,0,0,0,0,1,0,0,0,0,1,0,x,y,z,1) 缩放</span><br><span class="line">matrix(x,0,0,0,0,y,0,0,0,0,z,0,0,0,0,1) 平移</span><br></pre></td></tr></table></figure><ul><li><strong>==日常使用方法==</strong><ul><li>矩阵是反着推的</li><li>先通过效果把第三个矩阵写出来，再反推出第一个矩阵，从而得出 matrix()</li><li>注意：matrix()是上下上下数。最后一排无视</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">实践一下：</span><br><span class="line">想让一个图片垂直方向对调。如 a--b 变成 b--a</span><br><span class="line">第一步：根据效果得出第三个矩阵：</span><br><span class="line">| -x |</span><br><span class="line">| y  |</span><br><span class="line">| 1  |</span><br><span class="line">第二步：结合第二个矩阵得出第一个矩阵</span><br><span class="line">| -1,0,0 |   | x |   | -x |</span><br><span class="line">|  0,1,0 | * | y | &#x3D; | y  |</span><br><span class="line">|  0,0,1 |   | 1 |   | 1  |  &#x2F;&#x2F;这一排是系统方便计算用的，不用管</span><br><span class="line">第三步：得出matrix()矩阵参数</span><br><span class="line">matrix(-1,0,0,1,0,0)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="transform-origin：设置变换中心原点位置（相当于眼睛位置）"><a href="#transform-origin：设置变换中心原点位置（相当于眼睛位置）" class="headerlink" title="transform-origin：设置变换中心原点位置（相当于眼睛位置）"></a>transform-origin：设置变换中心原点位置（相当于眼睛位置）</h3><ul><li>设置到元素上，设置元素的变换中心点，不设置的话默认在元素平面的中心点。</li><li>transform-origin:50px 50px 50px; 旋转中心位置,比如这是一个 100px 的立方体，旋转中心就在立方体中心位置。</li></ul><h3 id="transform-style：变化风格"><a href="#transform-style：变化风格" class="headerlink" title="transform-style：变化风格"></a>transform-style：变化风格</h3><ul><li>preserve-3d;会在此区域创建出很多层图层，增强 3d 效果。</li><li>常用方法：一般和景深放一起。加上肯定没错的。</li></ul><h3 id="perspective-景深"><a href="#perspective-景深" class="headerlink" title="perspective 景深"></a>perspective 景深</h3><ul><li>设置到父级上</li><li>当子元素设置 z 轴时有立体效果</li><li>perspective:800px</li><li>景深可以叠加。（父+子）</li><li><strong>==一旦设置了 perspective 或者 transform-style，景深就变成了子元素定位的参照物==</strong></li><li><strong>==看到的都是投影上显示的形状，所以当 translatez 小于 100 时，距离越近看的越小==</strong></li></ul><p><img src="http://47.97.6.61/%E6%9C%89%E9%81%93%E4%BA%91%E5%9B%BE%E7%89%87/%E6%99%AF%E6%B7%B1.png" alt="avatar"></p><h3 id="perspective-origin：设置旋转原点位置"><a href="#perspective-origin：设置旋转原点位置" class="headerlink" title="perspective-origin：设置旋转原点位置"></a>perspective-origin：设置旋转原点位置</h3><ul><li>设置到父级上</li><li>perspective-origin:center center 默认原点在中间</li><li>perspective-origin:top left;…</li></ul><h2 id="animation-动画"><a href="#animation-动画" class="headerlink" title="animation 动画"></a>animation 动画</h2><h3 id="animation-name-动画名称"><a href="#animation-name-动画名称" class="headerlink" title="animation-name 动画名称"></a>animation-name 动画名称</h3><h4 id="关键帧容器-keyframes"><a href="#关键帧容器-keyframes" class="headerlink" title="==关键帧容器@keyframes=="></a>==关键帧容器@keyframes==</h4><ul><li>定义关键帧</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@keyframes run&#123;</span><br><span class="line">    0%&#123; &#x2F;&#x2F;0%可以写成from&#123;&#125;</span><br><span class="line">        left: 500px;</span><br><span class="line">        top: 500px;</span><br><span class="line">        background-color: red;</span><br><span class="line">    &#125;</span><br><span class="line">    50%&#123;&#125;</span><br><span class="line">    100%&#123;&#125;&#x2F;&#x2F;100%可以写成to&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用<br><br>animation:run 1s , run2 2s; //可以多个关键帧并行 <br><br>@-moz-…实战时做兼容</li></ul><h3 id="animation-duration-持续时间"><a href="#animation-duration-持续时间" class="headerlink" title="animation-duration 持续时间"></a>animation-duration 持续时间</h3><h3 id="animation-timing-function-过渡类型（传运动函数）"><a href="#animation-timing-function-过渡类型（传运动函数）" class="headerlink" title="animation-timing-function 过渡类型（传运动函数）"></a>animation-timing-function 过渡类型（传运动函数）</h3><ul><li>linear 线性过渡。等同于贝塞尔曲线 （0,0,1,1)</li><li>ease 平滑过渡。等同于贝塞尔曲线 （0.25,0.1,0.25,1.0)</li><li>ease-in 由慢到快。等同于贝塞尔曲线 （0.42,0,0.58,1)</li><li>ease-out 由快到慢。等同于贝塞尔曲线（0,0,0.58,1)</li><li>ease-in-out:由慢到快再到慢。等同于贝塞尔曲线（0.42,0,0.58,1)</li><li>cubic-bezier(0,0,1,1) 贝塞尔曲线</li></ul><h3 id="animation-delay-延迟时间"><a href="#animation-delay-延迟时间" class="headerlink" title="animation-delay 延迟时间"></a>animation-delay 延迟时间</h3><h3 id="animation-iteration-count-运动次数"><a href="#animation-iteration-count-运动次数" class="headerlink" title="animation-iteration-count 运动次数"></a>animation-iteration-count 运动次数</h3><ul><li>infinite 无线循环</li><li>number</li></ul><h3 id="animation-direction-关键帧的方向"><a href="#animation-direction-关键帧的方向" class="headerlink" title="animation-direction 关键帧的方向"></a>animation-direction 关键帧的方向</h3><ul><li>normal 默认</li><li>reverse 反转 从 100% -&gt; 0% 运动</li><li>alternate 100% -&gt; 0% 0% -&gt; 100% .. 正反循环运动。前提:运动次数大于 2</li><li>alternate-reverse 0% -&gt; 100% 100% -&gt; 0% ..同上</li></ul><h3 id="animation-play-state-运动状态"><a href="#animation-play-state-运动状态" class="headerlink" title="animation-play-state 运动状态"></a>animation-play-state 运动状态</h3><ul><li>running 默认值</li><li>paused 运动暂停（有兼容性问题，有些浏览器会出现问题，不要用）</li></ul><h3 id="animation-fill-mode-保留状态"><a href="#animation-fill-mode-保留状态" class="headerlink" title="animation-fill-mode 保留状态"></a>animation-fill-mode 保留状态</h3><ul><li>forwards 保留运动结束后的最后一帧（不会变回初始状态）</li><li>backwards 运动开始之前保留第一帧的状态（即使没开始动画，也变为 0%的状态）</li><li>both 上两个的结合：保留开始和结束的状态</li></ul><h3 id="steps-跨步"><a href="#steps-跨步" class="headerlink" title="steps 跨步"></a>steps 跨步</h3><ul><li>作用：从一帧到下一帧本来是渐变过去，使用 steps 变成分步变色。可以理解为从动画变成 ppt</li><li>end 保留当前帧状态，直到这一帧动画结束（注意，若下一帧是最后一帧，当跳转的时候动画也就结束了，所以不会捕捉到最后一帧。如果需要可用 forwards 解决）</li><li>start 保留下一帧状态，直到下一帧动画结束（注意，不会显示第一帧）</li><li>使用</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">animation: fun 1s linner steps(1, end)</span><br></pre></td></tr></table></figure><ul><li>特殊值：<ul><li>step-end === steps(1, end)</li><li>step-start === start(1, start)</li></ul></li></ul><h3 id="简写：-animation-fun-1s-linner。。。"><a href="#简写：-animation-fun-1s-linner。。。" class="headerlink" title="简写： animation: fun 1s linner。。。"></a>简写： animation: fun 1s linner。。。</h3><h2 id="gpu-amp-layout（性能优化）"><a href="#gpu-amp-layout（性能优化）" class="headerlink" title="gpu&amp;layout（性能优化）"></a>gpu&amp;layout（性能优化）</h2><h3 id="科普知识：cpu-和-gpu"><a href="#科普知识：cpu-和-gpu" class="headerlink" title="科普知识：cpu 和 gpu"></a>科普知识：cpu 和 gpu</h3><ul><li>cpu：中央处理器<ul><li>擅长基于逻辑的数学运算，与或非…</li></ul></li><li>gpu：显卡<ul><li>图片绘制…</li><li>适合高精度的浮点数运算</li><li>专业 gpu 都是点阵式，通过点的变化来完成图像变化</li><li>家用 gpu 是通过矩阵或者多边形叠加的方式来完成图像变化。</li><li>css3 的动画都是用矩阵的原理完成的，也就是点阵式，所以是比较烧性能的。</li><li>所以尽量不要有太多的复杂变化。</li><li>没有 gpu 的时候就会用 cpu 来计算，cpu 的算力远不如 gpu</li></ul></li></ul><h3 id="浏览器渲染机制"><a href="#浏览器渲染机制" class="headerlink" title="浏览器渲染机制"></a>浏览器渲染机制</h3><p><img src="http://47.97.6.61/%E6%9C%89%E9%81%93%E4%BA%91%E5%9B%BE%E7%89%87/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6.png" alt="浏览器渲染机制"></p><h4 id="什么情况下会触发-reflow-重排"><a href="#什么情况下会触发-reflow-重排" class="headerlink" title="什么情况下会触发 reflow(重排)"></a>什么情况下会触发 reflow(重排)</h4><ul><li>改变窗口大小</li><li>改变文字大小</li><li>内容的改变，输入文字</li><li>激活伪类，如:hover</li><li>操作 class 属性</li><li>脚本化操作 DOM</li><li>计算 offsetWidth 和 offsetHeight</li><li>设置 style 属性</li><li><strong>==如果要改动一些属性：不要用很多个.style，尽量用定义好的 class，直接更改 class 属性，触发一次怎么也比触发很多次节省性能==</strong></li></ul><h4 id="什么情况下会触发-repaint-重绘"><a href="#什么情况下会触发-repaint-重绘" class="headerlink" title="什么情况下会触发 repaint(重绘)"></a>什么情况下会触发 repaint(重绘)</h4><ul><li>只是改变某个元素的颜色，不影响布局的属性</li><li>repaint 速度快于 relfow</li></ul><h4 id="css3-怎么性能优化"><a href="#css3-怎么性能优化" class="headerlink" title="css3 怎么性能优化"></a>css3 怎么性能优化</h4><ul><li>因为 css3 会很消耗性能，所以最好交给 gpu 来做</li><li>虽然可能会让 gpu 来做，但是最好还是和 gpu 说一声，让 gpu 来帮忙做这件事。</li></ul><h5 id="gpu-操作是在另一个层面来操作。哪些指令能触发-gpu-这个层呢？"><a href="#gpu-操作是在另一个层面来操作。哪些指令能触发-gpu-这个层呢？" class="headerlink" title="gpu 操作是在另一个层面来操作。哪些指令能触发 gpu 这个层呢？"></a>gpu 操作是在另一个层面来操作。哪些指令能触发 gpu 这个层呢？</h5><ul><li>改变 opacity</li><li>transform:translate3d()/translatez();</li><li>比如开发时使用 transform 了，不管你前面填了啥，最好在最后填上个 translatez(0),叫 gpu 来操作，能节省一些效率。</li><li>==gpu 加速，最标准属性：will-change:tranform==<ul><li>启动这个后系统会一直监听，等待执行，也不太好，所以有下面最标准使用方法。</li><li>标准使用方法：<ul><li>比如点击触发某些动画时，可以在点击的元素上加个 hover，当 hover 的时候加上这个属性。</li><li>最好的用法就是在触发动画的前一刻再加这个属性。</li></ul></li></ul></li></ul><h5 id="一般浏览器刷新页面的频率-1s-60-次"><a href="#一般浏览器刷新页面的频率-1s-60-次" class="headerlink" title="一般浏览器刷新页面的频率 1s 60 次"></a>一般浏览器刷新页面的频率 1s 60 次</h5><ul><li>也就是每 16.7mm 刷新一次页面</li><li>如果编码结构足够节约效率，gpu 可以在一帧里渲染好页面，那么当改动页面元素或者实现动画的时候，将会非常流畅。</li></ul><h2 id="screen-amp-px-显示器的成像原理和像素的实际意义"><a href="#screen-amp-px-显示器的成像原理和像素的实际意义" class="headerlink" title="screen&amp;px 显示器的成像原理和像素的实际意义"></a>screen&amp;px 显示器的成像原理和像素的实际意义</h2><h3 id="空间混色法"><a href="#空间混色法" class="headerlink" title="空间混色法"></a>空间混色法</h3><ul><li>rgb 是三原色</li><li>一个像素由三个像点来构成 r g b ==&gt; 空间混色法</li></ul><h4 id="crt-显示屏"><a href="#crt-显示屏" class="headerlink" title="crt 显示屏"></a>crt 显示屏</h4><p><img src="http://47.97.6.61/%E6%9C%89%E9%81%93%E4%BA%91%E5%9B%BE%E7%89%87/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6.png" alt="crt"></p><ul><li>成像原理：</li></ul><ol><li>屏幕最末端有电子枪，可以打出电子束，电子束打到屏幕上</li><li>屏幕上会有荧光粉（rgb 三种，排列方式有两种，圆点型和栅格型）， 在接受到电子束的时候会变亮</li><li>根据电子束强弱的不同，每个被点亮的荧光粉的颜色强弱不同，最后混合出不同的颜色形成一个像素点</li><li>最后多个像素点成像</li></ol><ul><li>电子束容易散射，可能会相互影响，所以中间加一个荫罩层，用于矫正电子束。</li></ul><h4 id="lcd-led-液晶屏"><a href="#lcd-led-液晶屏" class="headerlink" title="lcd/led 液晶屏"></a>lcd/led 液晶屏</h4><ul><li>成像原理</li></ul><ol><li>通过磁场可以改变液晶屏的每一个点的状态是固态还是液态</li><li>当这个点是液态时，光就能过去，固态的时候光就过不去。</li><li>当这个光透过后可以把光打到滤光片上（有无数个滤光片，排列方式还是 rgb 形式）</li><li>白光打到每个像素中不同的滤光片上会出现不同的颜色，再经过混色成像。</li></ol><h4 id="1px-有多大"><a href="#1px-有多大" class="headerlink" title="1px 有多大"></a>1px 有多大</h4><ul><li>屏幕像素排列结构-品字原点形<br><br>可以说是点距，也就是两个相同点之间的距离（点距大小约等于像素大小，点距完全等于像素大小吗？不一定。可以表示像素大小吗?可以的。）<br><img src="http://47.97.6.61/%E6%9C%89%E9%81%93%E4%BA%91%E5%9B%BE%E7%89%87/%E7%82%B9%E8%B7%9D.png" alt="点距"></li><li>屏幕像素排列结构-栅格型<br><br>点距就是两个相同颜色的距离，也就是真实的像素距离。<br><img src="http://47.97.6.61/%E6%9C%89%E9%81%93%E4%BA%91%E5%9B%BE%E7%89%87/%E6%A0%85%E6%A0%BC%E5%9E%8B.png" alt="栅格型"></li></ul><h4 id="像素详解"><a href="#像素详解" class="headerlink" title="像素详解"></a>像素详解</h4><ul><li>像素是相对单位</li></ul><h5 id="物理像素-设备出厂时，像素的大小"><a href="#物理像素-设备出厂时，像素的大小" class="headerlink" title="物理像素 === 设备出厂时，像素的大小"></a>物理像素 === 设备出厂时，像素的大小</h5><h5 id="dpi-ppi"><a href="#dpi-ppi" class="headerlink" title="dpi(ppi)"></a>dpi(ppi)</h5><p>一英寸所能容纳的像素点数。能容纳的像素点数越多，代表像素越小，成像效果越好。<br><br>1 in = 2.54cm<br>96dpi ≈ 2.54 / 100 = 0.25mm 如果屏幕为 96dpi 也就是一像素的宽度约等于 0.25 毫米</p><h5 id="css-像素（参照像素）-逻辑像素"><a href="#css-像素（参照像素）-逻辑像素" class="headerlink" title="css 像素（参照像素）== 逻辑像素"></a>css 像素（参照像素）== 逻辑像素</h5><ul><li>96dip 一臂距离的视角去看，显示出的具体大小</li><li>标杆 1/96 * 英寸</li><li>具体实现：<ul><li>96dpi ≈ 1:1</li><li>200dpi ≈ 2:1</li><li>解释：就比如 96dpi 下是 100px ，换成 200dpi 的时候，屏幕会把 100px 再乘 2</li></ul></li><li>设备像素比 dpr = 物理像素/css 像素[参照像素]（200dpi/96dpi)</li><li>美工给图的时候会按照高像素屏幕的物理像素来给我们图片的尺寸，所以我们要转换为逻辑像素的时候需要除 dpr</li><li>我们也管 css 编程的逻辑像素方式，叫做逻辑屏幕</li></ul><h5 id="看屏幕的好坏不看分辨率"><a href="#看屏幕的好坏不看分辨率" class="headerlink" title="看屏幕的好坏不看分辨率"></a>看屏幕的好坏不看分辨率</h5><ul><li>1920 * 1080 固定宽高下，展示的像素点数。这个得根据屏幕大小来判断，1 寸的 1920.。和 10 寸的 1920.。那肯定不一样</li><li>所以要看 dpi，没有也可以自己算出来。</li></ul><h1 id="响应式网页开发"><a href="#响应式网页开发" class="headerlink" title="响应式网页开发"></a>响应式网页开发</h1><ul><li>用户通过什么来看页面？pc 端（电脑），移动端（手机、平板）–（大小/分辨率不同）</li><li>如何使页面在不同的设备上展示的效果相同？ ——》响应式网页设计</li></ul><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>真正的响应式设计方法不仅仅是根据可视区域大小而改变网页布局，而是要从整体上颠覆当前网页的设计方法，是针对任意设备的网页内容进行完美布局的一种显示机制。</p><h2 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h2><p>只需要开发一套页面，就能让用户在不同的设备上看到的页面呈现的效果是完美的。</p><h2 id="模拟移动端的-meta"><a href="#模拟移动端的-meta" class="headerlink" title="模拟移动端的 meta"></a>模拟移动端的 meta</h2><p>作用：适配各种不同分辨率的设备。<br><br>将页面大小，根据分辨率不同进行相应的调节，以展示给用的的大小感觉上差不多</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;</span><br><span class="line">默认 980px 1024px</span><br></pre></td></tr></table></figure><ul><li>content=”width=device-width 代表视口宽度设置为当前屏幕大小<br><br></li><li>initial-scale=1.0 初始化缩放比。也是针对视口而言的。<br> 作用同上，为 ios 做兼容。因为上面只涉及宽度，ios 横屏的时候宽度还是屏幕的宽度，不能自适应。<br><br></li><li>为什么不只写 initial-scale=1.0?<br><br>在 window phone ie 浏览器上，横屏宽度=竖屏宽度,不能自适应。</li></ul><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul><li>==width:视口宽度==</li><li>==device-width:设备宽度==</li><li>user-scalable=no 是否允许用户缩放</li><li>minimum-scale:最小缩放比</li><li>maximum-scale:最大缩放比</li></ul><h2 id="实现必备知识"><a href="#实现必备知识" class="headerlink" title="实现必备知识"></a>实现必备知识</h2><ul><li>流体网格布：可伸缩的网格，元素大小宽高不固定可伸缩<ul><li>flex</li><li>百分比</li><li>浮动</li></ul></li><li>弹性图片：图片宽高不固定（可设置 min-width:100%)</li><li>==媒体查询==：让页面载体不同的终端上面展示效果相同（用户体验相同），==在不同的设备上，均显示合适的页面==</li><li>主要断点：设备宽度的临界点 -&gt; 根据不同的宽度展示不同的样式</li><li>响应式网页开发主要是在 css 样式上面操作的。为什么不用 js 来控制实现<ul><li>代码偏多</li><li>加载速度变慢</li><li>监听过程当中，可能会对页面有一定影响</li></ul></li></ul><h3 id="主要断点详解"><a href="#主要断点详解" class="headerlink" title="主要断点详解"></a>主要断点详解</h3><p><img src="http://47.97.6.61/%E6%9C%89%E9%81%93%E4%BA%91%E5%9B%BE%E7%89%87/%E4%B8%BB%E8%A6%81%E6%96%AD%E7%82%B9.png" alt="主要断点"></p><h3 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h3><p>媒体查询是向不同设备提供不同样式的一种方式，它为每种类型的用户提供了最佳的体验。</p><h4 id="css2-media-type-媒体类型"><a href="#css2-media-type-媒体类型" class="headerlink" title="==css2:media type(媒体类型)=="></a>==css2:media type(媒体类型)==</h4><p>media type(媒体类型)是 css 2 中的一个非常有用的属性，通过 media type 我们可以对不同的设备指定特定的样式，从而实现更丰富的界面。</p><ul><li>==常用属性：screen:用于电脑屏幕、平板电脑、手机等==<br><img src="http://47.97.6.61/%E6%9C%89%E9%81%93%E4%BA%91%E5%9B%BE%E7%89%87/%E5%AA%92%E4%BD%93%E7%B1%BB%E5%9E%8B.png" alt="媒体类型"></li></ul><h4 id="css3-media-query-媒体查询"><a href="#css3-media-query-媒体查询" class="headerlink" title="css3:media query(媒体查询)"></a>css3:media query(媒体查询)</h4><p>media query 是 CSS3 对 media type 的增强，事实上我们可以将 media query 看成是媒体类型(media type)+css 属性(媒体特性 Media features)对设备进行判断。<br></p><h5 id="媒体特性-Media-features"><a href="#媒体特性-Media-features" class="headerlink" title="==媒体特性 Media features=="></a>==<strong>媒体特性 Media features</strong>==</h5><ul><li>==注意：媒体特性使用时加括号-&gt; (max-width:375px)==</li><li>width/max-width/min-width</li><li>height/max-height/min-height<br><img src="http://47.97.6.61/%E6%9C%89%E9%81%93%E4%BA%91%E5%9B%BE%E7%89%87/%E5%AA%92%E4%BD%93%E5%8A%9F%E8%83%BD.png" alt="媒体功能"></li></ul><h5 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h5><ul><li>合并多个媒体属性：and</li><li>指定备用功能(相当于 or)：,</li><li>指定否定条件:not</li><li>让早期浏览器隐藏媒体查询：only ps:加上 only 后如果不支持媒体查询会忽略媒体查询部分（如早期浏览器），支持则无影响</li></ul><h5 id="媒体查询使用-引入方式"><a href="#媒体查询使用-引入方式" class="headerlink" title="==媒体查询使用(引入方式)=="></a>==媒体查询使用(引入方式)==</h5><p>ps:希望在屏幕大小小于 375px 的设备上面作用这个样式</p><ul><li>外部引入 <link rel="stylesheet" media="screen and (max-width:375px)"  href="index.css"></li><li>外部引入 @import ‘index.css’ screen and (max-width:375px);</li><li>css 里面引入 @media screen and (max-width:375px){…}</li><li>==注意==<ol><li>媒体类型和媒体特性用 and 连接</li><li>权重为 0，一般放在最后来写</li></ol></li></ul><h2 id="单位值"><a href="#单位值" class="headerlink" title="单位值"></a>单位值</h2><ul><li>rem ：rem 是 CSS3 新增的一个相对单位（root em，根 em）相对的只是 HTML 根元素。</li><li>em：相对本身的 font-size 大小。</li><li>px：像素 px 是相对于显示器屏幕分辨率而言的。</li><li>Vw：相对于视口的宽度。视口被均分为 100 单位的 vw。一般用在移动端开发里面</li><li>Vh：相对于视口的高度。视口被均分为 100 单位的 vh。一般用在移动端开发里面</li><li>Vmax： 相对于视口的宽度或高度中较大的那个。其中最大的那个被均分为 100 单位的 vmax。移动端开发</li><li>Vmin：相对于视口的宽度或高度中较小的那个。其中最小的那个被均分为 100 单位的 vmin。移动端开发</li></ul><h2 id="响应式设计是最佳选择吗？"><a href="#响应式设计是最佳选择吗？" class="headerlink" title="响应式设计是最佳选择吗？"></a>响应式设计是最佳选择吗？</h2><p>不是的，根据实际情况来决定。</p><ul><li><p>内容设计通过响应式设计思路解决，项目的预算，目标用户以及定位决定了其实现方式。</p></li><li><p>开发思路<br>渐进增强 —》 先兼容老版本 再向上兼容 兼容最新设备<br>优雅降级 —》 开发通用版本 再兼容老版本 向下兼容</p></li><li><p>一般做响应式开发时思路：<br><br>先移动端 —》 pc 端 <br><br>先 iphone6 为初始原型 开发 —》 兼容其他的设备 ====》 渐进增强</p></li></ul><h2 id="3d-方块效果总结"><a href="#3d-方块效果总结" class="headerlink" title="3d 方块效果总结"></a>3d 方块效果总结</h2><p><strong>重点：</strong></p><blockquote><p>此处 box 代表一个方块，包含六个面</p></blockquote><ol><li>如果 box 自身会变化角度(rotate)，则需要在自身加上<code>transform-style: preserve-3d;</code></li><li>如果 box 自身会变化角度(rotate)，则父级必须加景深<code>perspective: 1000px;</code><ul><li>如果父级也会变化角度(rotate)，则在父级的父级加景深</li></ul></li></ol><p><strong>构建一个 3d 方块：</strong></p><ol><li>设置.box 样式</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">    transform-style: preserve-3d;</span><br><span class="line">    position: relative;</span><br><span class="line">    width: 300px;</span><br><span class="line">    height: 300px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>设置 面 的基本样式</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.box div &#123;</span><br><span class="line">    width: 300px;</span><br><span class="line">    height: 300px;</span><br><span class="line">    border: 1px solid;</span><br><span class="line">    position: absolute;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>分别设置六个 面 的样式</li></ol><blockquote><p>主要思路：设置上下左右面时，都顺时针转，只调整初始位置</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 前 *&#x2F;</span><br><span class="line">.box div:nth-child(1) &#123;</span><br><span class="line">    background-color: red;</span><br><span class="line">    transform: translateZ(150px);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;* 后 *&#x2F;</span><br><span class="line">.box div:nth-child(2) &#123;</span><br><span class="line">    background-color: blue;</span><br><span class="line">    transform: translateZ(-150px);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;* 上 *&#x2F;</span><br><span class="line">.box div:nth-child(3) &#123;</span><br><span class="line">    background-color: green;</span><br><span class="line">    transform: rotateX(90deg) translateZ(150px);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;* 下 *&#x2F;</span><br><span class="line">.box div:nth-child(4) &#123;</span><br><span class="line">    background-color: yellow;</span><br><span class="line">    transform: rotateX(90deg) translateZ(-150px);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;* 左 *&#x2F;</span><br><span class="line">.box div:nth-child(5) &#123;</span><br><span class="line">    background-color: greenyellow;</span><br><span class="line">    transform: rotateY(90deg) translateZ(-150px);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;* 右 *&#x2F;</span><br><span class="line">.box div:nth-child(6) &#123;</span><br><span class="line">    background-color: orange;</span><br><span class="line">    transform: rotateY(90deg) translateZ(150px);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="css3-轮播图"><a href="#css3-轮播图" class="headerlink" title="css3 轮播图"></a>css3 轮播图</h2><p>html:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;pic&quot;</span>&gt;</span><br><span class="line">    &lt;ul <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;inner&quot;</span>&gt;</span><br><span class="line">        &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;images/1.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">        &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;images/2.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">        &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;images/3.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">    &lt;ul <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;dot&quot;</span>&gt;</span><br><span class="line">        &lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;active&quot;</span>&gt;&lt;/span&gt;</span><br><span class="line">        &lt;span&gt;&lt;/span&gt;</span><br><span class="line">        &lt;span&gt;&lt;/span&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>css:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#pic &#123;</span><br><span class="line">    width: <span class="number">100</span>vw;</span><br><span class="line">    height: <span class="number">36</span>vw;</span><br><span class="line">    position: relative;</span><br><span class="line">    overflow: hidden;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pic .inner &#123;</span><br><span class="line">    width: <span class="number">300</span>vw;</span><br><span class="line">    display: flex;</span><br><span class="line">    position: absolute;</span><br><span class="line">    left: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pic .inner li &#123;</span><br><span class="line">    width: <span class="number">100</span>vw;</span><br><span class="line">    height: <span class="number">36</span>vw;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pic .inner li img &#123;</span><br><span class="line">    width: <span class="number">100</span>%;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pic .dot&#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    padding: <span class="number">5</span>px;</span><br><span class="line">    left: <span class="number">50</span>%;</span><br><span class="line">    bottom: <span class="number">10</span>px;</span><br><span class="line">    height: <span class="number">10</span>px;</span><br><span class="line">    line-height: <span class="number">15</span>px;</span><br><span class="line">    transform: translateX(<span class="number">-50</span>%);</span><br><span class="line">    border-radius: <span class="number">10</span>px;</span><br><span class="line">    background-color: rgba(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">.5</span>);</span><br><span class="line">&#125;</span><br><span class="line">#pic .dot span&#123;</span><br><span class="line">    display: inline-block;</span><br><span class="line">    width: <span class="number">10</span>px;</span><br><span class="line">    height: <span class="number">10</span>px;</span><br><span class="line">    background-color: white;</span><br><span class="line">    border: <span class="number">1</span>px solid black;</span><br><span class="line">    border-radius: <span class="number">50</span>%;</span><br><span class="line">    cursor: pointer;</span><br><span class="line">&#125;</span><br><span class="line">#pic .dot span.active&#123;</span><br><span class="line">    background-color: orange;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>js:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> pic = <span class="built_in">document</span>.getElementById(<span class="string">&quot;pic&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> picUl = pic.querySelector(<span class="string">&quot;ul&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> picLi = picUl.children;</span><br><span class="line"><span class="keyword">let</span> dots = pic.querySelector(<span class="string">&quot;.dot&quot;</span>).children;</span><br><span class="line"><span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> headLi = picUl.firstElementChild.cloneNode(<span class="literal">true</span>);</span><br><span class="line">picUl.appendChild(headLi);</span><br><span class="line"></span><br><span class="line">picUl.style.width = picLi.length * <span class="number">100</span> + <span class="string">&quot;vw&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  picUl.style.transition = <span class="string">&quot;left .5s&quot;</span>;</span><br><span class="line">  picUl.style.left = -index * <span class="number">100</span> + <span class="string">&quot;vw&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 页面失去焦点时不会触发这个事件</span></span><br><span class="line">picUl.addEventListener(<span class="string">&quot;transitionend&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (index == picLi.length - <span class="number">1</span>) &#123;</span><br><span class="line">    picUl.style.transition = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    picUl.style.left = <span class="number">0</span>;</span><br><span class="line">    index = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">autoPlay</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  index++;</span><br><span class="line">  <span class="comment">//这个条件是为了防止页面失去焦点的时候定时还在走，cn也在加，那就会超出范围</span></span><br><span class="line">  <span class="keyword">if</span> (index &gt; picLi.length - <span class="number">1</span>) &#123;</span><br><span class="line">    index = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  move();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> timer = <span class="built_in">setInterval</span>(autoPlay, <span class="number">1000</span>);</span><br><span class="line"><span class="comment">// 悬停效果</span></span><br><span class="line">picUl.onmouseenter = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">clearInterval</span>(timer);</span><br><span class="line">&#125;;</span><br><span class="line">picUl.onmouseleave = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  timer = <span class="built_in">setInterval</span>(autoPlay, <span class="number">1000</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给圆点添加事件</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">in</span> dots) &#123;</span><br><span class="line">  dots[item].onmouseenter = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">clearInterval</span>(timer);</span><br><span class="line">    <span class="keyword">let</span> i = <span class="built_in">Array</span>.from(dots).indexOf(e.target);</span><br><span class="line">    index = i;</span><br><span class="line">    move();</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 圆点移动</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dotPlay</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">in</span> dots) &#123;</span><br><span class="line">    dots[item].className = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (index === dots.length) &#123;</span><br><span class="line">    dots[<span class="number">0</span>].className = <span class="string">&quot;active&quot;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    dots[index].className = <span class="string">&quot;active&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 前端 </tag>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
