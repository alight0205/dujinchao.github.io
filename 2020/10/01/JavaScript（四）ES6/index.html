<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"8.0.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}};
  </script>

  <meta name="description" content="声明变量相关使用 var 声明变量 全局变量挂载到全局对象：全局对象成员污染问题 允许重复的变量声明：导致数据被覆盖 变量提升：怪异的数据访问、闭包问题">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaScript（四）ES6">
<meta property="og:url" content="http://example.com/2020/10/01/JavaScript%EF%BC%88%E5%9B%9B%EF%BC%89ES6/index.html">
<meta property="og:site_name" content="Mr.Duの博客">
<meta property="og:description" content="声明变量相关使用 var 声明变量 全局变量挂载到全局对象：全局对象成员污染问题 允许重复的变量声明：导致数据被覆盖 变量提升：怪异的数据访问、闭包问题">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://47.97.6.61/%E6%9C%89%E9%81%93%E4%BA%91%E5%9B%BE%E7%89%87/%E5%AE%BF%E4%B8%BB%E7%8E%AF%E5%A2%83.png">
<meta property="og:image" content="http://47.97.6.61/%E6%9C%89%E9%81%93%E4%BA%91%E5%9B%BE%E7%89%87/%E6%89%A7%E8%A1%8C%E6%A0%88.png">
<meta property="og:image" content="http://47.97.6.61/%E6%9C%89%E9%81%93%E4%BA%91%E5%9B%BE%E7%89%87/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF.png">
<meta property="og:image" content="http://47.97.6.61/%E6%9C%89%E9%81%93%E4%BA%91%E5%9B%BE%E7%89%87/%E5%AE%8F%E9%98%9F%E5%88%97%EF%BC%8C%E5%BE%AE%E9%98%9F%E5%88%97.png">
<meta property="og:image" content="http://47.97.6.61/%E6%9C%89%E9%81%93%E4%BA%91%E5%9B%BE%E7%89%87/unsettled%20%E5%92%8C%20settled.png">
<meta property="og:image" content="http://47.97.6.61/%E6%9C%89%E9%81%93%E4%BA%91%E5%9B%BE%E7%89%87/%E6%9C%AA%E5%86%B3%E6%8E%A8%E5%90%91%E5%B7%B2%E5%86%B3.png">
<meta property="og:image" content="http://47.97.6.61/%E6%9C%89%E9%81%93%E4%BA%91%E5%9B%BE%E7%89%87/%E5%B7%B2%E5%86%B3%E9%98%B6%E6%AE%B5%E5%90%8E%E7%BB%AD%E5%A4%84%E7%90%86.png">
<meta property="og:image" content="http://47.97.6.61/%E6%9C%89%E9%81%93%E4%BA%91%E5%9B%BE%E7%89%87/Promise.png">
<meta property="og:image" content="http://47.97.6.61/%E6%9C%89%E9%81%93%E4%BA%91%E5%9B%BE%E7%89%87/Promise.png">
<meta property="article:published_time" content="2020-09-30T16:39:46.000Z">
<meta property="article:modified_time" content="2020-10-01T10:20:42.675Z">
<meta property="article:author" content="黑砸是只猫">
<meta property="article:tag" content="笔记">
<meta property="article:tag" content="前端">
<meta property="article:tag" content="JavaScript">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://47.97.6.61/%E6%9C%89%E9%81%93%E4%BA%91%E5%9B%BE%E7%89%87/%E5%AE%BF%E4%B8%BB%E7%8E%AF%E5%A2%83.png">


<link rel="canonical" href="http://example.com/2020/10/01/JavaScript%EF%BC%88%E5%9B%9B%EF%BC%89ES6/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>JavaScript（四）ES6 | Mr.Duの博客</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>
 <a target="_blank" rel="noopener" href="https://github.com/cat-heiza" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Mr.Duの博客</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">半山腰总是最拥挤的，你得去山顶看看</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
          <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E%E5%8F%98%E9%87%8F%E7%9B%B8%E5%85%B3"><span class="nav-number">1.</span> <span class="nav-text">声明变量相关</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-var-%E5%A3%B0%E6%98%8E%E5%8F%98%E9%87%8F"><span class="nav-number">1.1.</span> <span class="nav-text">使用 var 声明变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-let-%E5%A3%B0%E6%98%8E%E5%8F%98%E9%87%8F"><span class="nav-number">1.2.</span> <span class="nav-text">使用 let 声明变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-const-%E5%A3%B0%E6%98%8E%E5%B8%B8%E9%87%8F"><span class="nav-number">1.3.</span> <span class="nav-text">使用 const 声明常量</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">2.</span> <span class="nav-text">字符串和正则表达式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%87%BD%E6%95%B0"><span class="nav-number">3.</span> <span class="nav-text">函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E6%95%B0%E9%BB%98%E8%AE%A4%E5%80%BC"><span class="nav-number">3.1.</span> <span class="nav-text">参数默认值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%A9%E4%BD%99%E5%8F%82%E6%95%B0"><span class="nav-number">3.2.</span> <span class="nav-text">剩余参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B1%95%E5%BC%80%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">3.3.</span> <span class="nav-text">展开运算符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%98%8E%E7%A1%AE%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%8C%E9%87%8D%E7%94%A8%E9%80%94"><span class="nav-number">3.4.</span> <span class="nav-text">明确函数的双重用途</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0"><span class="nav-number">3.5.</span> <span class="nav-text">箭头函数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1"><span class="nav-number">4.</span> <span class="nav-text">对象</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B0%E5%A2%9E%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%AD%97%E9%9D%A2%E9%87%8F%E8%AF%AD%E6%B3%95"><span class="nav-number">4.1.</span> <span class="nav-text">新增的对象字面量语法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Object-%E7%9A%84%E6%96%B0%E5%A2%9E-API"><span class="nav-number">4.2.</span> <span class="nav-text">Object 的新增 API</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="nav-number">4.3.</span> <span class="nav-text">面向对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%EF%BC%9A%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E8%AF%AD%E6%B3%95%E7%B3%96"><span class="nav-number">4.4.</span> <span class="nav-text">类：构造函数的语法糖</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E5%85%B6%E4%BB%96%E4%B9%A6%E5%86%99%E6%96%B9%E5%BC%8F"><span class="nav-number">4.5.</span> <span class="nav-text">类的其他书写方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="nav-number">4.6.</span> <span class="nav-text">类的继承</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%A7%A3%E6%9E%84"><span class="nav-number">5.</span> <span class="nav-text">解构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E8%A7%A3%E6%9E%84"><span class="nav-number">5.1.</span> <span class="nav-text">对象解构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E8%A7%A3%E6%9E%84"><span class="nav-number">5.2.</span> <span class="nav-text">数组解构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%84"><span class="nav-number">5.3.</span> <span class="nav-text">参数解构</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%A6%E5%8F%B7"><span class="nav-number">6.</span> <span class="nav-text">符号</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%99%AE%E9%80%9A%E7%AC%A6%E5%8F%B7"><span class="nav-number">6.1.</span> <span class="nav-text">普通符号</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E7%AC%A6%E5%8F%B7"><span class="nav-number">6.2.</span> <span class="nav-text">共享符号</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9F%A5%E5%90%8D%E7%AC%A6%E5%8F%B7"><span class="nav-number">6.3.</span> <span class="nav-text">知名符号</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86"><span class="nav-number">7.</span> <span class="nav-text">异步处理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF-%E5%9B%9E%E9%A1%BE"><span class="nav-number">7.1.</span> <span class="nav-text">事件循环[回顾]</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E5%92%8C%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E7%9A%84%E7%BC%BA%E9%99%B7"><span class="nav-number">7.2.</span> <span class="nav-text">事件和回调函数的缺陷</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86%E7%9A%84%E9%80%9A%E7%94%A8%E6%A8%A1%E5%9E%8B"><span class="nav-number">7.3.</span> <span class="nav-text">异步处理的通用模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Promise-%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="nav-number">7.4.</span> <span class="nav-text">Promise 的基本使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Promise-%E7%9A%84%E4%B8%B2%E8%81%94"><span class="nav-number">7.5.</span> <span class="nav-text">Promise 的串联</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Promise-%E7%9A%84%E5%85%B6%E4%BB%96-API"><span class="nav-number">7.6.</span> <span class="nav-text">Promise 的其他 API</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%8B%E5%86%99-Promise-%E6%89%A9%E5%B1%95"><span class="nav-number">7.7.</span> <span class="nav-text">手写 Promise[扩展]</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#async-%E5%92%8C-await"><span class="nav-number">7.8.</span> <span class="nav-text">async 和 await</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Fetch-Api"><span class="nav-number">8.</span> <span class="nav-text">Fetch Api</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Fetch-Api-%E6%A6%82%E8%BF%B0"><span class="nav-number">8.1.</span> <span class="nav-text">Fetch Api 概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="nav-number">8.2.</span> <span class="nav-text">基本使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Request-%E5%AF%B9%E8%B1%A1"><span class="nav-number">8.3.</span> <span class="nav-text">Request 对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Response-%E5%AF%B9%E8%B1%A1"><span class="nav-number">8.4.</span> <span class="nav-text">Response 对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Header-%E5%AF%B9%E8%B1%A1"><span class="nav-number">8.5.</span> <span class="nav-text">Header 对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0"><span class="nav-number">8.6.</span> <span class="nav-text">文件上传</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%94%9F%E6%88%90%E5%99%A8"><span class="nav-number">9.</span> <span class="nav-text">迭代器和生成器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-number">9.1.</span> <span class="nav-text">迭代器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%8D%8F%E8%AE%AE-%E4%B8%8E-for-of-%E5%BE%AA%E7%8E%AF"><span class="nav-number">9.2.</span> <span class="nav-text">可迭代协议 与 for-of 循环</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%9F%E6%88%90%E5%99%A8-Generator"><span class="nav-number">9.3.</span> <span class="nav-text">生成器 (Generator)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%9F%E6%88%90%E5%99%A8%E5%BA%94%E7%94%A8-%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E6%8E%A7%E5%88%B6"><span class="nav-number">9.4.</span> <span class="nav-text">生成器应用-异步任务控制</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9B%B4%E5%A4%9A%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B"><span class="nav-number">10.</span> <span class="nav-text">更多集合类型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#set-%E9%9B%86%E5%90%88"><span class="nav-number">10.1.</span> <span class="nav-text">set 集合</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#map-%E9%9B%86%E5%90%88"><span class="nav-number">10.2.</span> <span class="nav-text">map 集合</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#WeakSet-%E5%92%8C-WeakMap-%E6%89%A9%E5%B1%95"><span class="nav-number">10.3.</span> <span class="nav-text">WeakSet 和 WeakMap[扩展]</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%A3%E7%90%86%E4%B8%8E%E5%8F%8D%E5%B0%84"><span class="nav-number">11.</span> <span class="nav-text">代理与反射</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Proxy-%E4%BB%A3%E7%90%86"><span class="nav-number">11.1.</span> <span class="nav-text">Proxy 代理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%EF%BC%9A%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="nav-number">11.2.</span> <span class="nav-text">应用：观察者模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%EF%BC%9A%E5%81%B7%E6%87%92%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">11.3.</span> <span class="nav-text">应用：偷懒的构造函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%EF%BC%9A%E5%8F%AF%E9%AA%8C%E8%AF%81%E7%9A%84%E5%8F%82%E6%95%B0%E5%87%BD%E6%95%B0"><span class="nav-number">11.4.</span> <span class="nav-text">应用：可验证的参数函数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A2%9E%E5%BC%BA%E7%9A%84%E6%95%B0%E7%BB%84%E5%8A%9F%E8%83%BD"><span class="nav-number">12.</span> <span class="nav-text">增强的数组功能</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="nav-number">12.1.</span> <span class="nav-text">静态方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95"><span class="nav-number">12.2.</span> <span class="nav-text">实例方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E5%8C%96%E6%95%B0%E7%BB%84-%E6%89%A9%E5%B1%95"><span class="nav-number">12.3.</span> <span class="nav-text">类型化数组[扩展]</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ArrayBuffer-%E6%89%A9%E5%B1%95"><span class="nav-number">12.4.</span> <span class="nav-text">ArrayBuffer[扩展]</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%B6%E4%BD%9C%E9%BB%91%E7%99%BD%E7%85%A7%E7%89%87-%E6%89%A9%E5%B1%95"><span class="nav-number">12.5.</span> <span class="nav-text">制作黑白照片[扩展]</span></a></li></ol></li></ol></div>
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="黑砸是只猫"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">黑砸是只猫</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">8</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/cat-heiza" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;cat-heiza" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:1778911090@qq.com" title="E-Mail → mailto:1778911090@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </section>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">
      

      

  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/10/01/JavaScript%EF%BC%88%E5%9B%9B%EF%BC%89ES6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="黑砸是只猫">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr.Duの博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          JavaScript（四）ES6
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2020-10-01 00:39:46 / 修改时间：18:20:42" itemprop="dateCreated datePublished" datetime="2020-10-01T00:39:46+08:00">2020-10-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>69k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1:03</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="声明变量相关"><a href="#声明变量相关" class="headerlink" title="声明变量相关"></a>声明变量相关</h1><h2 id="使用-var-声明变量"><a href="#使用-var-声明变量" class="headerlink" title="使用 var 声明变量"></a>使用 var 声明变量</h2><ol>
<li>全局变量挂载到全局对象：全局对象成员污染问题</li>
<li>允许重复的变量声明：导致数据被覆盖</li>
<li>变量提升：怪异的数据访问、闭包问题<a id="more"></a>

</li>
</ol>
<h2 id="使用-let-声明变量"><a href="#使用-let-声明变量" class="headerlink" title="使用 let 声明变量"></a>使用 let 声明变量</h2><p>ES6 不仅引入 let 关键字用于解决变量生命的问题，同时引入了块级作用域的的概念</p>
<h3 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域<br></h3><ol>
<li>代码执行时遇到花括号，会创建一个块级作用域，花括号结束，销毁块级作用域</li>
<li>在循环中使用 let 声明的循环变量，在循环结束后会销毁</li>
<li>在循环中，用 let 声明的循环变量，会特殊处理，每次进入循环体，都会开启一个新的作用域，并且将循环变量绑定到该作用域（每次循环，使用的是一个全新的循环变量）</li>
<li>在循环中使用 let 声明的循环变量，在循环结束后会销毁</li>
</ol>
<h3 id="所解决声明变量的问题"><a href="#所解决声明变量的问题" class="headerlink" title="所解决声明变量的问题"></a>所解决声明变量的问题</h3><ol>
<li>不会污染全局变量（全局变量不会挂载到全局对象[window]）</li>
<li>let 变量不允许同作用域内重复声明</li>
<li>使用 let 不会有变量提升，因此，不能在定义 let 变量前使用它<ul>
<li><strong>底层实现上，let 声明的变量实际上也会有提升，但是，提升后会将其放入到“暂时性死区”，如果访问的变量位于暂时性死区，则会报错：“Cannot access ‘a’ before initialization”。当代码运行到该变量的声明语句时，会将其从暂时性死区中移除。</strong></li>
</ul>
</li>
</ol>
<h2 id="使用-const-声明常量"><a href="#使用-const-声明常量" class="headerlink" title="使用 const 声明常量"></a>使用 const 声明常量</h2><p>const 和 let 完全相同，仅在于用 const 声明的变量，==必须在声明时赋值，而且不可以重新赋值。==</p>
<ul>
<li>实际上，在开发中，应该==尽量使用 const 来声明变量==，以保证变量的值不会随意篡改，原因如下：<ol>
<li>根据经验，开发中的很多变量，都是不会更改，也不应该更改的。</li>
<li>后续的很多框架或者是第三方 JS 库，都要求数据不可变，使用常量可以一定程度上保证这一点。</li>
</ol>
</li>
<li>==<strong>注意的细节</strong>==：<ol>
<li>常量不可变，是指声明的常量的内存空间不可变，并不保证内存空间中的地址指向的其他空间不可变。(==常量本身的值不可变，若常量是个引用值，则可以更改引用值里面的数据==)</li>
<li>常量的命名<ol>
<li>特殊的常量：该常量从字面意义上，一定是不可变的，比如圆周率、月地距地或其他一些绝不可能变化的配置。通常，<strong>该常量的名称全部使用大写，多个单词之间用下划线分割</strong></li>
<li>普通的常量：使用和之前一样的命名即可</li>
</ol>
</li>
<li>在 for 循环中，循环变量不可以使用常量</li>
</ol>
</li>
</ul>
<h1 id="字符串和正则表达式"><a href="#字符串和正则表达式" class="headerlink" title="字符串和正则表达式"></a>字符串和正则表达式</h1><h3 id="Unicode-相关"><a href="#Unicode-相关" class="headerlink" title="Unicode 相关"></a>Unicode 相关</h3><p>早期，由于存储空间宝贵，Unicode 使用 16 位二进制来存储文字。我们将一个 16 位的二进制编码叫做一个码元（Code Unit）。</p>
<p>后来，由于技术的发展，Unicode 对文字编码进行了扩展，将某些文字扩展到了 32 位（占用两个码元），并且，将某个文字对应的二进制数字叫做码点（Code Point）。</p>
<p>ES6 为了解决这个困扰，为字符串提供了方法：codePointAt，根据字符串码元的位置得到其码点。</p>
<p>同时，ES6 为正则表达式添加了一个 flag: u，如果添加了该配置，则匹配时，使用码点匹配</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">const text &#x3D; &quot;𠮷&quot;; &#x2F;&#x2F;占用了两个码元（32位）</span><br><span class="line"></span><br><span class="line">console.log(&quot;字符串长度：&quot;, text.length);&#x2F;&#x2F;2</span><br><span class="line">console.log(&quot;使用正则测试：&quot;, &#x2F;^.$&#x2F;.test(text));&#x2F;&#x2F;false 因为这里匹配的是码元，所以匹配失败</span><br><span class="line">console.log(&quot;使用正则测试：&quot;, &#x2F;^.$&#x2F;u.test(text));&#x2F;&#x2F;true，这里匹配的是码点</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 判断字符串char，是32位，还是16位</span><br><span class="line"> * @param &#123;*&#125; char</span><br><span class="line"> *&#x2F;</span><br><span class="line">function is32bit(char, i) &#123;</span><br><span class="line">    &#x2F;&#x2F;如果码点大于了16位二进制的最大值，则其是32位的</span><br><span class="line">    return char.codePointAt(i) &gt; 0xffff;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 得到一个字符串码点的真实长度</span><br><span class="line"> * @param &#123;*&#125; str</span><br><span class="line"> *&#x2F;</span><br><span class="line">function getLengthOfCodePoint(str) &#123;</span><br><span class="line">    var len &#x3D; 0;</span><br><span class="line">    for (let i &#x3D; 0; i &lt; str.length; i++) &#123;</span><br><span class="line">        &#x2F;&#x2F;i在索引码元</span><br><span class="line">        if (is32bit(str, i)) &#123;</span><br><span class="line">            &#x2F;&#x2F;当前字符串，在i这个位置，占用了两个码元</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    return len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="更多的字符串-API"><a href="#更多的字符串-API" class="headerlink" title="更多的字符串 API"></a>更多的字符串 API</h3><ul>
<li>includes 判断字符串中是否包含指定的子字符串</li>
<li>startsWith 判断字符串中是否以指定的字符串开始</li>
<li>endsWith 判断字符串中是否以指定的字符串结束</li>
<li>repeat 将字符串重复指定的次数，返回一个新字符串</li>
</ul>
<h3 id="扩展-正则中的粘连标记"><a href="#扩展-正则中的粘连标记" class="headerlink" title="[扩展]正则中的粘连标记"></a>[扩展]正则中的粘连标记</h3><p>标记名：y</p>
<p>含义：匹配时，完全按照正则对象中的 lastIndex 位置开始匹配，并且匹配的位置必须在 lastIndex 位置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const text &#x3D; &#39;Hello World&#39;;</span><br><span class="line">const reg &#x3D; &#x2F;W\w+&#x2F;y; &#x2F;&#x2F;以W开头的字符串</span><br><span class="line">console.log(&#39;reg.lastIndex：&#39;, reg.lastIndex);&#x2F;&#x2F;0</span><br><span class="line">console.log(reg.test(text));&#x2F;&#x2F;false</span><br><span class="line"></span><br><span class="line">const text &#x3D; &#39;Hello World&#39;;</span><br><span class="line">const reg &#x3D; &#x2F;W\w+&#x2F;;</span><br><span class="line">console.log(&#39;reg.lastIndex：&#39;, reg.lastIndex);&#x2F;&#x2F;0</span><br><span class="line">console.log(reg.test(text));&#x2F;&#x2F;true</span><br><span class="line"></span><br><span class="line">const text &#x3D; &#39;Hello World&#39;;</span><br><span class="line">const reg &#x3D; &#x2F;W\w+&#x2F;y; &#x2F;&#x2F;以W开头的字符串</span><br><span class="line"> reg.lastIndex&#x3D;6</span><br><span class="line">console.log(&#39;reg.lastIndex：&#39;, reg.lastIndex);&#x2F;&#x2F;6</span><br><span class="line">console.log(reg.test(text));&#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>

<h3 id="模板字符串标记-扩展"><a href="#模板字符串标记-扩展" class="headerlink" title="模板字符串标记[扩展]"></a>模板字符串标记[扩展]</h3><ul>
<li>模板字符串就是`${…}`</li>
<li>String.raw`&lt;p&gt;…&lt;/p&gt;` 加上 String.raw 标记后，里面的符号全部是字符串(无需转义)</li>
<li>自定义标记</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">var text &#x3D; myTag&#96;邓哥喜欢$&#123;love1&#125;，邓哥也喜欢$&#123;love2&#125;。&#96;;</span><br><span class="line">function myTag(parts) &#123;</span><br><span class="line">    const values &#x3D; Array.prototype.slice.apply(arguments).slice(1);</span><br><span class="line">    let str &#x3D; &quot;&quot;;</span><br><span class="line">    for (let i &#x3D; 0; i &lt; values.length; i++) &#123;</span><br><span class="line">        str +&#x3D; &#96;$&#123;parts[i]&#125;：$&#123;values[i]&#125;&#96;;</span><br><span class="line">        if (i &#x3D;&#x3D;&#x3D; values.length - 1) &#123;</span><br><span class="line">            str +&#x3D; parts[i + 1];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return str;</span><br><span class="line">&#125;</span><br><span class="line">console.log(text);  &#x2F;&#x2F;邓哥喜欢：秋葵，邓哥也喜欢：香菜。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">safe&#96;&lt;p&gt;xx&lt;&#x2F;p&gt;&#96; &#x2F;&#x2F;可以处理当内容为标签时出现的bug</span><br><span class="line"></span><br><span class="line">function safe(parts)&#123;</span><br><span class="line">    const values &#x3D; Array.prototype.slice.apply(arguments).slice(1);</span><br><span class="line">    let str &#x3D; &quot;&quot;;</span><br><span class="line">    for (let i &#x3D; 0; i &lt; values.length; i++) &#123;</span><br><span class="line">        const v &#x3D; values[i].replace(&#x2F;&lt;&#x2F;g, &quot;&lt;&quot;).replace(&#x2F;&gt;&#x2F;g, &quot;&gt;&quot;);</span><br><span class="line">        str +&#x3D; parts[i] + v;</span><br><span class="line">        if (i &#x3D;&#x3D;&#x3D; values.length - 1) &#123;</span><br><span class="line">            str +&#x3D; parts[i + 1];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="参数默认值"><a href="#参数默认值" class="headerlink" title="参数默认值"></a>参数默认值</h2><p>在书写形参时，直接给形参赋值，附的值即为默认值</p>
<p>这样一来，当调用函数时，如果没有给对应的参数赋值（给它的值是 undefined），则会自动使用默认值。</p>
<p>注意不要用 null，用 null 会转成 0</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function sum(a, b &#x3D; 1, c &#x3D; 2) &#123;</span><br><span class="line">    return a + b + c;</span><br><span class="line">&#125;</span><br><span class="line">console.log(sum(10, undefined, undefined))</span><br><span class="line">console.log(sum(1, undefined, 5))</span><br><span class="line">console.log(sum(11))&#x2F;&#x2F;后面都是undefined可以省略</span><br></pre></td></tr></table></figure>

<h3 id="对-arguments-的影响-扩展"><a href="#对-arguments-的影响-扩展" class="headerlink" title="对 arguments 的影响[扩展]"></a>对 arguments 的影响[扩展]</h3><p>只要给函数加上参数默认值，该函数会自动变量严格模式(use strict)下的规则：arguments 和形参脱离，尽量不要用 arguments。</p>
<h3 id="留意暂时性死区-扩展"><a href="#留意暂时性死区-扩展" class="headerlink" title="留意暂时性死区[扩展]"></a>留意暂时性死区[扩展]</h3><p>形参和 ES6 中的 let 或 const 声明一样，具有作用域，并且根据参数的声明顺序，存在暂时性死区。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function test(a &#x3D; b, b) &#123;</span><br><span class="line">    console.log(a, b);</span><br><span class="line">&#125;</span><br><span class="line">test(undefined, 2);&#x2F;&#x2F;报错，不能在b声明前使用</span><br></pre></td></tr></table></figure>

<h2 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h2><ul>
<li><strong>arguments 的缺陷：</strong><ol>
<li>如果和形参配合使用，容易导致混乱</li>
<li>从语义上，使用 arguments 获取参数，由于形参缺失，无法从函数定义上理解函数的真实意图</li>
</ol>
</li>
</ul>
<h3 id="剩余参数-1"><a href="#剩余参数-1" class="headerlink" title="剩余参数"></a>剩余参数</h3><p>ES6 的剩余参数专门用于收集末尾的所有参数，将其放置到一个形参数组中。</p>
<ul>
<li><strong>细节：</strong><ol>
<li>一个函数，仅能出现一个剩余参数</li>
<li>一个函数，如果有剩余参数，剩余参数必须是最后一个参数</li>
<li>以后尽量用这个，少用 arguments</li>
</ol>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function (...形参名)&#123;</span><br><span class="line">&#x2F;&#x2F;这里是收集所有参数，形成一个数组</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function (...args)&#123;</span><br><span class="line">console.log(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="展开运算符"><a href="#展开运算符" class="headerlink" title="展开运算符"></a>展开运算符</h2><p>将数组的每一项展开，依次作为参数传递，而不是把整个数组作为一个参数传递</p>
<ul>
<li>展开函数参数</li>
<li>展开数组 es6</li>
<li>展开对象(可用于混合对象) es7</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">console.log(sum(...numbers))&#x2F;&#x2F;展开参数，相当于传递了10个参数</span><br><span class="line">console.log(sum(1, 3, ...numbers, 3, 5))&#x2F;&#x2F;展开数组</span><br><span class="line">const arr2 &#x3D; [0, ...arr1, 1];</span><br><span class="line"></span><br><span class="line">const obj &#x3D; &#123; &#x2F;&#x2F;展开对象，混合对象</span><br><span class="line">    ...obj1,</span><br><span class="line">    ...obj2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="应用：剩余参数和展开运算符实现柯里化"><a href="#应用：剩余参数和展开运算符实现柯里化" class="headerlink" title="应用：剩余参数和展开运算符实现柯里化"></a>应用：剩余参数和展开运算符实现柯里化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function cal(a, b, c, d) &#123;</span><br><span class="line">    return a + b * c - d;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;curry：柯里化，用户固定某个函数的前面的参数，得到一个新的函数，新的函数调用时，接收剩余的参数</span><br><span class="line">function curry(func, ...args) &#123;</span><br><span class="line">    return function(...subArgs) &#123;</span><br><span class="line">        const allArgs &#x3D; [...args, ...subArgs];</span><br><span class="line">        if (allArgs.length &gt;&#x3D; func.length) &#123;</span><br><span class="line">            &#x2F;&#x2F;参数够了</span><br><span class="line">            return func(...allArgs);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F;参数不够，继续固定</span><br><span class="line">            return curry(func, ...allArgs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const newCal &#x3D; curry(cal, 1, 2)</span><br><span class="line"></span><br><span class="line">console.log(newCal(3, 4)) &#x2F;&#x2F; 1+2*3-4</span><br><span class="line">console.log(newCal(4, 5)) &#x2F;&#x2F; 1+2*4-5</span><br></pre></td></tr></table></figure>

<h2 id="明确函数的双重用途"><a href="#明确函数的双重用途" class="headerlink" title="明确函数的双重用途"></a>明确函数的双重用途</h2><p>ES6 提供了一个特殊的 API，可以使用该 API 在函数内部，判断该函数是否使用了 new 来调用</p>
<ul>
<li>new.target 判断是否使用 new 来调用<ul>
<li>是则返回函数体</li>
<li>反之返回 undefined</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function Person(firstName, lastName) &#123;</span><br><span class="line">    &#x2F;&#x2F;判断是否是使用new的方式来调用的函数</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; &#x2F;&#x2F;过去的判断方式</span><br><span class="line">    &#x2F;&#x2F; if (!(this instanceof Person)) &#123;</span><br><span class="line">    &#x2F;&#x2F;     throw new Error(&quot;该函数没有使用new来调用&quot;)</span><br><span class="line">    &#x2F;&#x2F; &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;新的完美方式</span><br><span class="line">    if (new.target &#x3D;&#x3D;&#x3D; undefined) &#123;</span><br><span class="line">        throw new Error(&quot;该函数没有使用new来调用&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    this.firstName &#x3D; firstName;</span><br><span class="line">    this.lastName &#x3D; lastName;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>回顾：this 指向</p>
<ol>
<li>通过对象调用函数，this 指向对象</li>
<li>直接调用函数，this 指向全局对象</li>
<li>如果通过 new 调用函数，this 指向新创建的对象</li>
<li>如果通过 apply、call、bind 调用函数，this 指向指定的数据</li>
<li>如果是 DOM 事件函数，this 指向事件源</li>
</ol>
<h3 id="使用语法"><a href="#使用语法" class="headerlink" title="使用语法"></a>使用语法</h3><p>箭头函数是一个函数表达式，理论上，任何使用函数表达式的场景都可以使用箭头函数。</p>
<p>完整语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(参数1, 参数2, ...)&#x3D;&gt;&#123;</span><br><span class="line">    &#x2F;&#x2F;函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>==<strong>如果参数只有一个，可以省略小括号</strong>==</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const print &#x3D; function(num)&#123;</span><br><span class="line">    console.log(num);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;箭头函数</span><br><span class="line">const print &#x3D; num &#x3D;&gt; &#123;</span><br><span class="line">    console.log(num)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>==<strong>如果箭头函数只有一条返回语句，可以省略大括号，和 return 关键字</strong>==</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var num &#x3D; function fn(a)&#123;</span><br><span class="line">    return a*2;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;箭头函数</span><br><span class="line">var num &#x3D; a &#x3D;&gt; a*2;</span><br></pre></td></tr></table></figure>

<ul>
<li>==<strong>如果是对象形式则写成 =&gt; ({……})</strong>==</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const sum &#x3D; function(a,b)&#123;</span><br><span class="line">    a: a,</span><br><span class="line">    b: b,</span><br><span class="line">    sum: a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const sum &#x3D; (a, b) &#x3D;&gt; (&#123;</span><br><span class="line">    a: a,</span><br><span class="line">    b: b,</span><br><span class="line">    sum: a + b</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="注意细节"><a href="#注意细节" class="headerlink" title="注意细节"></a>注意细节</h3><ul>
<li>箭头函数中，==不存在 this、arguments、new.target==，如果使用了，则使用的是函数外层的对应的 this、arguments、new.target</li>
<li>箭头函数没有原型</li>
<li>箭头函数不能作用构造函数使用</li>
</ul>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ol>
<li>临时性使用的函数，并不会可以调用它，比如：<ol>
<li>事件处理函数</li>
<li>异步处理函数</li>
<li>其他临时性的函数</li>
</ol>
</li>
<li>为了绑定外层 this 的函数</li>
<li>在不影响其他代码的情况下，保持代码的简洁，最常见的，数组方法中的回调函数</li>
<li>==<strong>注意：对象里面的函数不要用箭头函数，因为会产生 this 指向的问题，如下</strong>==<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const obj&#x3D;&#123;</span><br><span class="line">    a: 1,</span><br><span class="line">    b: 2,</span><br><span class="line">    c: function()&#123;</span><br><span class="line">        ……</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>对于数组的应用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const numbers &#x3D; [3,4,5,6,7,8]</span><br><span class="line">const result &#x3D; numbers.filter(num &#x3D;&gt; num%2 !&#x3D;&#x3D; 0) &#x2F;&#x2F;过滤出为奇数的值</span><br><span class="line">    .map(num &#x3D;&gt; num * 2) &#x2F;&#x2F;映射，将数字乘以2</span><br><span class="line">    .reduce((a,b) &#x3D;&gt; a + b,0); &#x2F;&#x2F;累计，将数字累计相加</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><h2 id="新增的对象字面量语法"><a href="#新增的对象字面量语法" class="headerlink" title="新增的对象字面量语法"></a>新增的对象字面量语法</h2><ol>
<li>成员速写</li>
</ol>
<p>如果对象字面量初始化时，成员的名称来自于一个变量，并且和变量的名称相同，则可以进行简写</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function createUser(username,password)&#123;</span><br><span class="line">    const func &#x3D; function()&#123;</span><br><span class="line">        ……</span><br><span class="line">    &#125;</span><br><span class="line">    return &#123;</span><br><span class="line">        username, &#x2F;&#x2F;相当于username:username</span><br><span class="line">        password,</span><br><span class="line">        func &#x2F;&#x2F;相当于func:func</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">createUser(&#39;admin&#39;,&#39;123456&#39;);&#x2F;&#x2F;&#123;username:&#39;admin&#39;,password:&#39;123456&#39;,func:function()&#123;……&#125;&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>方法速写</li>
</ol>
<p>对象字面量初始化时，方法可以省略冒号和 function 关键字</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const user &#x3D; &#123;</span><br><span class="line">    name:&quot;姬成&quot;,</span><br><span class="line">    age:100,</span><br><span class="line">    func()&#123;……&#125; &#x2F;&#x2F;相当于func:function()&#123;……&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>计算属性名</li>
</ol>
<p>有的时候，初始化对象时，某些属性名可能来自于某个表达式的值，在 ES6，可以使用中括号来表示该属性名是通过计算得到的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const prop1 &#x3D; &quot;name&quot;;</span><br><span class="line">const prop2 &#x3D; &quot;age&quot;;</span><br><span class="line">const prop3 &#x3D; &quot;func&quot;;</span><br><span class="line"></span><br><span class="line">const user &#x3D; &#123;</span><br><span class="line">    [prop1]:&quot;姬成&quot;,</span><br><span class="line">    [prop2]:18,</span><br><span class="line">    [prop3]():&#123;</span><br><span class="line">        console.log(this[prop1],this[prop2])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">user[prop3]();&#x2F;&#x2F;姬成,18</span><br><span class="line">console.log(uesr);&#x2F;&#x2F;&#123;name:&quot;姬成&quot;,age:18,func:f&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Object-的新增-API"><a href="#Object-的新增-API" class="headerlink" title="Object 的新增 API"></a>Object 的新增 API</h2><p>Object 是一个构造函数（说对象的去反省）</p>
<ul>
<li>Object.is 用于判断两个对象是否相等<ul>
<li>基本上跟严格相等（===）是一致的，除了以下两点：</li>
<li>NaN 和 NaN 相等(=== 是 false)</li>
<li>+0 和-0 不相等(=== 是 true)</li>
</ul>
</li>
<li>Object.assign 用于混合对象(es6 的方法，不推荐用)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const obj &#x3D; &#123; &#x2F;&#x2F;这里是展开运算符，es7的方法，最常用</span><br><span class="line">    ...obj1,</span><br><span class="line">    ...obj2</span><br><span class="line">&#125;</span><br><span class="line">const obj &#x3D; Object.assign(obj1,obj2);&#x2F;&#x2F;obj1会被改动，可以用巧妙的方法避免</span><br><span class="line">const obj &#x3D; Object.assign(&#123;&#125;,obj1,obj2);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol start="3">
<li>Object.getOwnPropertyNames 的枚举顺序</li>
</ol>
<p>Object.getOwnPropertyNames 方法之前就存在，只不过，官方没有明确要求，对属性的顺序如何排序，如何排序，完全由浏览器厂商决定。</p>
<p>ES6 规定了该方法返回的数组的排序方式如下：</p>
<ul>
<li>先排数字，并按照升序排序</li>
<li>再排其他，按照书写顺序排序</li>
</ul>
<ol start="4">
<li>Object.setPrototypeOf</li>
</ol>
<p>该函数用于设置某个对象的隐式原型</p>
<p>比如： Object.setPrototypeOf(obj1, obj2)</p>
<p>相当于： <code>obj1.__proto__ = obj2</code></p>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>面向对象：一种编程思想，跟具体的语言</p>
<p>对比面向过程：</p>
<ul>
<li>面向过程：思考的切入点是功能的步骤</li>
<li>面向对象：思考的切入点是对象的划分</li>
</ul>
<h2 id="类：构造函数的语法糖"><a href="#类：构造函数的语法糖" class="headerlink" title="类：构造函数的语法糖"></a>类：构造函数的语法糖</h2><ul>
<li>传统的构造函数的问题<ol>
<li>属性和原型方法定义分离，降低了可读性</li>
<li>原型成员可以被遍历</li>
<li>默认情况下，构造函数仍然可以被当作普通函数使用</li>
</ol>
</li>
</ul>
<h3 id="类的特点"><a href="#类的特点" class="headerlink" title="类的特点"></a>类的特点</h3><ol>
<li>类声明不会被提升(window.不会找到)，与 let 和 const 一样，存在暂时性死区(先定义再使用)</li>
<li>类中的所有代码均在严格模式下执行(自动加的)</li>
<li>类的所有方法都是不可枚举的</li>
<li>类的所有方法都无法被当作构造函数使用</li>
<li>类的构造器必须使用 new 来调用，否则会报错（没有 new，不能调用类构造函数）</li>
</ol>
<h3 id="类的写法"><a href="#类的写法" class="headerlink" title="类的写法"></a>类的写法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;原先写法</span><br><span class="line">function Animal(type, name, age, sex) &#123;</span><br><span class="line">    this.type &#x3D; type;</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">    this.age &#x3D; age;</span><br><span class="line">    this.sex &#x3D; sex;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;定义实例方法（原型方法）</span><br><span class="line">Animal.prototype.print &#x3D; function () &#123;</span><br><span class="line">    console.log(&#96;【种类】：$&#123;this.type&#125;&#96;);</span><br><span class="line">    console.log(&#96;【名字】：$&#123;this.name&#125;&#96;);</span><br><span class="line">    console.log(&#96;【年龄】：$&#123;this.age&#125;&#96;);</span><br><span class="line">    console.log(&#96;【性别】：$&#123;this.sex&#125;&#96;);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;类的写法</span><br><span class="line">class Animal &#123;</span><br><span class="line">    constructor(type, name, age, sex) &#123;</span><br><span class="line">        this.type &#x3D; type;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">        this.age &#x3D; age;</span><br><span class="line">        this.sex &#x3D; sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    print() &#123;</span><br><span class="line">        console.log(&#96;【种类】：$&#123;this.type&#125;&#96;);</span><br><span class="line">        console.log(&#96;【名字】：$&#123;this.name&#125;&#96;);</span><br><span class="line">        console.log(&#96;【年龄】：$&#123;this.age&#125;&#96;);</span><br><span class="line">        console.log(&#96;【性别】：$&#123;this.sex&#125;&#96;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类的其他书写方式"><a href="#类的其他书写方式" class="headerlink" title="类的其他书写方式"></a>类的其他书写方式</h2><ol>
<li><p>可计算的成员名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">const printName &#x3D; &quot;print&quot;;</span><br><span class="line"></span><br><span class="line">class Animal &#123;</span><br><span class="line">    constructor(type, name, age, sex) &#123;</span><br><span class="line">        this.type &#x3D; type;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">        this.age &#x3D; age;</span><br><span class="line">        this.sex &#x3D; sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [printName]() &#123;</span><br><span class="line">        console.log(&#96;【种类】：$&#123;this.type&#125;&#96;);</span><br><span class="line">        console.log(&#96;【名字】：$&#123;this.name&#125;&#96;);</span><br><span class="line">        console.log(&#96;【年龄】：$&#123;this.age&#125;&#96;);</span><br><span class="line">        console.log(&#96;【性别】：$&#123;this.sex&#125;&#96;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const a &#x3D; new Animal(&quot;狗&quot;, &quot;旺财&quot;, 3, &quot;男&quot;);</span><br><span class="line">a[printName]();</span><br></pre></td></tr></table></figure>
</li>
<li><p>getter 和 setter</p>
</li>
</ol>
<p>Object.defineProperty 可定义某个对象成员属性的读取和设置</p>
<p>使用 getter 和 setter 控制的属性，不在原型上，相当于 obj.xx</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">const printName &#x3D; &quot;print&quot;;</span><br><span class="line">class Animal &#123;</span><br><span class="line">    constructor(type, name, age, sex) &#123;</span><br><span class="line">        this.type &#x3D; type;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">        this.age &#x3D; age;</span><br><span class="line">        this.sex &#x3D; sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;创建一个age属性，并给它加上getter，读取该属性时，会运行该函数</span><br><span class="line">    get age() &#123;</span><br><span class="line">        return this._age + &quot;岁&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;创建一个age属性，并给它加上setter，给该属性赋值时，会运行该函数</span><br><span class="line">    set age(age) &#123;</span><br><span class="line">        if (typeof age !&#x3D;&#x3D; &quot;number&quot;) &#123;</span><br><span class="line">            throw new TypeError(&quot;age property must be a number&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (age &lt; 0) &#123;</span><br><span class="line">            age &#x3D; 0;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (age &gt; 1000) &#123;</span><br><span class="line">            age &#x3D; 1000;</span><br><span class="line">        &#125;</span><br><span class="line">        this._age &#x3D; age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [printName]() &#123;</span><br><span class="line">        console.log(&#96;【种类】：$&#123;this.type&#125;&#96;);</span><br><span class="line">        console.log(&#96;【名字】：$&#123;this.name&#125;&#96;);</span><br><span class="line">        console.log(&#96;【年龄】：$&#123;this.age&#125;&#96;);</span><br><span class="line">        console.log(&#96;【性别】：$&#123;this.sex&#125;&#96;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var a &#x3D; new Animal(&quot;狗&quot;, &quot;旺财&quot;, 3, &quot;男&quot;);</span><br><span class="line">console.log(a.age); &#x2F;&#x2F; 3岁</span><br><span class="line">a.age &#x3D; 4; &#x2F;&#x2F;age赋值为4</span><br><span class="line">a.print(); &#x2F;&#x2F;打印信息</span><br><span class="line">&#x2F;&#x2F;备注：getter\setter也可以通过成员名的方式实现，但是哪个必须调用方法名，不如这个直观</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>静态成员</li>
</ol>
<p>构造函数本身的成员</p>
<p>使用 static 关键字定义的成员即静态成员</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Chess &#123;</span><br><span class="line">    constructor(name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line">    static width &#x3D; 50;</span><br><span class="line">    static height &#x3D; 50;</span><br><span class="line">    static method() &#123;</span><br><span class="line">    ……</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;调用</span><br><span class="line">console.log(Chess.width)</span><br><span class="line">console.log(Chess.height)</span><br><span class="line">Chess.method();</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>字段初始化器（ES7）</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Test &#123;</span><br><span class="line">    static a &#x3D; 1; &#x2F;&#x2F;这里是加静态属性</span><br><span class="line">    b &#x3D; 2; &#x2F;&#x2F;此处相当于 在构造方法里面加 this.b &#x3D; 2;</span><br><span class="line">    c &#x3D; 3;</span><br><span class="line"></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        this.d &#x3D; this.b + this.c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    print &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">        console.log(this.a) &#x2F;&#x2F;用箭头函数时，this指向当前对象</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const t &#x3D; new Test();</span><br><span class="line">console.log(t)</span><br></pre></td></tr></table></figure>

<p>注意：<br>1). 使用 static 的字段初始化器，添加的是静态成员<br>2). 没有使用 static 的字段初始化器，添加的成员位于对象上<br>3). 箭头函数在字段初始化器位置上，指向当前对象</p>
<ol start="5">
<li>类表达式</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const A &#x3D; class &#123; &#x2F;&#x2F;匿名类，类表达式</span><br><span class="line">    a &#x3D; 1;</span><br><span class="line">    b &#x3D; 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const a &#x3D; new A();</span><br><span class="line">console.log(a)</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>[扩展]装饰器（ES7）(Decorator)</li>
</ol>
<p>横切关注点</p>
<p>装饰器的本质是一个函数</p>
<p>目前还没有很好的支持</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Test &#123;</span><br><span class="line"></span><br><span class="line">    @Obsolete</span><br><span class="line">    print() &#123;</span><br><span class="line">        console.log(&quot;print方法&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Obsolete(target, methodName, descriptor) &#123;</span><br><span class="line">    &#x2F;&#x2F; function Test</span><br><span class="line">    &#x2F;&#x2F; print</span><br><span class="line">    &#x2F;&#x2F; &#123; value: function print()&#123;&#125;, ... &#125;</span><br><span class="line">    &#x2F;&#x2F; console.log(target, methodName, descriptor);</span><br><span class="line">    const oldFunc &#x3D; descriptor.value</span><br><span class="line">    descriptor.value &#x3D; function (...args) &#123;</span><br><span class="line">        console.warn(&#96;$&#123;methodName&#125;方法已过时&#96;);</span><br><span class="line">        oldFunc.apply(this, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h2><p>如果两个类 A 和 B，如果可以描述为：B 是 A，则，A 和 B 形成继承关系</p>
<p>如果 B 是 A，则：</p>
<ol>
<li>B 继承自 A</li>
<li>A 派生 B</li>
<li>B 是 A 的子类</li>
<li>A 是 B 的父类</li>
</ol>
<p>如果 A 是 B 的父类，则 B 会自动拥有 A 中的所有实例成员。</p>
<h3 id="关键字："><a href="#关键字：" class="headerlink" title="关键字："></a>关键字：</h3><ul>
<li>extends：继承，用于类的定义</li>
<li>super<ul>
<li>直接当作函数调用，表示父类构造函数</li>
<li>如果当作对象使用，则表示父类的原型</li>
<li>注意：ES6 要求，如果定义了 constructor，并且该类是子类，则必须在 constructor 的第一行手动调用父类的构造函数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Dog extends Animal &#123; &#x2F;&#x2F; Dog 继承自 Animal</span><br><span class="line">constructor(name, age, sex) &#123;</span><br><span class="line">    super(&quot;犬类&quot;, name, age, sex);&#x2F;&#x2F;必须先调用一次super，否则会报错（必须要在函数的最开始位置调用父类的构造函数）</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果子类不写 constructor，则会有默认的构造器，该构造器需要的参数和父类一致，并且自动调用父类构造器</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="继承的写法"><a href="#继承的写法" class="headerlink" title="继承的写法"></a>继承的写法</h3><ul>
<li>原来的方式</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">function Animal(type, name, age, sex) &#123;</span><br><span class="line">    this.type &#x3D; type;</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">    this.age &#x3D; age;</span><br><span class="line">    this.sex &#x3D; sex;</span><br><span class="line">&#125;</span><br><span class="line">Animal.prototype.print &#x3D; function () &#123;</span><br><span class="line">    console.log(&#96;【种类】：$&#123;this.type&#125;&#96;);</span><br><span class="line">    console.log(&#96;【名字】：$&#123;this.name&#125;&#96;);</span><br><span class="line">    console.log(&#96;【年龄】：$&#123;this.age&#125;&#96;);</span><br><span class="line">    console.log(&#96;【性别】：$&#123;this.sex&#125;&#96;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Dog(name, age, sex) &#123;</span><br><span class="line">    &#x2F;&#x2F;借用父类的构造函数</span><br><span class="line">    Animal.call(this, &quot;犬类&quot;, name, age, sex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Object.setPrototypeOf(Dog.prototype, Animal.prototype);</span><br><span class="line">&#x2F;&#x2F;将Dog.prototype的隐式原型指向Animal的原型，使继承关系完整</span><br><span class="line"></span><br><span class="line">const d &#x3D; new Dog(&quot;旺财&quot;, 3, &quot;公&quot;);</span><br><span class="line">d.print();</span><br><span class="line">console.log(d);</span><br></pre></td></tr></table></figure>

<ul>
<li>类的继承（ES6 的写法）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">    constructor(type, name, age, sex) &#123;</span><br><span class="line">        this.type &#x3D; type;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">        this.age &#x3D; age;</span><br><span class="line">        this.sex &#x3D; sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    print() &#123;</span><br><span class="line">        console.log(&#96;【种类】：$&#123;this.type&#125;&#96;);</span><br><span class="line">        console.log(&#96;【名字】：$&#123;this.name&#125;&#96;);</span><br><span class="line">        console.log(&#96;【年龄】：$&#123;this.age&#125;&#96;);</span><br><span class="line">        console.log(&#96;【性别】：$&#123;this.sex&#125;&#96;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    jiao()&#123;</span><br><span class="line">        throw new Error(&quot;动物怎么叫的？&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dog extends Animal &#123; &#x2F;&#x2F; Dog 继承自 Animal</span><br><span class="line">    constructor(name, age, sex) &#123;</span><br><span class="line">        super(&quot;犬类&quot;, name, age, sex);</span><br><span class="line">        &#x2F;&#x2F; 子类特有的属性</span><br><span class="line">        this.loves &#x3D; &quot;吃骨头&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    print()&#123;</span><br><span class="line">        &#x2F;&#x2F;调用父类的print</span><br><span class="line">        super.print();</span><br><span class="line">        &#x2F;&#x2F;自己特有的代码</span><br><span class="line">        console.log(&#96;【爱好】：$&#123;this.loves&#125;&#96;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;同名方法，会覆盖父类</span><br><span class="line">    jiao()&#123;</span><br><span class="line">        console.log(&quot;旺旺！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const d &#x3D; new Dog(&quot;旺财&quot;, 3, &quot;公&quot;);</span><br><span class="line">d.print(); &#x2F;&#x2F; 打印自己的print()</span><br><span class="line">console.log(d) &#x2F;&#x2F; 打印d的所有属性</span><br><span class="line">d.jiao(); &#x2F;&#x2F; 旺旺</span><br></pre></td></tr></table></figure>

<h3 id="【小知识】"><a href="#【小知识】" class="headerlink" title="【小知识】"></a>【小知识】</h3><ul>
<li>用 JS 制作抽象类<ul>
<li>抽象类：一般是父类，不能通过该类创建对象</li>
</ul>
</li>
<li>正常情况下，this 的指向，this 始终指向具体的类的对象</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">    constructor(type, name, age, sex) &#123;</span><br><span class="line">        if (new.target &#x3D;&#x3D;&#x3D; Animal) &#123; &#x2F;&#x2F;如果构造函数是Animal</span><br><span class="line">            throw new TypeError(&quot;你不能直接创建Animal的对象，应该通过子类创建&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        this.type &#x3D; type;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">        this.age &#x3D; age;</span><br><span class="line">        this.sex &#x3D; sex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Dog extends Animal &#123;</span><br><span class="line">    constructor(name, age, sex) &#123;</span><br><span class="line">        super(&quot;犬类&quot;, name, age, sex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">const a &#x3D; new Animal(&quot;狗&quot;,&quot;旺柴&quot;,2,&quot;公&quot;); &#x2F;&#x2F; 会报错 你不能……</span><br><span class="line">const a &#x3D; new Dog(&quot;狗&quot;,&quot;旺柴&quot;,2,&quot;公&quot;); &#x2F;&#x2F;不会报错</span><br></pre></td></tr></table></figure>

<h1 id="解构"><a href="#解构" class="headerlink" title="解构"></a>解构</h1><p>使用 ES6 的一种语法规则，将一个对象或数组的某个属性提取到某个变量中。</p>
<h2 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h2><ul>
<li>写法：<code>let &#123;name,age,sex,address&#125; = user;</code></li>
<li>当对象没有{}里面的属性时，默认 undefined</li>
<li>在解构中使用默认值：<code>&#123;同名变量 = 默认值&#125; </code></li>
<li>非同名属性解构：<code>&#123;属性名:变量名&#125;</code></li>
<li><strong>解构不会对被解构的目标造成任何影响</strong></li>
<li>深层次解构：<code>let &#123;address:&#123;province&#125;&#125; = user</code>，相当于定义变量 province,把属性值同名属性赋给变量</li>
<li>可配合展开运算符</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">const user &#x3D; &#123;</span><br><span class="line">    name: &quot;kevin&quot;,</span><br><span class="line">    age: 11,</span><br><span class="line">    sex: &quot;男&quot;,</span><br><span class="line">    address: &#123;</span><br><span class="line">        province: &quot;四川&quot;,</span><br><span class="line">        city: &quot;成都&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let name,age,sex,address; &#x2F;&#x2F;定义4个变量</span><br><span class="line">(&#123;name,age,sex,address&#125; &#x3D; user);&#x2F;&#x2F;把user同名属性赋值到变量里面</span><br><span class="line"></span><br><span class="line">let &#123;name,age,sex,address&#125; &#x3D; user; &#x2F;&#x2F;简写，意义同上</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;在解构中使用默认值</span><br><span class="line">let &#123;name,age,sex &#x3D; &#39;男&#39;,address&#125; &#x3D; user; &#x2F;&#x2F;如果没有sex属性，sex变量默认为男</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;非同名属性解构    &#123;属性名:变量名&#125;</span><br><span class="line">let &#123; name, age,sex: gender, address &#125; &#x3D; user;&#x2F;&#x2F;把sex属性值给变量gender</span><br><span class="line">console.log(name, age, gender, address)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;深层次解构    &#123;属性名:变量名&#125;</span><br><span class="line">let &#123; name, age,sex, address:&#123;province,city&#125; &#125; &#x3D; user;&#x2F;&#x2F;把sex属性值给变量gender</span><br><span class="line">console.log(name, age, gender, province,city); &#x2F;&#x2F;kevin 11 男 四川 成都</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;展开运算符 解构出name，然后，剩余的所有属性，放到一个新的对象中，变量名为obj</span><br><span class="line">&#x2F;&#x2F; name: kevin</span><br><span class="line">&#x2F;&#x2F; obj : &#123;age:11, sex:&quot;男&quot;, address:&#123;...&#125;&#125;</span><br><span class="line"></span><br><span class="line">const &#123; name, ...obj &#125; &#x3D; user;</span><br></pre></td></tr></table></figure>

<h2 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构"></a>数组解构</h2><ul>
<li>写法：<code>const [n1, n2] = numbers; </code></li>
<li>对象的解构方法也行得通</li>
<li>其他用法同对象解构一致，用法在下面</li>
<li>可配合展开运算符来用</li>
<li>小题目：不用第三个变量交换变量数据：[a,b] = [b,a]</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">const numbers &#x3D; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 用对象的方法来解构，数组本身也是对象</span><br><span class="line">const &#123;</span><br><span class="line">    0: n1,</span><br><span class="line">    1: n2</span><br><span class="line">&#125; &#x3D; numbers;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let n1, n2;</span><br><span class="line">([n1, n2] &#x3D; numbers); &#x2F;&#x2F; 数组解构方法</span><br><span class="line"></span><br><span class="line">const [n1, n2] &#x3D; numbers;&#x2F;&#x2F;数组解构简写方法。</span><br><span class="line"></span><br><span class="line">const numbers &#x3D; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, [1, 2, 3, 4]];</span><br><span class="line">&#x2F;&#x2F;得到numbers下标为4的数组中的下标为2的数据，放到变量n中</span><br><span class="line">const [, , , , [, , n]] &#x3D; numbers;</span><br><span class="line"></span><br><span class="line">const numbers &#x3D; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &#123;</span><br><span class="line">    a: 1,</span><br><span class="line">    b: 2</span><br><span class="line">&#125;];</span><br><span class="line">&#x2F;&#x2F;得到numbers下标为4的数组的属性a，赋值给变量A</span><br><span class="line">const [, , , , &#123; a: A &#125;] &#x3D; numbers;</span><br><span class="line">const &#123; a: A &#125; &#x3D; numbers[4];&#x2F;&#x2F;和上面意义相同，灵活的写法</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 展开运算符： 得到数组前两项，分别放到变量a和b中，然后剩余的所有数据放到数组nums</span><br><span class="line">const numbers &#x3D; [324, 7, 23, 5, 3243];</span><br><span class="line">const [a, b, ...nums] &#x3D; numbers;</span><br></pre></td></tr></table></figure>

<h3 id="对象数组解构练习题"><a href="#对象数组解构练习题" class="headerlink" title="对象数组解构练习题"></a>对象数组解构练习题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">const article &#x3D; &#123;</span><br><span class="line">          title: &quot;文章标题&quot;,</span><br><span class="line">          content: &quot;文章内容&quot;,</span><br><span class="line">          comments: [&#123;</span><br><span class="line">              content: &quot;评论1&quot;,</span><br><span class="line">              user: &#123;</span><br><span class="line">                  id: 1,</span><br><span class="line">                  name: &quot;用户名1&quot;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;, &#123;</span><br><span class="line">              content: &quot;评论2&quot;,</span><br><span class="line">              user: &#123;</span><br><span class="line">                  id: 2,</span><br><span class="line">                  name: &quot;用户名2&quot;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;]</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F;解构出第二条评论的用户名和评论内容</span><br><span class="line">      &#x2F;&#x2F; name:&quot;用户名2&quot;  content:&quot;评论2&quot;</span><br><span class="line"></span><br><span class="line">      const &#123;</span><br><span class="line">          comments: [, &#123;</span><br><span class="line">              content,</span><br><span class="line">              user: &#123;</span><br><span class="line">                  name</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;]</span><br><span class="line">      &#125; &#x3D; article;</span><br><span class="line">      console.log(content, name);&#x2F;&#x2F;评论2 用户名2</span><br><span class="line"></span><br><span class="line">      const [content,user&#123;name&#125;] &#x3D; article.commnents[1]; &#x2F;&#x2F;这么写也可以，灵活运用</span><br></pre></td></tr></table></figure>

<h2 id="参数解构"><a href="#参数解构" class="headerlink" title="参数解构"></a>参数解构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;解构传入对象的参数</span><br><span class="line">function print(&#123; name, age, sex, address: &#123;</span><br><span class="line">    province,</span><br><span class="line">    city</span><br><span class="line">&#125; &#125;) &#123;</span><br><span class="line">    console.log(&#96;姓名：$&#123;name&#125;&#96;)</span><br><span class="line">    console.log(&#96;年龄：$&#123;age&#125;&#96;)</span><br><span class="line">    console.log(&#96;性别：$&#123;sex&#125;&#96;)</span><br><span class="line">    console.log(&#96;身份：$&#123;province&#125;&#96;)</span><br><span class="line">    console.log(&#96;城市：$&#123;city&#125;&#96;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const user &#x3D; &#123;</span><br><span class="line">    name: &quot;kevin&quot;,</span><br><span class="line">    age: 11,</span><br><span class="line">    sex: &quot;男&quot;,</span><br><span class="line">    address: &#123;</span><br><span class="line">        province: &quot;四川&quot;,</span><br><span class="line">        city: &quot;成都&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">print(user)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;给传入对象设置默认值</span><br><span class="line">&#x2F;&#x2F;设置默认的method和url属性</span><br><span class="line">&#x2F;&#x2F;如果什么都没传入，默认是空对象</span><br><span class="line">&#x2F;&#x2F;如果不写默认为空对象的话，会报错（不能解构出属性method...）</span><br><span class="line">function ajax(&#123;</span><br><span class="line">    method &#x3D; &quot;get&quot;,</span><br><span class="line">    url &#x3D; &quot;&#x2F;&quot;</span><br><span class="line">&#125; &#x3D; &#123;&#125;) &#123;</span><br><span class="line">    console.log(method, url)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ajax()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h1><h2 id="普通符号"><a href="#普通符号" class="headerlink" title="普通符号"></a>普通符号</h2><p>符号是 ES6 新增的一个数据类型，它通过使用函数 <code>Symbol(符号描述)</code> 来创建</p>
<p>符号设计的初衷，是为了给对象设置私有属性</p>
<p>私有属性：只能在对象内部使用，外面无法使用</p>
<h3 id="符号具有以下特点："><a href="#符号具有以下特点：" class="headerlink" title="符号具有以下特点："></a>符号具有以下特点：</h3><ul>
<li>没有字面量</li>
<li>使用 typeof 得到的类型是 symbol</li>
<li><strong>每次调用 Symbol 函数得到的符号永远不相等，无论符号名是否相同</strong></li>
<li>符号可以作为对象的属性名存在，这种属性称之为符号属性<ul>
<li>开发者可以通过精心的设计，让这些属性无法通过常规方式被外界访问，<strong>实现私有属性</strong></li>
<li><strong>符号属性是不能枚举的</strong>，因此在 for-in 循环中无法读取到符号属性，Object.keys 方法也无法读取到符号属性名</li>
<li>Object.getOwnPropertyNames 尽管可以得到所有无法枚举的属性，但是仍然无法读取到符号属性</li>
<li>ES6 新增 Object.getOwnPropertySymbols 方法，可以读取符号</li>
</ul>
</li>
<li><strong>符号无法被隐式转换</strong>，因此不能被用于数学运算、字符串拼接或其他隐式转换的场景，但<strong>符号可以显式的转换为字符串</strong>，通过 String 构造函数进行转换即可，console.log 之所以可以输出符号，是它在内部进行了显式转换</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 实现私有属性</span><br><span class="line">const hero &#x3D; (function () &#123;</span><br><span class="line">    const getRandom &#x3D; Symbol();</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">        attack: 30,</span><br><span class="line">        hp: 300,</span><br><span class="line">        defence: 10,</span><br><span class="line">        gongji() &#123; &#x2F;&#x2F;攻击</span><br><span class="line">            &#x2F;&#x2F;伤害：攻击力*随机数（0.8~1.1)</span><br><span class="line">            const dmg &#x3D; this.attack * this[getRandom](0.8, 1.1);</span><br><span class="line">            console.log(dmg);</span><br><span class="line">        &#125;,</span><br><span class="line">        [getRandom](min, max) &#123; &#x2F;&#x2F;根据最小值和最大值产生一个随机数</span><br><span class="line">            return Math.random() * (max - min) + min;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">console.log(hero);</span><br><span class="line">console.log(hero.getRandom);&#x2F;&#x2F;访问不到</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;访问符号属性</span><br><span class="line">const syb &#x3D; Symbol();</span><br><span class="line"></span><br><span class="line">const obj &#x3D; &#123;</span><br><span class="line">    [syb]: 1,</span><br><span class="line">    a: 2,</span><br><span class="line">    b: 3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (const prop in obj) &#123;</span><br><span class="line">    console.log(prop)</span><br><span class="line">&#125;</span><br><span class="line">console.log(Object.keys(obj)) &#x2F;&#x2F;得到对象的所有属性名，[&quot;a&quot;,&quot;b&quot;]</span><br><span class="line">console.log(Object.getOwnPropertyNames(obj)) &#x2F;&#x2F;能得到无法枚举的属性名，但是也无法读取符号[&quot;a&quot;,&quot;b&quot;]</span><br><span class="line">const sybs &#x3D; Object.getOwnPropertySymbols(obj);&#x2F;&#x2F;得到的是一个符号属性的数组</span><br><span class="line">console.log(sybs, sybs[0] &#x3D;&#x3D;&#x3D; syb)&#x2F;&#x2F; Symbol() true</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;使用符号属性</span><br><span class="line">const Hero &#x3D; (() &#x3D;&gt; &#123;</span><br><span class="line">    const getRandom &#x3D; Symbol();</span><br><span class="line"></span><br><span class="line">    return class &#123;</span><br><span class="line">        constructor(attack, hp, defence) &#123;</span><br><span class="line">            this.attack &#x3D; attack;</span><br><span class="line">            this.hp &#x3D; hp;</span><br><span class="line">            this.defence &#x3D; defence;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        gongji() &#123;</span><br><span class="line">            &#x2F;&#x2F;伤害：攻击力*随机数（0.8~1.1)</span><br><span class="line">            const dmg &#x3D; this.attack * this[getRandom](0.8, 1.1);</span><br><span class="line">            console.log(dmg);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        [getRandom](min, max) &#123; &#x2F;&#x2F;根据最小值和最大值产生一个随机数</span><br><span class="line">            return Math.random() * (max - min) + min;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">const h &#x3D; new Hero(3, 6, 3);</span><br><span class="line">const sybs &#x3D; Object.getOwnPropertySymbols(Hero.prototype);</span><br><span class="line">const prop &#x3D; sybs[0];</span><br><span class="line">console.log(h[prop](3, 5)) &#x2F;&#x2F; -&gt; getRandom(3,5)</span><br></pre></td></tr></table></figure>

<h2 id="共享符号"><a href="#共享符号" class="headerlink" title="共享符号"></a>共享符号</h2><p>根据某个符号名称（符号描述）能够得到同一个符号</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Symbol.for(&quot;符号名&#x2F;符号描述&quot;)  &#x2F;&#x2F;获取共享符号</span><br><span class="line"></span><br><span class="line">const syb1 &#x3D; Symbol.for(&quot;abc&quot;);</span><br><span class="line">const syb2 &#x3D; Symbol.for(&quot;abc&quot;);</span><br><span class="line">console.log(syb1 &#x3D;&#x3D;&#x3D; syb2)&#x2F;&#x2F;true</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;使用共享符号当作属性</span><br><span class="line">const obj &#x3D; &#123;</span><br><span class="line">    a: 1,</span><br><span class="line">    b: 2,</span><br><span class="line">    [Symbol.for(&quot;c&quot;)]: 3</span><br><span class="line">&#125;</span><br><span class="line">console.log(obj[Symbol.for(&quot;c&quot;)]);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="知名符号"><a href="#知名符号" class="headerlink" title="知名符号"></a>知名符号</h2><p>知名符号是一些具有特殊含义的共享符号，通过 Symbol 的静态属性得到</p>
<p>ES6 延续了 ES5 的思想：减少魔法，暴露内部实现！</p>
<p>因此，ES6 用知名符号暴露了某些场景的内部实现</p>
<ol>
<li>Symbol.hasInstance</li>
</ol>
<p>该符号用于定义构造函数的静态成员，它将影响 instanceof 的判定</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">obj instanceof A</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;等效于</span><br><span class="line"></span><br><span class="line">A[Symbol.hasInstance](obj) &#x2F;&#x2F; Function.prototype[Symbol.hasInstance]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;案例</span><br><span class="line">function A() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Object.defineProperty(A, Symbol.hasInstance, &#123; &#x2F;&#x2F;使用知名符号修改</span><br><span class="line">    value: function (obj) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">const obj &#x3D; new A();</span><br><span class="line"></span><br><span class="line">console.log(obj instanceof A); &#x2F;&#x2F;默认true , 修改后为false</span><br><span class="line">console.log(A[Symbol.hasInstance](obj)); &#x2F;&#x2F;默认true , 修改后为false</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>[扩展] Symbol.isConcatSpreadable -&gt; concat 是否拆分</li>
</ol>
<p>该知名符号会影响数组的 concat 方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">const arr &#x3D; [3];</span><br><span class="line">const arr2 &#x3D; [5, 6, 7, 8];</span><br><span class="line"></span><br><span class="line">arr2[Symbol.isConcatSpreadable] &#x3D; false;</span><br><span class="line"></span><br><span class="line">const result &#x3D; arr.concat(56, arr2)</span><br><span class="line"></span><br><span class="line">console.log(result)</span><br><span class="line">&#x2F;&#x2F;默认  [3, 56, 5, 6, 7, 8]</span><br><span class="line">&#x2F;&#x2F;修改为false后不拆分</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;对象也适用</span><br><span class="line">const arr &#x3D; [1];</span><br><span class="line">const obj &#x3D; &#123;</span><br><span class="line">    0: 3,</span><br><span class="line">    1: 4,</span><br><span class="line">    length: 2,</span><br><span class="line">    [Symbol.isConcatSpreadable]: true</span><br><span class="line"></span><br><span class="line">const result &#x3D; arr.concat(2, obj)</span><br><span class="line">console.log(result)</span><br><span class="line">&#x2F;&#x2F;默认应该为 [1,2,&#123;……&#125;]</span><br><span class="line">&#x2F;&#x2F;修改为true拆分后，为[1,2,3,4]</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>[扩展] Symbol.toPrimitive -&gt;影响类型转换结果</li>
</ol>
<p>该知名符号会影响类型转换的结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Temperature &#123;</span><br><span class="line">    constructor(degree) &#123;</span><br><span class="line">        this.degree &#x3D; degree;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [Symbol.toPrimitive](type) &#123;</span><br><span class="line">        if (type &#x3D;&#x3D;&#x3D; &quot;default&quot;) &#123; &#x2F;&#x2F;默认转换行为</span><br><span class="line">            return this.degree + &quot;摄氏度&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (type &#x3D;&#x3D;&#x3D; &quot;number&quot;) &#123;&#x2F;&#x2F;转换为数字</span><br><span class="line">            return this.degree;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (type &#x3D;&#x3D;&#x3D; &quot;string&quot;) &#123;&#x2F;&#x2F;转换成字符串</span><br><span class="line">            return this.degree + &quot;℃&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const t &#x3D; new Temperature(30);</span><br><span class="line">&#x2F;&#x2F;默认为[Object object]，默认转换过程，t.value -&gt; t.toString</span><br><span class="line">&#x2F;&#x2F;修改后为 30摄氏度！</span><br><span class="line">console.log(t + &quot;!&quot;);</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F;转换为数字，默认为NAN</span><br><span class="line"> &#x2F;&#x2F;修改后为 15</span><br><span class="line">console.log(t &#x2F; 2);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;转换为字符串，默认为[Object object]</span><br><span class="line">&#x2F;&#x2F;修改后为30℃</span><br><span class="line">console.log(String(t));</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>[扩展] Symbol.toStringTag</li>
</ol>
<p>该知名符号会影响 Object.prototype.toString 的返回值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line"></span><br><span class="line">    [Symbol.toStringTag] &#x3D; &quot;Person&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const p &#x3D; new Person();</span><br><span class="line"></span><br><span class="line">const arr &#x3D; [32424, 45654, 32]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;默认是[Object object],修改后为[Object Person]</span><br><span class="line">console.log(Object.prototype.toString.apply(p));</span><br><span class="line"></span><br><span class="line">console.log(Object.prototype.toString.apply(arr));</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>其他知名符号</li>
</ol>
<p>……</p>
<h1 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a>异步处理</h1><h2 id="事件循环-回顾"><a href="#事件循环-回顾" class="headerlink" title="事件循环[回顾]"></a>事件循环[回顾]</h2><h3 id="宿主环境"><a href="#宿主环境" class="headerlink" title="宿主环境"></a>宿主环境</h3><p><img src="http://47.97.6.61/%E6%9C%89%E9%81%93%E4%BA%91%E5%9B%BE%E7%89%87/%E5%AE%BF%E4%B8%BB%E7%8E%AF%E5%A2%83.png" alt="宿主环境"></p>
<ul>
<li>JS 运行的环境称之为宿主环境。</li>
</ul>
<h3 id="执行栈"><a href="#执行栈" class="headerlink" title="执行栈"></a>执行栈</h3><p><img src="http://47.97.6.61/%E6%9C%89%E9%81%93%E4%BA%91%E5%9B%BE%E7%89%87/%E6%89%A7%E8%A1%8C%E6%A0%88.png" alt="执行栈"></p>
<ul>
<li>执行栈：call stack，一个数据结构，用于存放各种函数的执行环境，每一个函数执行之前，它的相关信息会加入到执行栈。函数调用之前，创建执行环境，然后加入到执行栈；函数调用之后，销毁执行环境。</li>
<li>JS 引擎永远执行的是执行栈的最顶部。</li>
</ul>
<h3 id="异步函数"><a href="#异步函数" class="headerlink" title="异步函数"></a>异步函数</h3><p>异步函数：某些函数不会立即执行，需要等到某个时机到达后才会执行，这样的函数称之为异步函数。比如事件处理函数。异步函数的执行时机，会被宿主环境控制。</p>
<ul>
<li><strong>浏览器宿主环境中包含 5 个线程：</strong></li>
</ul>
<ol>
<li>JS 引擎：负责执行执行栈的最顶部代码</li>
<li>GUI 线程：负责渲染页面</li>
<li>事件监听线程：负责监听各种事件</li>
<li>计时线程：负责计时</li>
<li>网络线程：负责网络通信<br><img src="http://47.97.6.61/%E6%9C%89%E9%81%93%E4%BA%91%E5%9B%BE%E7%89%87/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF.png" alt="事件循环"></li>
</ol>
<p>当上面的线程发生了某些事请，如果该线程发现，这件事情有处理程序，它会将该处理程序加入一个叫做事件队列的内存。当 JS 引擎发现，执行栈中已经没有了任何内容后，会将事件队列中的第一个函数加入到执行栈中执行。</p>
<p><strong>JS 引擎对事件队列的取出执行方式，以及与宿主环境的配合，称之为事件循环。</strong></p>
<ul>
<li>解析上面这段话，<strong>以按钮点击事件为例</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;button id &#x3D; &#39;btn&#39;&gt;点击&lt;&#x2F;button&gt;</span><br><span class="line"></span><br><span class="line">document.getElementById(&#39;btn&#39;).onclick &#x3D; function A()&#123;</span><br><span class="line">    console.log(&#39;按钮被点击了&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>执行栈：建立全局上下文</li>
<li>执行栈：建立 getElementById 函数的上下文</li>
<li>执行栈：getElementById 函数运行，此上下文出栈</li>
<li>函数 A 放入事件监听线程里面</li>
<li>执行栈：js 继续执行，全局上下文出栈<ul>
<li>若执行栈为空，看事件队列里是否有任务，若有，将第一个任务放入执行栈执行</li>
</ul>
</li>
<li>点击按钮</li>
<li>事件监听线程将函数 A 放入事件队列</li>
<li>执行栈：将事件队列里的函数 A 放入执行栈</li>
<li>执行栈：执行函数 A，创建函数 A 的上下文</li>
<li>执行栈：创建 console.log 的上下文</li>
<li>执行栈：运行 console.log，此上下文出栈</li>
<li>执行栈：函数 A 上下文出栈</li>
</ol>
<ul>
<li><strong>以 setTimeout 事件为例解析</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setTimeout &#x3D; (function()&#123;</span><br><span class="line">    console.log(&#39;hello world&#39;)</span><br><span class="line">&#125;,1000)</span><br></pre></td></tr></table></figure>

<ol>
<li>执行栈：建立全局上下文</li>
<li>执行栈：建立 setTimeout 函数的上下文</li>
<li>把 setTimeout 函数放入计时线程</li>
<li>计时线程：1s 后将异步函数放入事件队列等待执行</li>
<li>执行栈：当执行栈内容清空后，在去看事件队列</li>
<li>执行栈：将事件队列里面的异步函数入栈执行</li>
<li>执行栈：执行完成后异步函数的上下文出栈</li>
</ol>
<h3 id="宏队列和微队列"><a href="#宏队列和微队列" class="headerlink" title="宏队列和微队列"></a>宏队列和微队列</h3><p>事件队列在不同的宿主环境中有所差异，大部分宿主环境会将事件队列进行细分。在浏览器中，事件队列分为两种：宏队列和微队列<br><img src="http://47.97.6.61/%E6%9C%89%E9%81%93%E4%BA%91%E5%9B%BE%E7%89%87/%E5%AE%8F%E9%98%9F%E5%88%97%EF%BC%8C%E5%BE%AE%E9%98%9F%E5%88%97.png" alt="宏队列，微队列"></p>
<ul>
<li>宏任务（队列）：macroTask，计时器结束的回调、事件回调、http 回调等等绝大部分异步函数进入宏队列。ps：之前学过的都是宏队列</li>
<li>微任务（队列）：MutationObserver，Promise 产生的回调进入微队列。ps：相当于 vip，优先查找</li>
<li><strong>==当执行栈清空时，JS 引擎首先会将微任务中的所有任务依次执行结束，如果没有微任务，则执行宏任务。务==</strong></li>
</ul>
<blockquote>
<p>MutationObserver 用于监听某个 DOM 对象的变化</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul id&#x3D;&quot;container&quot;&gt;&lt;&#x2F;ul&gt;</span><br><span class="line">&lt;button id&#x3D;&quot;btn&quot;&gt;点击&lt;&#x2F;button&gt;</span><br><span class="line"></span><br><span class="line">let count &#x3D; 1;</span><br><span class="line">const ul &#x3D; document.getElementById(&quot;container&quot;);</span><br><span class="line">document.getElementById(&quot;btn&quot;).onclick &#x3D; function A() &#123;</span><br><span class="line">    setTimeout(function C() &#123;</span><br><span class="line">        console.log(&quot;添加了一个li&quot;)</span><br><span class="line">    &#125;, 0);</span><br><span class="line">    var li &#x3D; document.createElement(&quot;li&quot;)</span><br><span class="line">    li.innerText &#x3D; count++;</span><br><span class="line">    ul.appendChild(li);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;监听ul</span><br><span class="line">const observer &#x3D; new MutationObserver(function B() &#123;</span><br><span class="line">    &#x2F;&#x2F;当监听的dom元素发生变化时运行的回调函数</span><br><span class="line">    console.log(&quot;ul元素发生了变化&quot;)</span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F;监听ul</span><br><span class="line">observer.observe(ul, &#123;</span><br><span class="line">    attributes: true, &#x2F;&#x2F;监听属性的变化</span><br><span class="line">    childList: true, &#x2F;&#x2F;监听子元素的变化</span><br><span class="line">    subtree: true &#x2F;&#x2F;监听子树的变化</span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F;取消监听</span><br><span class="line">observer.disconnect();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;点击按钮时先执行console.log(&quot;ul元素发生了变化&quot;)</span><br><span class="line">&#x2F;&#x2F;在执行console.log(&quot;添加了一个li&quot;)</span><br></pre></td></tr></table></figure>

<ul>
<li>解析：</li>
</ul>
<ol>
<li>浏览器线程中已有函数 A(点击事件)和函数 B(监听事件)</li>
<li>点击按钮，函数 A 执行，放入宏队列</li>
<li>执行栈将宏队列的函数 A 入栈执行</li>
<li>将函数 C(setTimeout)放入计时线程，0 秒后放入宏队列</li>
<li>li 添加到 ul 触发函数 B，函数 B 放入微队列</li>
<li>函数 A 出栈</li>
<li>执行微队列中的函数 B 并出栈</li>
<li>执行宏队列中的函数 C 并出栈</li>
</ol>
<h2 id="事件和回调函数的缺陷"><a href="#事件和回调函数的缺陷" class="headerlink" title="事件和回调函数的缺陷"></a>事件和回调函数的缺陷</h2><p>我们习惯于使用传统的回调或事件处理来解决异步问题</p>
<p>本质上，事件和回调并没有本质的区别，只是把函数放置的位置不同而已。</p>
<p>存在的问题：</p>
<ol>
<li>回调地狱：某个异步操作需要等待之前的异步操作完成，无论用回调还是事件，都会陷入不断的嵌套</li>
<li>异步之间的联系：某个异步操作要等待多个异步操作的结果，对这种联系的处理，会让代码的复杂度剧增</li>
</ol>
<h2 id="异步处理的通用模型"><a href="#异步处理的通用模型" class="headerlink" title="异步处理的通用模型"></a>异步处理的通用模型</h2><p>ES 官方参考了大量的异步场景，总结出了一套异步的通用模型，该模型可以覆盖几乎所有的异步场景，甚至是同步场景。</p>
<p>值得注意的是，为了兼容旧系统，ES6 并不打算抛弃掉过去的做法，只是基于该模型推出一个全新的 API，使用该 API，会让异步处理更加的简洁优雅。</p>
<p>理解该 API，最重要的，是理解它的异步模型</p>
<h3 id="1-ES6-将某一件可能发生异步操作的事情，分为两个阶段：unsettled-和-settled"><a href="#1-ES6-将某一件可能发生异步操作的事情，分为两个阶段：unsettled-和-settled" class="headerlink" title="1. ES6 将某一件可能发生异步操作的事情，分为两个阶段：unsettled 和 settled"></a>1. ES6 将某一件可能发生异步操作的事情，分为两个阶段：unsettled 和 settled</h3><ul>
<li>unsettled： 未决阶段，表示事情还在进行前期的处理，并没有发生通向结果的那件事</li>
<li>settled：已决阶段，事情已经有了一个结果，不管这个结果是好是坏，整件事情无法逆转</li>
</ul>
<p>事情总是从<strong>未决阶段</strong>逐步发展到<strong>已决阶段</strong>的。并且，未决阶段拥有<strong>控制</strong>何时通向已决阶段的能力。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">未决：监听窗口中的某个元素是否被点击</span><br><span class="line">已决：按钮已经被点击了</span><br></pre></td></tr></table></figure>

<p><img src="http://47.97.6.61/%E6%9C%89%E9%81%93%E4%BA%91%E5%9B%BE%E7%89%87/unsettled%20%E5%92%8C%20settled.png" alt="unsettled 和 settled"></p>
<h3 id="2-ES6-将事情划分为三种状态：-pending、resolved、rejected"><a href="#2-ES6-将事情划分为三种状态：-pending、resolved、rejected" class="headerlink" title="2. ES6 将事情划分为三种状态： pending、resolved、rejected"></a>2. ES6 将事情划分为三种状态： pending、resolved、rejected</h3><ul>
<li><strong>pending</strong>： ==挂起，处于未决阶段==，则表示这件事情还在挂起（最终的结果还没出来）</li>
<li><strong>resolved</strong>：==已处理，已决阶段的一种状态==，表示整件事情<strong>已经出现结果</strong>，并是一个可以按照正常逻辑进行下去的结果</li>
<li><strong>rejected</strong>：==已拒绝，已决阶段的一种状态==，表示整件事情已经出现结果，并是一个无法按照正常逻辑进行下去的结果，通常用于表示有一个错误</li>
</ul>
<p>既然未决阶段有权力决定事情的走向，因此，<strong>未决阶段可以决定事情最终的状态！</strong></p>
<p>我们将 把事情变为 resolved 状态的过程叫做：<strong>resolve</strong>，推向该状态时，可能会传递一些数据</p>
<p>我们将 把事情变为 rejected 状态的过程叫做：<strong>reject</strong>，推向该状态时，同样可能会传递一些数据，通常为错误信息</p>
<p><strong>==始终记住，无论是阶段，还是状态，是不可逆的！==</strong></p>
<p><img src="http://47.97.6.61/%E6%9C%89%E9%81%93%E4%BA%91%E5%9B%BE%E7%89%87/%E6%9C%AA%E5%86%B3%E6%8E%A8%E5%90%91%E5%B7%B2%E5%86%B3.png" alt="未决推向已决"></p>
<h3 id="3-当事情达到已决阶段后，通常需要进行后续处理，不同的已决状态，决定了不同的后续处理。"><a href="#3-当事情达到已决阶段后，通常需要进行后续处理，不同的已决状态，决定了不同的后续处理。" class="headerlink" title="3. 当事情达到已决阶段后，通常需要进行后续处理，不同的已决状态，决定了不同的后续处理。"></a>3. 当事情达到已决阶段后，通常需要进行后续处理，不同的已决状态，决定了不同的后续处理。</h3><ul>
<li>resolved 状态：这是一个正常的已决状态，后续处理表示为 thenable</li>
<li>rejected 状态：这是一个非正常的已决状态，后续处理表示为 catchable</li>
</ul>
<p>后续处理可能有多个，因此会形成作业队列，这些后续处理会按照顺序，当状态到达后依次执行</p>
<p><img src="http://47.97.6.61/%E6%9C%89%E9%81%93%E4%BA%91%E5%9B%BE%E7%89%87/%E5%B7%B2%E5%86%B3%E9%98%B6%E6%AE%B5%E5%90%8E%E7%BB%AD%E5%A4%84%E7%90%86.png" alt="已决阶段后续处理"></p>
<h3 id="整件事称之为-Promise"><a href="#整件事称之为-Promise" class="headerlink" title="整件事称之为 Promise"></a>整件事称之为 Promise</h3><p><img src="http://47.97.6.61/%E6%9C%89%E9%81%93%E4%BA%91%E5%9B%BE%E7%89%87/Promise.png" alt="Promise"></p>
<p><strong>理解上面的概念，对学习 Promise 至关重要！</strong></p>
<h2 id="Promise-的基本使用"><a href="#Promise-的基本使用" class="headerlink" title="Promise 的基本使用"></a>Promise 的基本使用</h2><p><img src="http://47.97.6.61/%E6%9C%89%E9%81%93%E4%BA%91%E5%9B%BE%E7%89%87/Promise.png" alt="Promise"></p>
<ul>
<li>格式及解析：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pro = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 未决阶段的处理</span></span><br><span class="line">  <span class="comment">// 通过调用resolve函数将Promise推向已决阶段的resolved状态</span></span><br><span class="line">  <span class="comment">// 通过调用reject函数将Promise推向已决阶段的rejected状态</span></span><br><span class="line">  <span class="comment">// resolve和reject均可以传递最多一个参数，表示推向状态的数据</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">pro.then(</span><br><span class="line">  (data) =&gt; &#123;</span><br><span class="line">    <span class="comment">//这是thenable函数，如果当前的Promise已经是resolved状态，该函数会立即执行</span></span><br><span class="line">    <span class="comment">//如果当前是未决阶段，则会加入到作业队列，等待到达resolved状态后执行</span></span><br><span class="line">    <span class="comment">//data为状态数据</span></span><br><span class="line">  &#125;,</span><br><span class="line">  (err) =&gt; &#123;</span><br><span class="line">    <span class="comment">//这是catchable函数，如果当前的Promise已经是rejected状态，该函数会立即执行</span></span><br><span class="line">    <span class="comment">//如果当前是未决阶段，则会加入到作业队列，等待到达rejected状态后执行</span></span><br><span class="line">    <span class="comment">//err为状态数据</span></span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<ul>
<li>各种用法：</li>
</ul>
<p>基本使用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pro = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;未决阶段&quot;</span>);</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&quot;推入resolved&quot;</span>);</span><br><span class="line">  &#125;, <span class="number">3000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">pro.then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data); <span class="comment">//3s后打印&quot;推入resolved&quot;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>配合函数来实现回调：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">biaodai</span>(<span class="params">god</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;这里是立即执行的&quot;</span>);</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">Math</span>.random() &lt; <span class="number">0.5</span>) &#123;</span><br><span class="line">        resolve(<span class="string">&quot;表白成功了&quot;</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resolve(<span class="string">&quot;表白失败了&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">3000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">biaodai(<span class="string">&quot;女孩&quot;</span>).then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//当前pro的状态是pending，不执行，等状态变为resolve时执行</span></span><br><span class="line">  <span class="built_in">console</span>.log(data); <span class="comment">// 3s后打印返回结果</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>可以注册多个 thenable：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pro = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">&quot;就算立即执行也是异步执行，加入微队列&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;这里是先打印的&quot;</span>);</span><br><span class="line">pro.then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br><span class="line">pro.then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>获取两种状态（resolved 和 rejectd）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pro = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;未决阶段&quot;</span>);</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Math</span>.random &lt; <span class="number">0.5</span>) &#123;</span><br><span class="line">      resolve(<span class="number">123</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;这是一个错误信息……&quot;</span>)); <span class="comment">//通常错误状态会返回一个错误信息</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="number">3000</span>);</span><br><span class="line">&#125;);</span><br><span class="line">pro.then(</span><br><span class="line">  (data) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data); <span class="comment">// resolved状态执行</span></span><br><span class="line">  &#125;,</span><br><span class="line">  (err) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err); <span class="comment">// rejected状态执行</span></span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>实现 ajax 的回调：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 辅助函数,把传进来的对象拼接成url的字符串</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toData</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (obj === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> arr = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">let</span> str = i + <span class="string">&quot;=&quot;</span> + obj[i];</span><br><span class="line">    arr.push(str);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr.join(<span class="string">&quot;&amp;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 封装Ajax</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//指定提交方式的默认值</span></span><br><span class="line">    obj.type = obj.type || <span class="string">&quot;get&quot;</span>;</span><br><span class="line">    <span class="comment">//设置是否异步，默认为true(异步)</span></span><br><span class="line">    obj.async = obj.async || <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//设置数据的默认值</span></span><br><span class="line">    obj.data = obj.data || <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 根据不同的浏览器创建XHR对象</span></span><br><span class="line">    <span class="keyword">let</span> xhr = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.XMLHttpRequest) &#123;</span><br><span class="line">      <span class="comment">// 非IE浏览器</span></span><br><span class="line">      xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// IE浏览器</span></span><br><span class="line">      xhr = <span class="keyword">new</span> ActiveXObject(<span class="string">&quot;Microsoft.XMLHTTP&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 区分get和post,发送HTTP请求</span></span><br><span class="line">    <span class="keyword">if</span> (obj.type === <span class="string">&quot;post&quot;</span>) &#123;</span><br><span class="line">      xhr.open(obj.type, obj.url, obj.async);</span><br><span class="line">      xhr.setRequestHeader(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>);</span><br><span class="line">      <span class="keyword">let</span> data = toData(obj.data);</span><br><span class="line">      xhr.send(data);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> url = obj.url + <span class="string">&quot;?&quot;</span> + toData(obj.data);</span><br><span class="line">      xhr.open(obj.type, url, obj.async);</span><br><span class="line">      xhr.send();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 接收返回过来的数据</span></span><br><span class="line">    xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>) || xhr.status == <span class="number">304</span>) &#123;</span><br><span class="line">          resolve(<span class="built_in">JSON</span>.parse(xhr.responseText));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          reject(xhr.status);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ajax(&#123;</span><br><span class="line">  url: <span class="string">&quot;./data/students.json?name=李华&quot;</span>,</span><br><span class="line">&#125;).then(</span><br><span class="line">  (resp) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(resp);</span><br><span class="line">  &#125;,</span><br><span class="line">  (err) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><strong>细节</strong></p>
<ol>
<li>未决阶段的处理函数本身是同步的，会立即执行</li>
<li>thenable 和 catchable 函数是异步的，就算是立即执行，也会加入到事件队列中等待执行，并且，加入的队列是微队列<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const pro &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&quot;此处第一个打印&quot;);</span><br><span class="line">    resolve(&#39;此处第三个打印&#39;);</span><br><span class="line">&#125;)</span><br><span class="line">console.log(&quot;此处第二个打印&quot;);</span><br><span class="line">pro.then(data &#x3D;&gt; &#123;</span><br><span class="line">    console.log(data);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li>pro.then 可以只添加 thenable 函数，pro.catch 可以单独添加 catchable 函数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const pro &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    resolve(&quot;这里只展示效果&quot;);</span><br><span class="line">&#125;)</span><br><span class="line">pro.then(data &#x3D;&gt; &#123;</span><br><span class="line">    console.log(data)</span><br><span class="line">&#125;)</span><br><span class="line">pro.catch(err &#x3D;&gt; &#123;</span><br><span class="line">    console.log(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li>在未决阶段的处理函数中，如果发生未捕获的错误，会将状态推向 rejected，并会被 catchable 捕获<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const pro &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    throw new Error(&quot;123&quot;); &#x2F;&#x2F; pro 状态推向 rejected</span><br><span class="line">&#125;)</span><br><span class="line">pro.then(data &#x3D;&gt; &#123;</span><br><span class="line">    console.log(data)</span><br><span class="line">&#125;)</span><br><span class="line">pro.catch(err &#x3D;&gt; &#123;</span><br><span class="line">    console.log(err) &#x2F;&#x2F;     先打印错误，然后报错（因为thenable和catchable函数在微队    列中）</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li>一旦状态推向了已决阶段，无法再对状态做任何更改<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const pro &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    throw new Error(&quot;abc&quot;); &#x2F;&#x2F; pro推向已决阶段rejectd状态</span><br><span class="line">    resolve(1); &#x2F;&#x2F;无效</span><br><span class="line">    reject(2); &#x2F;&#x2F;无效</span><br><span class="line">    resolve(3); &#x2F;&#x2F;无效</span><br><span class="line">    reject(4); &#x2F;&#x2F;无效</span><br><span class="line">&#125;)</span><br><span class="line">pro.then(data &#x3D;&gt; &#123;</span><br><span class="line">    console.log(data)</span><br><span class="line">&#125;)</span><br><span class="line">pro.catch(err &#x3D;&gt; &#123;</span><br><span class="line">    console.log(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><strong>Promise 并没有消除回调，只是让回调变得可控</strong></li>
</ol>
<h2 id="Promise-的串联"><a href="#Promise-的串联" class="headerlink" title="Promise 的串联"></a>Promise 的串联</h2><p>当后续的 Promise 需要用到之前的 Promise 的处理结果时，需要 Promise 的串联</p>
<p>==Promise 对象中，无论是 then 方法还是 catch 方法，它们都具有返回值，返回的是一个全新的 Promise 对象==</p>
<p>它的状态满足下面的规则：</p>
<ol>
<li>==如果当前的 Promise 是未决的，<strong>得到的新的 Promise 是挂起状态</strong>==</li>
<li>==如果当前的 Promise 是已决的，会运行响应的后续处理函数，并将后续处理函数的结果（返回值）作为 resolved 状态数据，应用到新的 Promise 中；如果后续处理函数发生错误，则把返回值作为 rejected 状态数据，应用到新的 Promise 中。==</li>
</ol>
<p>==<strong>后续的 Promise 一定会等到前面的 Promise 有了后续处理结果后，才会变成已决状态</strong>==</p>
<p>如果前面的 Promise 的后续处理，返回的是一个 Promise，则返 回的==新的 Promise 状态和后续处理返回的 Promise 状态保持一致。==</p>
<p>基本使用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1.pro.then(……) 返回一个新的Promise</span></span><br><span class="line"><span class="comment"> * 2.如果函数体内没有错误，新Promise由pending(挂起)状态推向resolve(已处理)状态</span></span><br><span class="line"><span class="comment"> * 3.如果函数体内出现错误，新Promise由pending(挂起)状态推向reject(已拒绝)状态</span></span><br><span class="line"><span class="comment"> * 4.return data; 为传入的参数</span></span><br><span class="line"><span class="comment"> * 5.当pro处于未决状态时，pro2也保持未决状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> pro = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">&quot;成功了&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> pro2 = pro.then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">  <span class="keyword">return</span> data;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(pro2); <span class="comment">//此处打印pending</span></span><br><span class="line">pro2.then(</span><br><span class="line">  (data) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data, <span class="number">2</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  (err) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>加深理解：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pro1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="number">1</span>; <span class="comment">//这里报错，推向rejected状态</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此处运行：return 3，推向resolved状态，当pro1.then里面的代码出错时才会推向rejected状态</span></span><br><span class="line"><span class="keyword">const</span> pro2 = pro1.then(</span><br><span class="line">  (result) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> result * <span class="number">2</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  (err) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> err * <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">//此处和上面err一起运行，但是这个并没有返回给pro2，所以不影响下面输出</span></span><br><span class="line">pro1.catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> err * <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//pro2的状态：</span></span><br><span class="line">pro2.then(</span><br><span class="line">  (result) =&gt; <span class="built_in">console</span>.log(result * <span class="number">2</span>),</span><br><span class="line">  (err) =&gt; <span class="built_in">console</span>.log(err * <span class="number">3</span>)</span><br><span class="line">);</span><br><span class="line"><span class="comment">//输出：6</span></span><br></pre></td></tr></table></figure>

<p>返回 Promise</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pro1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pro2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">2</span>);</span><br><span class="line">  &#125;, <span class="number">3000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">pro1</span><br><span class="line">  .then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;结果出来了，得到的是一个Promise&quot;</span>); <span class="comment">//运行后会立刻打印</span></span><br><span class="line">    <span class="keyword">return</span> pro2;</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result); <span class="comment">//等待pro2执行完，3s后打印 2</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result); <span class="comment">//上一个没有传入数据，打印undefined</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>解决回调地狱</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ajax函数在上面</span></span><br><span class="line"><span class="comment">//获取李华所在班级的老师的信息</span></span><br><span class="line"><span class="comment">//1. 获取李华的班级id   Promise</span></span><br><span class="line"><span class="comment">//2. 根据班级id获取李华所在班级的老师id   Promise</span></span><br><span class="line"><span class="comment">//3. 根据老师的id查询老师信息   Promise</span></span><br><span class="line"><span class="keyword">const</span> pro = ajax(&#123;</span><br><span class="line">  url: <span class="string">&quot;./data/students.json&quot;</span>,</span><br><span class="line">&#125;);</span><br><span class="line">pro</span><br><span class="line">  .then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (data[i].name === <span class="string">&quot;李华&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> data[i].classId;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">cid</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ajax(&#123;</span><br><span class="line">      url: <span class="string">&quot;./data/classes.json?id=&quot;</span> + cid,</span><br><span class="line">    &#125;).then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (data[i].id == cid) &#123;</span><br><span class="line">          <span class="keyword">return</span> data[i].teacherId;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">tid</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ajax(&#123;</span><br><span class="line">      url: <span class="string">&quot;./data/teachers.json?id=&quot;</span> + tid,</span><br><span class="line">    &#125;).then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(data);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (data[i].id === tid) &#123;</span><br><span class="line">          <span class="keyword">return</span> data[i];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">teacher</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(teacher);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>邓哥女神表白</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    邓哥心中有三个女神</span></span><br><span class="line"><span class="comment">    有一天，邓哥决定向第一个女神表白，如果女神拒绝，则向第二个女神表白，直到所有的女神都拒绝，或有一个女神同意为止</span></span><br><span class="line"><span class="comment">    用代码模拟上面的场景</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">biaobai</span>(<span class="params">god</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;邓哥向&quot;</span> + god + <span class="string">&quot;发出了表白&quot;</span>);</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">Math</span>.random() &lt; <span class="number">0.3</span>) &#123;</span><br><span class="line">        resolve(<span class="literal">true</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resolve(<span class="literal">false</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> gods = [<span class="string">&quot;女神1&quot;</span>, <span class="string">&quot;女神2&quot;</span>, <span class="string">&quot;女神3&quot;</span>, <span class="string">&quot;女神4&quot;</span>, <span class="string">&quot;女神5&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> pro;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; gods.length; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">    pro = biaobai(gods[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  pro = pro.then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (result === <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (result) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;result&#125;</span>同意了`</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;result&#125;</span>拒绝了`</span>);</span><br><span class="line">      <span class="keyword">if</span> (i &lt; gods.length - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> biaobai(gods[i + <span class="number">1</span>]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Promise-的其他-API"><a href="#Promise-的其他-API" class="headerlink" title="Promise 的其他 API"></a>Promise 的其他 API</h2><h3 id="原型成员-实例成员"><a href="#原型成员-实例成员" class="headerlink" title="原型成员 (实例成员)"></a>原型成员 (实例成员)</h3><ul>
<li>then：注册一个后续处理函数，当 Promise 为 resolved 状态时运行该函数</li>
<li>catch：注册一个后续处理函数，当 Promise 为 rejected 状态时运行该函数</li>
<li>finally：[ES2018]注册一个后续处理函数（无参），当 Promise 为已决时运行该函数</li>
</ul>
<h3 id="构造函数成员-（静态成员）"><a href="#构造函数成员-（静态成员）" class="headerlink" title="构造函数成员 （静态成员）"></a>构造函数成员 （静态成员）</h3><ul>
<li>resolve(数据)：该方法返回一个 resolved 状态的 Promise，传递的数据作为状态数据<ul>
<li>特殊情况：如果传递的数据是 Promise，则直接返回传递的 Promise 对象</li>
</ul>
</li>
<li>reject(数据)：该方法返回一个 rejected 状态的 Promise，传递的数据作为状态数据</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pro = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//等效于：</span></span><br><span class="line"><span class="keyword">const</span> pro = <span class="built_in">Promise</span>.resolve(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="number">3</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// const pro = Promise.resolve(p);</span></span><br><span class="line"><span class="comment">//等效于</span></span><br><span class="line"><span class="keyword">const</span> pro = p;</span><br><span class="line"><span class="built_in">console</span>.log(pro === p);</span><br></pre></td></tr></table></figure>

<ul>
<li>all(iterable)：这个方法返回一个新的 promise 对象，该 promise 对象在 iterable 参数对象里所有的 promise 对象都成功的时候才会触发成功，一旦有任何一个 iterable 里面的 promise 对象失败则立即触发该 promise 对象的失败。<ul>
<li>这个新的 promise 对象在触发成功状态以后，会把一个包含 iterable 里所有 promise 返回值的数组作为成功回调的返回值，顺序跟 iterable 的顺序保持一致；如果这个新的 promise 对象触发了失败状态，它会把 iterable 里第一个触发失败的 promise 对象的错误信息作为它的失败错误信息。</li>
<li><strong>Promise.all 方法常被用于处理多个 promise 对象的状态集合。</strong></li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRandom</span>(<span class="params">min, max</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (max - min)) + min;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> proms = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  proms.push(</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Math</span>.random() &lt; <span class="number">0.5</span>) &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(i, <span class="string">&quot;完成&quot;</span>);</span><br><span class="line">          resolve(i);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(i, <span class="string">&quot;失败&quot;</span>);</span><br><span class="line">          reject(i);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, getRandom(<span class="number">1000</span>, <span class="number">5000</span>));</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//等到所有的promise变成resolved状态后输出: 全部完成</span></span><br><span class="line"><span class="keyword">const</span> pro = <span class="built_in">Promise</span>.all(proms);</span><br><span class="line">pro.then(<span class="function">(<span class="params">datas</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;全部完成&quot;</span>, datas);</span><br><span class="line">&#125;);</span><br><span class="line">pro.catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;有失败的&quot;</span>, err);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(proms);</span><br></pre></td></tr></table></figure>

<ul>
<li>race(iterable)：当 iterable 参数里的任意一个子 promise 被成功或失败后，父 promise 马上也会用子 promise 的成功返回值或失败详情作为参数调用父 promise 绑定的相应句柄，并返回该 promise 对象</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">function getRandom(min, max) &#123;</span><br><span class="line">    return Math.floor(Math.random() * (max - min)) + min;</span><br><span class="line">&#125;</span><br><span class="line">const proms &#x3D; [];</span><br><span class="line">for (let i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">    proms.push(new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">        setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">            if (Math.random() &lt; 0.5) &#123;</span><br><span class="line">                console.log(i, &quot;完成&quot;);</span><br><span class="line">                resolve(i);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                console.log(i, &quot;失败&quot;)</span><br><span class="line">                reject(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, getRandom(1000, 5000));</span><br><span class="line">    &#125;))</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;等到所有的promise变成resolved状态后输出: 全部完成</span><br><span class="line">const pro &#x3D; Promise.race(proms)</span><br><span class="line">pro.then(data &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&quot;有人完成了&quot;, data);</span><br><span class="line">&#125;)</span><br><span class="line">pro.catch(err &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&quot;有人失败了&quot;, err);</span><br><span class="line">&#125;)</span><br><span class="line">console.log(proms);</span><br></pre></td></tr></table></figure>

<h2 id="手写-Promise-扩展"><a href="#手写-Promise-扩展" class="headerlink" title="手写 Promise[扩展]"></a>手写 Promise[扩展]</h2><p>有时间去看视频</p>
<h2 id="async-和-await"><a href="#async-和-await" class="headerlink" title="async 和 await"></a>async 和 await</h2><p>async 和 await 是 ES2016 新增两个关键字，它们借鉴了 ES2015 中生成器在实际开发中的应用，目的是简化 Promise api 的使用，并非是替代 Promise。</p>
<h3 id="async-关键字"><a href="#async-关键字" class="headerlink" title="async 关键字"></a>async 关键字</h3><p>==目的是简化在函数的返回值中对 Promise 的创建==</p>
<p>async 用于修饰函数（无论是函数字面量还是函数表达式），放置在函数最开始的位置，被修饰函数的返回结果一定是 Promise 对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">throw</span> <span class="number">3</span>; <span class="comment">//推向reject(3);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//等效于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    resolve(<span class="number">2</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="await-关键字"><a href="#await-关键字" class="headerlink" title="await 关键字"></a>await 关键字</h3><ul>
<li><p>==await 关键字必须出现在 async 函数中==</p>
</li>
<li><p>await 用在某个表达式之前，如果表达式是一个 Promise，则==得到的是 thenable 中的状态数据。==</p>
</li>
<li><p>如果 await 的表达式不是 Promise，则会将其使用 Promise.resolve 包装后按照规则运行</p>
</li>
</ul>
<p>基本使用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//这里就相当于把return回来的数据直接赋值给result</span></span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">await</span> test1();</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test2();</span><br><span class="line"><span class="comment">//等效于:</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    resolve(<span class="number">2</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    test1().then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> result = data;</span><br><span class="line">      <span class="built_in">console</span>.log(result);</span><br><span class="line">      resolve();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test2();</span><br></pre></td></tr></table></figure>

<p>await 的表达式不是 Promise：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//await不返回Promise</span></span><br><span class="line"><span class="comment">//如果await的表达式不是Promise，则会将其使用Promise.resolve包装后按照规则运行</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">await</span> <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//等效于：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">Promise</span>.resolve(<span class="number">1</span>).then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> result = data;</span><br><span class="line">      <span class="built_in">console</span>.log(result);</span><br><span class="line">      resolve();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">test();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">123</span>);</span><br></pre></td></tr></table></figure>

<p>捕获 catchable 状态数据：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getPromise</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Math</span>.random() &lt; <span class="number">0.5</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> getPromise();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;正常状态&quot;</span>, result);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;错误状态&quot;</span>, err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test();</span><br></pre></td></tr></table></figure>

<h3 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h3><p>ajax 请求</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取李华所在班级的老师的信息</span></span><br><span class="line"><span class="comment">//1. 获取李华的班级id   Promise</span></span><br><span class="line"><span class="comment">//2. 根据班级id获取李华所在班级的老师id   Promise</span></span><br><span class="line"><span class="comment">//3. 根据老师的id查询老师信息   Promise</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getTeacher</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> stus = <span class="keyword">await</span> ajax(&#123;</span><br><span class="line">    url: <span class="string">&quot;./data/students.json&quot;</span>,</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">let</span> cid;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; stus.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (stus[i].name === <span class="string">&quot;李华&quot;</span>) &#123;</span><br><span class="line">      cid = stus[i].classId;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> cls = <span class="keyword">await</span> ajax(&#123;</span><br><span class="line">    url: <span class="string">&quot;./data/classes.json&quot;</span>,</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">let</span> tid;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; cls.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (cls[i].id === cid) &#123;</span><br><span class="line">      tid = cls[i].teacherId;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> ts = <span class="keyword">await</span> ajax(&#123;</span><br><span class="line">    url: <span class="string">&quot;./data/teachers.json&quot;</span>,</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; ts.length; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> element = ts[i];</span><br><span class="line">    <span class="keyword">if</span> (element.id === tid) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(element);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">getTeacher();</span><br></pre></td></tr></table></figure>

<p>邓哥表白女神</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    邓哥心中有三个女神</span></span><br><span class="line"><span class="comment">    有一天，邓哥决定向第一个女神表白，如果女神拒绝，则向第二个女神表白，直到所有的女神都拒绝，或有一个女神同意为止</span></span><br><span class="line"><span class="comment">    用代码模拟上面的场景</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> gods = [<span class="string">&quot;女神1&quot;</span>, <span class="string">&quot;女神2&quot;</span>, <span class="string">&quot;女神3&quot;</span>, <span class="string">&quot;女神4&quot;</span>, <span class="string">&quot;女神5&quot;</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; gods.length; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> g = gods[i];</span><br><span class="line">    <span class="comment">// 当前循环等待的Promise没有resolve，下一次循环不运行</span></span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> biaobai(g);</span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;g&#125;</span>同意了，不用再表白了！！！`</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;g&#125;</span>没有同意`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>如果 async 里面有定时器，会出现 this 指向的问题，可以通过改造计时器的方式实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delay</span>(<span class="params">duration</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      resolve();</span><br><span class="line">    &#125;, duration);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">biaobai</span>(<span class="params">god</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`邓哥向<span class="subst">$&#123;god&#125;</span>发出了表白短信`</span>);</span><br><span class="line">  <span class="keyword">await</span> delay(<span class="number">500</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.random() &lt; <span class="number">0.3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Fetch-Api"><a href="#Fetch-Api" class="headerlink" title="Fetch Api"></a>Fetch Api</h1><h2 id="Fetch-Api-概述"><a href="#Fetch-Api-概述" class="headerlink" title="Fetch Api 概述"></a>Fetch Api 概述</h2><p><strong>XMLHttpRequest 的问题</strong></p>
<ol>
<li>所有的功能全部集中在同一个对象上，容易书写出混乱不易维护的代码</li>
<li>若采用传统的事件驱动模式，无法适配新的 Promise Api</li>
</ol>
<p><strong>Fetch Api 的特点</strong></p>
<ol>
<li>并非取代 AJAX，而是对 AJAX 传统 API 的改进</li>
<li>精细的功能分割：头部信息、请求信息、响应信息等均分布到不同的对象，更利于处理各种复杂的 AJAX 场景</li>
<li>使用 Promise Api，更利于异步代码的书写</li>
<li>Fetch Api 并非 ES6 的内容，属于 HTML5 新增的 Web Api</li>
<li>需要掌握网络通信的知识</li>
</ol>
<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><blockquote>
<p>请求测试地址：<a target="_blank" rel="noopener" href="http://101.132.72.36:5100/api/local">http://101.132.72.36:5100/api/local</a></p>
</blockquote>
<p>使用 <code>fetch</code> 函数即可立即向服务器发送网络请求</p>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>该函数有两个参数：</p>
<ol>
<li>必填，字符串，请求地址</li>
<li>选填，对象，请求配置(下面为可配置参数)</li>
</ol>
<p><strong>请求配置对象</strong></p>
<ul>
<li><strong>method</strong>：字符串，请求方法，默认值 GET</li>
<li><strong>headers</strong>：对象，请求头信息。常见<code>&quot;Content-Type:&quot;application/json&quot;</code>,也可以配置自定义的内容</li>
<li><strong>body</strong>: 请求体的内容，必须匹配请求头中的 Content-Type。==（注：只有 post 请求才会有请求体，get 的请求内容都在 url 中）==</li>
<li>mode：字符串，请求模式<ul>
<li>cors：默认值，配置为该值，会在请求头中加入 origin 和 referer</li>
<li>no-cors：配置为该值，不会在请求头中加入 origin 和 referer，跨域的时候可能会出现问题</li>
<li>same-origin：指示请求必须在同一个域中发生，如果请求其他域，则会报错</li>
</ul>
</li>
<li>credentials: 如何携带凭据（cookie）<ul>
<li>omit：默认值，不携带 cookie</li>
<li>same-origin：请求同源地址时携带 cookie</li>
<li>include：请求任何地址都携带 cookie</li>
</ul>
</li>
<li>cache：配置缓存模式<ul>
<li>default: 表示 fetch 请求之前将检查下 http 的缓存.</li>
<li>no-store: 表示 fetch 请求将完全忽略 http 缓存的存在. 这意味着请求之前将不再检查下 http 的缓存, 拿到响应后, 它也不会更新 http 缓存.</li>
<li>no-cache: 如果存在缓存, 那么 fetch 将发送一个条件查询 request 和一个正常的 request, 拿到响应后, 它会更新 http 缓存.</li>
<li>reload: 表示 fetch 请求之前将忽略 http 缓存的存在, 但是请求拿到响应后, 它将主动更新 http 缓存.</li>
<li>force-cache: 表示 fetch 请求不顾一切的依赖缓存, 即使缓存过期了, 它依然从缓存中读取. 除非没有任何缓存, 那么它将发送一个正常的 request.</li>
<li>only-if-cached: 表示 fetch 请求不顾一切的依赖缓存, 即使缓存过期了, 它依然从缓存中读取. 如果没有缓存, 它将抛出网络错误(该设置只在 mode 为”same-origin”时有效).</li>
</ul>
</li>
</ul>
<h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>fetch 函数返回一个 Promise 对象</p>
<ul>
<li>当收到服务器的返回结果后(注：404 等也是返回的结果)，Promise 进入 resolved 状态，状态数据为 Response 对象</li>
<li>当网络发生错误（或其他导致无法完成交互的错误）时，Promise 进入 rejected 状态，状态数据为错误信息</li>
</ul>
<p><strong>Response 对象</strong></p>
<ul>
<li>ok：boolean，当响应消息码在 200~299 之间时为 true，其他为 false</li>
<li>status：number，响应的状态码</li>
<li>**json()**：用于处理 JSON 格式的 Ajax 的响应。它将 JSON 数据流转换为一个被解决为 JavaScript 对象的 promise。</li>
<li>**text()**：用于处理文本格式的 Ajax 响应。它从响应中获取文本流，将其读完，然后返回一个被解决为 string 对象的 Promise。</li>
<li>blob()：用于处理二进制文件格式（比如图片或者电子表格）的 Ajax 响应。它读取文件的原始数据，一旦读取完整个文件，就返回一个被解决为 blob 对象的 Promise。</li>
<li>redirect()：可以用于重定向到另一个 URL。它会创建一个新的 Promise，以解决来自重定向的 URL 的响应。</li>
</ul>
<p><strong>完整使用</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getProvinces</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> url = <span class="string">&quot;http://101.132.72.36:5100/api/local&quot;</span>;</span><br><span class="line">  <span class="keyword">const</span> config = &#123;</span><br><span class="line">    method: <span class="string">&quot;GET&quot;</span>,</span><br><span class="line">    headers: &#123;</span><br><span class="line">      a: <span class="number">1</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> resp = <span class="keyword">await</span> fetch(url, config); <span class="comment">//返回response对象，先等服务器的响应结果</span></span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> resp.json(); <span class="comment">//解析响应结果，等解析完成后再进行后续操作，所以用await</span></span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="comment">//如果上面为rejected状态会进入这里面</span></span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果确定不会出错，甚至可以更简单</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getProvinces</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> url = <span class="string">&quot;http://101.132.72.36:5100/api/local&quot;</span>;</span><br><span class="line">  <span class="keyword">const</span> resp = <span class="keyword">await</span> fetch(url);</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">await</span> resp.json();</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//袁总用过的一种写法</span></span><br><span class="line"></span><br><span class="line">fetch(url)</span><br><span class="line">  .then(<span class="function">(<span class="params">resp</span>) =&gt;</span> resp.json())</span><br><span class="line">  .then(<span class="function">(<span class="params">resp</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(resp);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<h2 id="Request-对象"><a href="#Request-对象" class="headerlink" title="Request 对象"></a>Request 对象</h2><p>除了使用基本的 fetch 方法，还可以通过创建一个 Request 对象来完成请求（实际上，fetch 的内部会帮你创建一个 Request 对象）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Request(url地址, 配置);</span><br></pre></td></tr></table></figure>

<p>注意点：</p>
<p>尽量保证每次请求都是一个新的 Request 对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> req;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRequestInfo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!req) &#123;</span><br><span class="line">    <span class="keyword">const</span> url = <span class="string">&quot;http://101.132.72.36:5100/api/local&quot;</span>;</span><br><span class="line">    req = <span class="keyword">new</span> Request(url, &#123;&#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(req);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> req.clone(); <span class="comment">//克隆一个全新的request对象，配置一致</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getProvinces</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> resp = <span class="keyword">await</span> fetch(getRequestInfo());</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">await</span> resp.json();</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">&quot;button&quot;</span>).onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  getProvinces();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Response-对象"><a href="#Response-对象" class="headerlink" title="Response 对象"></a>Response 对象</h2><p>可以用来模拟数据使用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getProvinces</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> resp = <span class="keyword">new</span> Response(</span><br><span class="line">    <span class="string">`[</span></span><br><span class="line"><span class="string">        &#123;&quot;id&quot;:1, &quot;name&quot;:&quot;北京&quot;&#125;,</span></span><br><span class="line"><span class="string">        &#123;&quot;id&quot;:2, &quot;name&quot;:&quot;天津&quot;&#125;</span></span><br><span class="line"><span class="string">    ]`</span>,</span><br><span class="line">    &#123;</span><br><span class="line">      ok: <span class="literal">true</span>,</span><br><span class="line">      status: <span class="number">200</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">await</span> getJSON(resp);</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getJSON</span>(<span class="params">resp</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> json = <span class="keyword">await</span> resp.json();</span><br><span class="line">  <span class="keyword">return</span> json;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Header-对象"><a href="#Header-对象" class="headerlink" title="Header 对象"></a>Header 对象</h2><p>在 Request 和 Response 对象内部，会将传递的请求头对象，转换为 Headers</p>
<p>Headers 对象中的方法：</p>
<ul>
<li>has(key)：检查请求头中是否存在指定的 key 值</li>
<li>get(key): 得到请求头中对应的 key 值</li>
<li>set(key, value)：修改对应的键值对</li>
<li>append(key, value)：添加对应的键值对</li>
<li>keys(): 得到所有的请求头键的集合</li>
<li>values(): 得到所有的请求头中的值的集合</li>
<li>entries(): 得到所有请求头中的键值对的集合</li>
</ul>
<p>基本使用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> req;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRequestInfo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!req) &#123;</span><br><span class="line">    <span class="keyword">const</span> url = <span class="string">&quot;http://101.132.72.36:5100/api/local&quot;</span>;</span><br><span class="line">    <span class="keyword">const</span> headers = <span class="keyword">new</span> Headers(&#123;</span><br><span class="line">      a: <span class="number">1</span>,</span><br><span class="line">      b: <span class="number">2</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">    req = <span class="keyword">new</span> Request(url, &#123;</span><br><span class="line">      headers,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(req);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> req.clone(); <span class="comment">//克隆一个全新的request对象，配置一致</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>案例</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> req;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCommonHeaders</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Headers(&#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: <span class="number">2</span>,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printHeaders</span>(<span class="params">headers</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> datas = headers.entries();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> pair <span class="keyword">of</span> datas) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`key: <span class="subst">$&#123;pair[<span class="number">0</span>]&#125;</span>，value: <span class="subst">$&#123;pair[<span class="number">1</span>]&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRequestInfo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!req) &#123;</span><br><span class="line">    <span class="keyword">const</span> url = <span class="string">&quot;http://101.132.72.36:5100/api/local&quot;</span>;</span><br><span class="line">    <span class="keyword">const</span> headers = getCommonHeaders();</span><br><span class="line">    headers.set(<span class="string">&quot;a&quot;</span>, <span class="number">3</span>);</span><br><span class="line">    req = <span class="keyword">new</span> Request(url, &#123;</span><br><span class="line">      headers,</span><br><span class="line">    &#125;);</span><br><span class="line">    printHeaders(headers);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> req.clone(); <span class="comment">//克隆一个全新的request对象，配置一致</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getProvinces</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> resp = <span class="keyword">await</span> fetch(getRequestInfo());</span><br><span class="line">  printHeaders(resp.headers);</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">await</span> getJSON(resp);</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getJSON</span>(<span class="params">resp</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> json = <span class="keyword">await</span> resp.json();</span><br><span class="line">  <span class="keyword">return</span> json;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">&quot;button&quot;</span>).onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  getProvinces();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><p>流程：</p>
<ol>
<li>客户端将文件数据发送给服务器</li>
<li>服务器保存上传的文件数据到服务器端</li>
<li>服务器响应给客户端一个文件访问地址</li>
</ol>
<blockquote>
<p>测试地址：<a target="_blank" rel="noopener" href="http://101.132.72.36:5100/api/upload">http://101.132.72.36:5100/api/upload</a><br>键的名称（表单域名称）：imagefile</p>
</blockquote>
<p>请求方法：POST<br>请求的表单格式：enctype =”multipart/form-data” （input 的 multiple 属性可选择多个文件）<br>请求体中必须包含一个键值对，键的名称是服务器要求的名称，值是文件数据</p>
<blockquote>
<p>HTML5 中，JS 仍然无法随意的获取文件数据，但是可以获取到 input 元素中，被用户选中的文件数据<br>可以利用 HTML5 提供的 FormData 构造函数来创建请求体</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">upload</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> inp = <span class="built_in">document</span>.getElementById(<span class="string">&quot;avatar&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (inp.files.length === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//判断是否选择了文件</span></span><br><span class="line">    alert(<span class="string">&quot;请先选择文件&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> formdata = <span class="keyword">new</span> FormData(); <span class="comment">//创建ForData对象</span></span><br><span class="line">  formdata.append(<span class="string">&quot;imagefile&quot;</span>, inp.files[<span class="number">0</span>]); <span class="comment">//把文件添加到对象</span></span><br><span class="line">  <span class="keyword">const</span> url = <span class="string">&quot;http://101.132.72.36:5100/api/upload&quot;</span>;</span><br><span class="line">  <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(url, &#123;</span><br><span class="line">    <span class="comment">//进行ajax请求</span></span><br><span class="line">    method: <span class="string">&quot;POST&quot;</span>,</span><br><span class="line">    body: formdata, <span class="comment">//fordata对象会自动添加header</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">await</span> response.json(); <span class="comment">//将响应数据转为json格式</span></span><br><span class="line">  <span class="keyword">return</span> result; <span class="comment">//返回数据</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">&quot;button&quot;</span>).onclick = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">await</span> upload(); <span class="comment">//异步调用方法</span></span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">  <span class="comment">//将返回数据里面的图片路径赋值给img标签</span></span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&quot;imgAvatar&quot;</span>).src = result.path;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="迭代器和生成器"><a href="#迭代器和生成器" class="headerlink" title="迭代器和生成器"></a>迭代器和生成器</h1><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><h3 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h3><ol>
<li>什么是迭代？</li>
</ol>
<p>从一个数据集合中按照一定的顺序，不断取出数据的过程</p>
<ol start="2">
<li>迭代和遍历的区别？</li>
</ol>
<p>迭代强调的是依次取数据，并不保证取多少，也不保证把所有的数据取完</p>
<p>遍历强调的是要把整个数据依次全部取出</p>
<ol start="3">
<li>迭代器</li>
</ol>
<p>对迭代过程的封装，在不同的语言中有不同的表现形式，通常为对象</p>
<ol start="4">
<li>迭代模式</li>
</ol>
<p>一种设计模式，用于统一迭代过程，并规范了迭代器规格：</p>
<ul>
<li>迭代器应该具有得到下一个数据的能力</li>
<li>迭代器应该具有判断是否还有后续数据的能力</li>
</ul>
<h3 id="JS-中的迭代器"><a href="#JS-中的迭代器" class="headerlink" title="JS 中的迭代器"></a>JS 中的迭代器</h3><p>JS 规定，如果一个对象具有 next 方法，并且该方法返回一个对象，则认为该对象是一个迭代器。该对象的格式如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">value</span>: 值, <span class="attr">done</span>: 是否迭代完成&#125;</span><br></pre></td></tr></table></figure>

<p>含义：</p>
<ul>
<li>next 方法：用于得到下一个数据</li>
<li>返回的对象<ul>
<li>value：下一个数据的值</li>
<li>done：boolean，是否迭代完成</li>
</ul>
</li>
</ul>
<h4 id="使用迭代器和循环的区别"><a href="#使用迭代器和循环的区别" class="headerlink" title="使用迭代器和循环的区别"></a>使用迭代器和循环的区别</h4><ol>
<li>用循环的方式也能够完成迭代的过程，但是使用循环需要直接跟数据集打交道</li>
<li>很多情况下没有什么问题，可以直接使用循环</li>
<li>数据集如果不是真数组，可能还需要把他转换为真数组，做一些处理。</li>
<li>使用迭代器就可以避免这种情况</li>
</ol>
<ul>
<li>==可以这么想象：==<ol>
<li>这个数组是一个仓库</li>
<li>用循环的模式，是亲自去仓库取数据</li>
<li>用迭代器的方式，相当于多加了一个人，不是直接跟仓库打交道，而是和管理员打交道</li>
</ol>
</li>
</ul>
<h4 id="迭代器的使用"><a href="#迭代器的使用" class="headerlink" title="迭代器的使用"></a>迭代器的使用</h4><p>基本写法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="comment">//迭代数组arr</span></span><br><span class="line"><span class="keyword">const</span> iterator = &#123;</span><br><span class="line">  i: <span class="number">0</span>, <span class="comment">//当前的数组下标</span></span><br><span class="line">  next() &#123;</span><br><span class="line">    <span class="keyword">var</span> result = &#123;</span><br><span class="line">      value: arr[<span class="built_in">this</span>.i],</span><br><span class="line">      done: <span class="built_in">this</span>.i &gt;= arr.length,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">this</span>.i++;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//让迭代器不断的取出下一个数据，直到没有数据为止</span></span><br><span class="line"><span class="comment">//最重要的是：使用过程中没有用到数组</span></span><br><span class="line"><span class="keyword">let</span> data = iterator.next();</span><br><span class="line"><span class="keyword">while</span> (!data.done) &#123;</span><br><span class="line">  <span class="comment">//只要没有迭代完成，则取出数据</span></span><br><span class="line">  <span class="built_in">console</span>.log(data.value);</span><br><span class="line">  <span class="comment">//进行下一次迭代</span></span><br><span class="line">  data = iterator.next();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;迭代完成&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>迭代器创建函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代器创建函数  iterator creator</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createIterator</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>; <span class="comment">//当前的数组下标</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    next() &#123;</span><br><span class="line">      <span class="keyword">var</span> result = &#123;</span><br><span class="line">        value: arr[i],</span><br><span class="line">        done: i &gt;= arr.length,</span><br><span class="line">      &#125;;</span><br><span class="line">      i++;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> iter1 = createIterator(arr1);</span><br><span class="line"><span class="keyword">const</span> iter2 = createIterator(arr2);</span><br></pre></td></tr></table></figure>

<p>获取斐波拉契数列</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 依次得到斐波拉契数列前面n位的值</span></span><br><span class="line"><span class="comment">// 1 1 2 3 5 8 13 .....</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个斐波拉契数列的迭代器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFeiboIterator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> prev1 = <span class="number">1</span>,</span><br><span class="line">    prev2 = <span class="number">1</span>, <span class="comment">//当前位置的前1位和前2位</span></span><br><span class="line">    n = <span class="number">1</span>; <span class="comment">//当前是第几位</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    next() &#123;</span><br><span class="line">      <span class="keyword">let</span> value;</span><br><span class="line">      <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">        value = <span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        value = prev1 + prev2;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> result = &#123;</span><br><span class="line">        value,</span><br><span class="line">        done: <span class="literal">false</span>,</span><br><span class="line">      &#125;;</span><br><span class="line">      prev2 = prev1;</span><br><span class="line">      prev1 = result.value;</span><br><span class="line">      n++;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> iterator = createFeiboIterator();</span><br></pre></td></tr></table></figure>

<h2 id="可迭代协议-与-for-of-循环"><a href="#可迭代协议-与-for-of-循环" class="headerlink" title="可迭代协议 与 for-of 循环"></a>可迭代协议 与 for-of 循环</h2><h3 id="可迭代协议"><a href="#可迭代协议" class="headerlink" title="可迭代协议"></a>可迭代协议</h3><p><strong>概念回顾</strong></p>
<ul>
<li>迭代器(iterator)：一个具有 next 方法的对象，next 方法返回下一个数据并且能指示是否迭代完成</li>
<li>迭代器创建函数（iterator creator）：一个返回迭代器的函数</li>
</ul>
<h4 id="可迭代协议-1"><a href="#可迭代协议-1" class="headerlink" title="可迭代协议"></a>可迭代协议</h4><p>==ES6 规定，如果一个对象具有知名符号属性<code>Symbol.iterator</code>，并且属性值是一个迭代器创建函数，则该对象是可迭代的（iterable）==</p>
<blockquote>
<p>思考：如何知晓一个对象是否是可迭代的？</p>
</blockquote>
<p>答：判断是否有 Symbol.iterator 这个符号属性，并且是否是一个函数</p>
<blockquote>
<p>思考：如何遍历一个可迭代对象？</p>
</blockquote>
<p>答：如下。</p>
<h4 id="遍历可迭代对象"><a href="#遍历可迭代对象" class="headerlink" title="遍历可迭代对象"></a>遍历可迭代对象</h4><ul>
<li>数组是可迭代对象</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">5</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>];</span><br><span class="line"><span class="keyword">const</span> iterator = arr[<span class="built_in">Symbol</span>.iterator](); <span class="comment">//返回arr的迭代器</span></span><br><span class="line"><span class="keyword">let</span> result = iterator.next();</span><br><span class="line"><span class="keyword">while</span> (!result.done) &#123;</span><br><span class="line">  <span class="comment">//判断迭代是否完成</span></span><br><span class="line">  <span class="keyword">const</span> item = result.value; <span class="comment">//取出数据</span></span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">  result = iterator.next(); <span class="comment">//下一次迭代</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>获取的 domList 也是可迭代对象</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> divs = <span class="built_in">document</span>.querySelectorAll(<span class="string">&quot;div&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> iterator = divs[<span class="built_in">Symbol</span>.iterator](); <span class="comment">//返回divs的迭代器</span></span><br><span class="line"><span class="keyword">let</span> result = iterator.next();</span><br><span class="line"><span class="keyword">while</span> (!result.done) &#123;</span><br><span class="line">  <span class="keyword">const</span> item = result.value; <span class="comment">//取出数据</span></span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">  result = iterator.next(); <span class="comment">//下一次迭代</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="for-of-循环"><a href="#for-of-循环" class="headerlink" title="for-of 循环"></a>for-of 循环</h4><ul>
<li>for-of 循环用于遍历可迭代对象，格式如下</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//迭代完成后循环结束</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> iterable) &#123;</span><br><span class="line">  <span class="comment">//iterable：可迭代对象</span></span><br><span class="line">  <span class="comment">//item：每次迭代得到的数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>基本使用：</strong></li>
</ul>
<p>遍历数组：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">5</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// const iterator = arr[Symbol.iterator]();</span></span><br><span class="line"><span class="comment">// let result = iterator.next();</span></span><br><span class="line"><span class="comment">// while (!result.done) &#123;</span></span><br><span class="line"><span class="comment">//     const item = result.value; //取出数据</span></span><br><span class="line"><span class="comment">//     console.log(item);</span></span><br><span class="line"><span class="comment">//     //下一次迭代</span></span><br><span class="line"><span class="comment">//     result = iterator.next();</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="comment">//作用完全相等于上方代码</span></span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遍历对象属性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="number">2</span>,</span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">    <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(<span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      next: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> propName = keys[i];</span><br><span class="line">        <span class="keyword">const</span> propValue = <span class="built_in">this</span>[propName];</span><br><span class="line">        <span class="keyword">const</span> result = &#123;</span><br><span class="line">          value: &#123;</span><br><span class="line">            propName,</span><br><span class="line">            propValue,</span><br><span class="line">          &#125;,</span><br><span class="line">          done: i &gt;= keys.length,</span><br><span class="line">        &#125;;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> obj) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="展开运算符与可迭代对象"><a href="#展开运算符与可迭代对象" class="headerlink" title="展开运算符与可迭代对象"></a>展开运算符与可迭代对象</h4><p>展开运算符可以==<strong>作用于可迭代对象</strong>==，这样，就可以轻松的将可迭代对象转换为数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="number">2</span>,</span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">    <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(<span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      next: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> propName = keys[i];</span><br><span class="line">        <span class="keyword">const</span> propValue = <span class="built_in">this</span>[propName];</span><br><span class="line">        <span class="keyword">const</span> result = &#123;</span><br><span class="line">          value: &#123;</span><br><span class="line">            propName,</span><br><span class="line">            propValue,</span><br><span class="line">          &#125;,</span><br><span class="line">          done: i &gt;= keys.length,</span><br><span class="line">        &#125;;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [...obj]; <span class="comment">//把可迭代对象展开放入数组中</span></span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//此处是被展开后的属性a和b</span></span><br><span class="line">  <span class="built_in">console</span>.log(a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(...obj); <span class="comment">// //把可迭代对象展开放入函数中</span></span><br></pre></td></tr></table></figure>

<h2 id="生成器-Generator"><a href="#生成器-Generator" class="headerlink" title="生成器 (Generator)"></a>生成器 (Generator)</h2><h3 id="什么是生成器？"><a href="#什么是生成器？" class="headerlink" title="什么是生成器？"></a>什么是生成器？</h3><p>生成器是一个通过构造函数 Generator 创建的对象，生成器既是一个迭代器，同时又是一个可迭代对象</p>
<h3 id="如何创建生成器？"><a href="#如何创建生成器？" class="headerlink" title="如何创建生成器？"></a>如何创建生成器？</h3><p>生成器的创建，必须使用生成器函数（Generator Function）</p>
<h3 id="生成器格式-amp-基本使用"><a href="#生成器格式-amp-基本使用" class="headerlink" title="生成器格式&amp;基本使用"></a>生成器格式&amp;基本使用</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是一个生成器函数，该函数一定返回一个生成器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">method</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//注：*可以在function后面，也可在函数名前面</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>==生成器函数内部是如何执行的？==</strong></p>
<p>生成器函数内部是为了给生成器的每次迭代提供的数据</p>
<p>每次调用生成器的 next 方法，将导致生成器函数运行到下一个 yield 关键字位置</p>
<p>yield 是一个关键字，该关键字只能在生成器函数内部使用，表达“产生”一个迭代数据。</p>
<p><strong>==生成器基本使用：==</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;第1次运行&quot;</span>);</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>; <span class="comment">//返回value值为1</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;第2次运行&quot;</span>);</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>; <span class="comment">//返回value值为2</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;第3次运行&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> generator = test();</span><br><span class="line">grenerator.next();</span><br><span class="line"><span class="comment">//第一次运行</span></span><br><span class="line"><span class="comment">//&#123;value: 1, done: false&#125;</span></span><br><span class="line">grenerator.next();</span><br><span class="line"><span class="comment">//第二次运行</span></span><br><span class="line"><span class="comment">//&#123;value: 2, done: false&#125;</span></span><br><span class="line">grenerator.next();</span><br><span class="line"><span class="comment">//第三次运行，后面没有yield关键字，迭代器结束</span></span><br><span class="line"><span class="comment">//&#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure>

<p>数组迭代：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代器创建函数  iterator creator</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">createIterator</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">    <span class="keyword">yield</span> item;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> iter1 = createIterator(arr1);</span><br><span class="line"><span class="keyword">const</span> iter2 = createIterator(arr2);</span><br></pre></td></tr></table></figure>

<p>斐波拉契数列</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个斐波拉契数列的迭代器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">createFeiboIterator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> prev1 = <span class="number">1</span>,</span><br><span class="line">    prev2 = <span class="number">1</span>, <span class="comment">//当前位置的前1位和前2位</span></span><br><span class="line">    n = <span class="number">1</span>; <span class="comment">//当前是第几位</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> newValue = prev1 + prev2;</span><br><span class="line">      <span class="keyword">yield</span> newValue;</span><br><span class="line">      prev2 = prev1;</span><br><span class="line">      prev1 = newValue;</span><br><span class="line">    &#125;</span><br><span class="line">    n++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> iterator = createFeiboIterator();</span><br></pre></td></tr></table></figure>

<h3 id="需要注意的细节"><a href="#需要注意的细节" class="headerlink" title="需要注意的细节"></a>需要注意的细节</h3><ol>
<li><p>生成器函数可以有返回值，返回值出现在第一次 done 为 true 时的 value 属性中（也就是迭代结束的时候）</p>
<pre><code><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">function</span>* <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;第1次运行&quot;</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;第2次运行&quot;</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;第3次运行&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2.  调用生成器的 next 方法时，可以传递参数，传递的参数会交给 yield 表达式的返回值</span><br><span class="line"></span><br><span class="line">    &#96;&#96;&#96;js</span><br><span class="line">    function* test() &#123;</span><br><span class="line">      console.log(&quot;函数开始&quot;);</span><br><span class="line">      let info &#x3D; yield 1; &#x2F;&#x2F; 此处不是把1赋值给info</span><br><span class="line">      console.log(info);</span><br><span class="line">      info &#x3D; yield 2 + info;</span><br><span class="line">      console.log(info);</span><br><span class="line">    &#125;</span><br><span class="line">    const generator &#x3D; test();</span><br><span class="line">    genrator.next(); &#x2F;&#x2F; 函数开始  &#123;value: 1, done: false&#125;</span><br><span class="line">    genrator.next(5); &#x2F;&#x2F;在这里传递参数 &#123;value: 7, done: false&#125;</span><br><span class="line">    grenerator.next();</span><br><span class="line">    &#x2F;&#x2F;第三次运行，后面没有yield关键字，迭代器结束</span><br><span class="line">    &#x2F;&#x2F;&#123;value: undefined, done: true&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>第一次调用 next 方法时，传参没有任何意义</p>
</li>
<li><p>在生成器函数内部，可以调用其他生成器函数，但是要注意加上*号</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">t1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span>* t1();</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="生成器的其他-API"><a href="#生成器的其他-API" class="headerlink" title="生成器的其他 API"></a>生成器的其他 API</h3><ul>
<li>return 方法：调用该方法，可以提前结束生成器函数，从而提前让整个迭代过程结束<ul>
<li>grenerator.return(); 让整个迭代结束{value: undefined, done: true}</li>
<li>grenerator.return(10);让整个迭代结束{value: 10, done: true}</li>
</ul>
</li>
<li>throw 方法：调用该方法，可以在生成器中产生一个错误<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>; <span class="comment">//错误会放在这里</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> generator = test();</span><br><span class="line">generator.next();</span><br><span class="line">generator.throw(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;这是一个错误&quot;</span>));</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="生成器应用-异步任务控制"><a href="#生成器应用-异步任务控制" class="headerlink" title="生成器应用-异步任务控制"></a>生成器应用-异步任务控制</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">task</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> d = <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(d);</span><br><span class="line">  <span class="comment">// //d : 1</span></span><br><span class="line">  <span class="keyword">const</span> resp = <span class="keyword">yield</span> fetch(<span class="string">&quot;http://101.132.72.36:5100/api/local&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">yield</span> resp.json();</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run(task);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">generatorFunc</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> generator = generatorFunc();</span><br><span class="line">  <span class="keyword">let</span> result = generator.next(); <span class="comment">//启动任务（开始迭代）, 得到迭代数据</span></span><br><span class="line">  handleResult();</span><br><span class="line">  <span class="comment">//对result进行处理</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleResult</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (result.done) &#123;</span><br><span class="line">      <span class="keyword">return</span>; <span class="comment">//迭代完成，不处理</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//迭代没有完成，分为两种情况</span></span><br><span class="line">    <span class="comment">//1. 迭代的数据是一个Promise</span></span><br><span class="line">    <span class="comment">//2. 迭代的数据是其他数据</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> result.value.then === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">      <span class="comment">//1. 迭代的数据是一个Promise</span></span><br><span class="line">      <span class="comment">//等待Promise完成后，再进行下一次迭代</span></span><br><span class="line">      result.value.then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">        result = generator.next(data);</span><br><span class="line">        handleResult();</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//2. 迭代的数据是其他数据，直接进行下一次迭代</span></span><br><span class="line">      result = generator.next(result.value);</span><br><span class="line">      handleResult();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="更多集合类型"><a href="#更多集合类型" class="headerlink" title="更多集合类型"></a>更多集合类型</h1><blockquote>
<p>一直以来，JS 只能使用数组和对象来保存多个数据，缺乏像其他语言那样拥有丰富的集合类型。因此，ES6 新增了两种集合类型（set 和 map），用于在不同的场景中发挥作用。</p>
</blockquote>
<h2 id="set-集合"><a href="#set-集合" class="headerlink" title="set 集合"></a>set 集合</h2><p>set 用于存放不重复的数据</p>
<h3 id="创建-set-集合"><a href="#创建-set-集合" class="headerlink" title="创建 set 集合"></a>创建 set 集合</h3><p>创建一个没有任何内容的 set 集合</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Set</span>();</span><br></pre></td></tr></table></figure>

<p>创建一个具有初始内容的 set 集合，内容来自于可迭代对象每一次迭代的结果</p>
<ul>
<li>传入可迭代对象</li>
<li>字符串也是可迭代对象，每次迭代一个字符</li>
<li>也是一种非常简单的去重方式</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Set</span>(iterable); <span class="comment">//传入必须是可迭代对象</span></span><br></pre></td></tr></table></figure>

<h3 id="set-集合的操作"><a href="#set-集合的操作" class="headerlink" title="set 集合的操作"></a>set 集合的操作</h3><ul>
<li>add(数据): 添加一个数据到 set 集合末尾，如果数据已存在，则不进行任何操作<ul>
<li>set 使用 Object.is 的方式判断两个数据是否相同，但是，针对+0 和-0，set 认为是相等</li>
</ul>
</li>
<li>has(数据): 判断 set 中是否存在对应的数据</li>
<li>delete(数据)：删除匹配的数据，返回是否删除成功</li>
<li>clear()：清空整个 set 集合</li>
<li>size: 获取 set 集合中的元素数量，只读属性，无法重新赋值</li>
</ul>
<p>数组转换成 set 集合：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([……]);</span><br></pre></td></tr></table></figure>

<p>set 集合转换成数组</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [...s];</span><br></pre></td></tr></table></figure>

<p>数组去重</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">const</span> result = [...new <span class="built_in">Set</span>(arr)];</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure>

<p>字符串去重</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&quot;adsdlfjdslkf&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> result = [...new <span class="built_in">Set</span>(str)].join(<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure>

<h3 id="遍历-set-集合"><a href="#遍历-set-集合" class="headerlink" title="遍历 set 集合"></a>遍历 set 集合</h3><ol>
<li>使用 for-of 循环</li>
<li>使用 set 中的实例方法 forEach<ul>
<li>注意：set 集合中不存在下标，因此 forEach 中的回调的第二个参数和第一个参数是一致的，均表示 set 中的每一项</li>
</ul>
</li>
</ol>
<h3 id="set-应用"><a href="#set-应用" class="headerlink" title="set 应用"></a>set 应用</h3><ul>
<li>获得两个数组的并集、交集、差集(不能出现重复项)，得到的结果是一个新数组</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//并集</span></span><br><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>(arr1.concat(arr2));</span><br><span class="line"><span class="keyword">const</span> result = [...s]</span><br><span class="line">cosnt result = [...new <span class="built_in">Set</span>(arr1.concat(arr2))];<span class="comment">//一步写完方式一</span></span><br><span class="line">cosnt result = [...new <span class="built_in">Set</span>([...arr1,...arr2])];<span class="comment">//一步写完方式二</span></span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br><span class="line"></span><br><span class="line"><span class="comment">//交集</span></span><br><span class="line"><span class="keyword">const</span> s1 = <span class="keyword">new</span> <span class="built_in">Set</span>(arr1);</span><br><span class="line">[...s1].filter(<span class="function"><span class="params">item</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr2.indexOf(item) &gt;=<span class="number">0</span>;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> result = [...new <span class="built_in">Set</span>(arr1)].filter(<span class="function"><span class="params">item</span> =&gt;</span> arr2.indexOf(item) &gt;= <span class="number">0</span>);<span class="comment">//简写</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//差集</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;差集&quot;</span>, [...new <span class="built_in">Set</span>([...arr1, ...arr2])].filter(<span class="function"><span class="params">item</span> =&gt;</span> arr1.indexOf(item) &gt;= <span class="number">0</span> &amp;&amp; arr2.indexOf(item) &lt; <span class="number">0</span> || arr2.indexOf(item) &gt;= <span class="number">0</span> &amp;&amp; arr1.indexOf(item) &lt; <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;差集&quot;</span>, [...new <span class="built_in">Set</span>([...arr1, ...arr2])].filter(<span class="function"><span class="params">item</span> =&gt;</span> jiaoji.indexOf(item) &lt; <span class="number">0</span>)) <span class="comment">//如果已经有交集，可以用它</span></span><br></pre></td></tr></table></figure>

<h3 id="手写-set-扩展"><a href="#手写-set-扩展" class="headerlink" title="手写 set[扩展]"></a>手写 set[扩展]</h3><p>这里是模拟，并不是和源码一模一样</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySet</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(iterator = []) &#123;</span><br><span class="line">    <span class="comment">//验证是否是可迭代的对象</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> iterator[<span class="built_in">Symbol</span>.iterator] !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">`你提供的<span class="subst">$&#123;iterator&#125;</span>不是一个可迭代的对象`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>._datas = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> iterator) &#123;</span><br><span class="line">      <span class="built_in">this</span>.add(item);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> <span class="title">size</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._datas.length;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  add(data) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.has(data)) &#123;</span><br><span class="line">      <span class="built_in">this</span>._datas.push(data);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  has(data) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> <span class="built_in">this</span>._datas) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.isEqual(data, item)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span>(data) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>._datas.length; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> element = <span class="built_in">this</span>._datas[i];</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.isEqual(element, data)) &#123;</span><br><span class="line">        <span class="comment">//删除</span></span><br><span class="line">        <span class="built_in">this</span>._datas.splice(i, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  clear() &#123;</span><br><span class="line">    <span class="built_in">this</span>._datas.length = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//这里是用生成器创建迭代器</span></span><br><span class="line">  *[<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> <span class="built_in">this</span>._datas) &#123;</span><br><span class="line">      <span class="keyword">yield</span> item;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  forEach(callback) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> <span class="built_in">this</span>._datas) &#123;</span><br><span class="line">      callback(item, item, <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 判断两个数据是否相等</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;*&#125;</span> <span class="variable">data1</span></span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;*&#125;</span> <span class="variable">data2</span></span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  isEqual(data1, data2) &#123;</span><br><span class="line">    <span class="keyword">if</span> (data1 === <span class="number">0</span> &amp;&amp; data2 === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.is(data1, data2);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="map-集合"><a href="#map-集合" class="headerlink" title="map 集合"></a>map 集合</h2><p>键值对（key value pair）数据集合的特点：键不可重复</p>
<p>map 集合专门用于存储多个键值对数据。</p>
<p>在 map 出现之前，我们使用的是对象的方式来存储键值对，键是属性名，值是属性值。</p>
<p>使用对象存储有以下问题：</p>
<ol>
<li>键名只能是字符串</li>
<li>获取数据的数量不方便</li>
<li>键名容易跟原型上的名称冲突</li>
</ol>
<h3 id="创建-map-集合"><a href="#创建-map-集合" class="headerlink" title="创建 map 集合"></a>创建 map 集合</h3><p>创建一个空的 map</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Map</span>();</span><br></pre></td></tr></table></figure>

<p>创建一个具有初始内容的 map，初始内容来自于可迭代对象每一次迭代的结果，但是，它要求每一次迭代的结果必须是一个长度为 2 的数组，数组第一项表示键，数组的第二项表示值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mp1 = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="string">&quot;a&quot;</span>, <span class="number">3</span>],</span><br><span class="line">  [<span class="string">&quot;b&quot;</span>, <span class="number">4</span>],</span><br><span class="line">  [<span class="string">&quot;c&quot;</span>, <span class="number">5</span>],</span><br><span class="line">]);</span><br></pre></td></tr></table></figure>

<h3 id="操作-map-集合"><a href="#操作-map-集合" class="headerlink" title="操作 map 集合"></a>操作 map 集合</h3><ul>
<li>size：只读属性，获取当前 map 中键的数量</li>
<li>set(键, 值)：设置一个键值对，键和值可以是任何类型<ul>
<li>如果键不存在，则添加一项</li>
<li>如果键已存在，则修改它的值</li>
<li>比较键的方式和 set 相同</li>
</ul>
</li>
<li>get(键): 根据一个键得到对应的值</li>
<li>has(键)：判断某个键是否存在</li>
<li>delete(键)：删除指定的键</li>
<li>clear(): 清空 map</li>
</ul>
<h3 id="和数组互相转换"><a href="#和数组互相转换" class="headerlink" title="和数组互相转换"></a>和数组互相转换</h3><p>数组转换成 map 集合：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Map</span>([……]);</span><br></pre></td></tr></table></figure>

<p>map 集合转换成数组</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [...s];</span><br></pre></td></tr></table></figure>

<h3 id="遍历-map-集合"><a href="#遍历-map-集合" class="headerlink" title="遍历 map 集合"></a>遍历 map 集合</h3><ul>
<li>for-of，每次迭代得到的是一个长度为 2 的数组</li>
<li>forEach，通过回调函数遍历<ul>
<li>参数 1：每一项的值</li>
<li>参数 2：每一项的键</li>
<li>参数 3：map 本身</li>
</ul>
</li>
</ul>
<h3 id="手写-map-扩展"><a href="#手写-map-扩展" class="headerlink" title="手写 map[扩展]"></a>手写 map[扩展]</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyMap</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(iterable = []) &#123;</span><br><span class="line">    <span class="comment">//验证是否是可迭代的对象</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> iterable[<span class="built_in">Symbol</span>.iterator] !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">`你提供的<span class="subst">$&#123;iterable&#125;</span>不是一个可迭代的对象`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>._datas = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> iterable) &#123;</span><br><span class="line">      <span class="comment">// item 也得是一个可迭代对象</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> item[<span class="built_in">Symbol</span>.iterator] !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">`你提供的<span class="subst">$&#123;item&#125;</span>不是一个可迭代的对象`</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> iterator = item[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line">      <span class="keyword">const</span> key = iterator.next().value;</span><br><span class="line">      <span class="keyword">const</span> value = iterator.next().value;</span><br><span class="line">      <span class="built_in">this</span>.set(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  set(key, value) &#123;</span><br><span class="line">    <span class="keyword">const</span> obj = <span class="built_in">this</span>._getObj(key);</span><br><span class="line">    <span class="keyword">if</span> (obj) &#123;</span><br><span class="line">      <span class="comment">//修改</span></span><br><span class="line">      obj.value = value;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>._datas.push(&#123;</span><br><span class="line">        key,</span><br><span class="line">        value,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  get(key) &#123;</span><br><span class="line">    <span class="keyword">const</span> item = <span class="built_in">this</span>._getObj(key);</span><br><span class="line">    <span class="keyword">if</span> (item) &#123;</span><br><span class="line">      <span class="keyword">return</span> item.value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> <span class="title">size</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._datas.length;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span>(key) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>._datas.length; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> element = <span class="built_in">this</span>._datas[i];</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.isEqual(element.key, key)) &#123;</span><br><span class="line">        <span class="built_in">this</span>._datas.splice(i, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  clear() &#123;</span><br><span class="line">    <span class="built_in">this</span>._datas.length = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 根据key值从内部数组中，找到对应的数组项</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;*&#125;</span> <span class="variable">key</span></span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  _getObj(key) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> <span class="built_in">this</span>._datas) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.isEqual(item.key, key)) &#123;</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  has(key) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._getObj(key) !== <span class="literal">undefined</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 判断两个数据是否相等</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;*&#125;</span> <span class="variable">data1</span></span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;*&#125;</span> <span class="variable">data2</span></span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  isEqual(data1, data2) &#123;</span><br><span class="line">    <span class="keyword">if</span> (data1 === <span class="number">0</span> &amp;&amp; data2 === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.is(data1, data2);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  *[<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> <span class="built_in">this</span>._datas) &#123;</span><br><span class="line">      <span class="keyword">yield</span> [item.key, item.value];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  forEach(callback) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> <span class="built_in">this</span>._datas) &#123;</span><br><span class="line">      callback(item.value, item.key, <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="WeakSet-和-WeakMap-扩展"><a href="#WeakSet-和-WeakMap-扩展" class="headerlink" title="WeakSet 和 WeakMap[扩展]"></a>WeakSet 和 WeakMap[扩展]</h2><h3 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h3><p>使用该集合，可以实现和 set 一样的功能，不同的是：</p>
<ol>
<li><strong>它内部存储的对象地址不会影响垃圾回收</strong><ul>
<li>使用 Set()时，在数据对象变为 null 的时候，通过 set 对象依然可以找到数据，数据因为 Set()的影响不会被回收</li>
<li>使用 WeakSet()对象时，则数据对象在变为 null 的时，不会影响其垃圾回收(也就是数据会回收，WeakSet 对象也找不到)<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  name: <span class="string">&quot;yj&quot;</span>,</span><br><span class="line">  age: <span class="number">18</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//const set = new Set();</span></span><br><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="built_in">WeakSet</span>();</span><br><span class="line">set.add(obj);</span><br><span class="line">obj = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">console</span>.log(set);</span><br><span class="line"><span class="comment">//注意：垃圾回收不是立即回收的，重新获取set会为空</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>只能添加对象</li>
<li>不能遍历（不是可迭代的对象）、没有 size 属性、没有 forEach 方法</li>
<li>主要就是看看是否被回收</li>
</ol>
<h3 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h3><p>类似于 map 的集合，不同的是：</p>
<ol>
<li><strong>它的键存储的地址不会影响垃圾回收</strong></li>
<li>它的键只能是对象</li>
<li>不能遍历（不是可迭代的对象）、没有 size 属性、没有 forEach 方法</li>
</ol>
<ul>
<li>应用场景：有时候界面的某些元素可能会关联到一个普通的 js 对象，这个&lt;li&gt;存在的话，这个对象应该存在，这个&lt;li&gt;不存在的话，这个对象应该消失。如果把这些对象放在数组里面，因为不会回收就要出问题，这个时候就可以用 WeakMap 来实现</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;!-- &#123; id:&quot;1&quot;, name:&quot;姓名1&quot; &#125; --&gt;</span><br><span class="line">    &lt;li&gt;1&lt;&#x2F;li&gt;</span><br><span class="line">    &lt;!-- &#123; id:&quot;2&quot;, name:&quot;姓名2&quot; &#125; --&gt;</span><br><span class="line">    &lt;li&gt;2&lt;&#x2F;li&gt;</span><br><span class="line">    &lt;!-- &#123; id:&quot;3&quot;, name:&quot;姓名3&quot; &#125; --&gt;</span><br><span class="line">    &lt;li&gt;3&lt;&#x2F;li&gt;</span><br><span class="line">&lt;&#x2F;ul&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    const wmap &#x3D; new WeakMap();</span><br><span class="line">    let list &#x3D; document.querySelectorAll(&quot;li&quot;);</span><br><span class="line">    for (const li of list) &#123;</span><br><span class="line">        wmap.set(li, &#123;</span><br><span class="line">            id: li.innerHTML,</span><br><span class="line">            name: &#96;姓名$&#123;li.innerHTML&#125;&#96;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    lis[0].remove();</span><br><span class="line">    lis &#x3D; null;</span><br><span class="line"></span><br><span class="line">    console.log(wmap);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<h1 id="代理与反射"><a href="#代理与反射" class="headerlink" title="代理与反射"></a>代理与反射</h1><h3 id="Reflect-反射"><a href="#Reflect-反射" class="headerlink" title="Reflect 反射"></a>Reflect 反射</h3><p>Reflect 是一个内置的 JS 对象，它提供了一系列方法，可以让开发者通过调用这些方法，访问一些 JS 底层功能</p>
<p>由于它类似于其他语言的<strong>反射</strong>，因此取名为 Reflect</p>
<h4 id="它可以做什么？"><a href="#它可以做什么？" class="headerlink" title="它可以做什么？"></a>它可以做什么？</h4><p>使用 Reflect 可以实现诸如 属性的赋值与取值、调用普通函数、调用构造函数、判断属性是否存在与对象中 等等功能</p>
<h4 id="这些功能不是已经存在了吗？为什么还需要用-Reflect-实现一次？"><a href="#这些功能不是已经存在了吗？为什么还需要用-Reflect-实现一次？" class="headerlink" title="这些功能不是已经存在了吗？为什么还需要用 Reflect 实现一次？"></a>这些功能不是已经存在了吗？为什么还需要用 Reflect 实现一次？</h4><p>有一个重要的理念，在 ES5 就被提出：==减少魔法、让代码更加纯粹==</p>
<p>这种理念很大程度上是受到函数式编程的影响</p>
<p>ES6 进一步贯彻了这种理念，它认为，对属性内存的控制、原型链的修改、函数的调用等等，这些都属于底层实现，属于一种魔法，因此，需要将它们提取出来，形成一个正常的 API，并高度聚合到某个对象中，于是，就造就了 Reflect 对象</p>
<p>因此，你可以看到 Reflect 对象中有很多的 API 都可以使用过去的某种语法或其他 API 实现。</p>
<h4 id="提供的-API"><a href="#提供的-API" class="headerlink" title="提供的 API"></a>提供的 API</h4><ul>
<li>Reflect.set(target, propertyKey, value): 设置对象 target 的属性 propertyKey 的值为 value，等同于给对象的属性赋值</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.a = <span class="number">10</span>; <span class="comment">//阅读起来就是：给obj的属性a赋值为10</span></span><br><span class="line"><span class="built_in">Reflect</span>.set(obj, <span class="string">&quot;a&quot;</span>, <span class="number">10</span>); <span class="comment">//阅读起来就是：使用底层实现，将obj的a赋值为10</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Reflect.get(target, propertyKey): 读取对象 target 的属性 propertyKey，等同于读取对象的属性值</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(obj.a);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Reflect</span>.get(obj, <span class="string">&quot;a&quot;</span>));</span><br></pre></td></tr></table></figure>

<ul>
<li>Reflect.apply(target, thisArgument, argumentsList)：调用一个指定的函数，并绑定 this 和参数列表。等同于函数调用</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">method</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;method&quot;</span>, a, b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//method(3, 4);</span></span><br><span class="line"><span class="built_in">Reflect</span>.apply(method, <span class="literal">null</span>, [<span class="number">3</span>, <span class="number">4</span>]);</span><br></pre></td></tr></table></figure>

<ul>
<li>Reflect.deleteProperty(target, propertyKey)：删除一个对象的属性</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">delete</span> obj.a;</span><br><span class="line"><span class="built_in">Reflect</span>.deleteProperty(obj, <span class="string">&quot;a&quot;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Reflect.defineProperty(target, propertyKey, attributes)：类似于 Object.defineProperty，不同的是如果配置出现问题，返回 false 而不是报错</p>
</li>
<li><p>Reflect.construct(target, argumentsList)：用构造函数的方式创建一个对象</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.a = a;</span><br><span class="line">  <span class="built_in">this</span>.b = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// const t = new Test(1, 3);</span></span><br><span class="line"><span class="keyword">const</span> t = <span class="built_in">Reflect</span>.construct(Test, [<span class="number">1</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(t);</span><br></pre></td></tr></table></figure>

<ul>
<li>Reflect.has(target, propertyKey): 判断一个对象是否拥有一个属性</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// console.log(&quot;a&quot; in obj);</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Reflect</span>.has(obj, <span class="string">&quot;a&quot;</span>));</span><br></pre></td></tr></table></figure>

<ul>
<li>其他 API：<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect</a></li>
</ul>
<h2 id="Proxy-代理"><a href="#Proxy-代理" class="headerlink" title="Proxy 代理"></a>Proxy 代理</h2><p>代理：提供了让开发者能够重写底层实现的机制</p>
<p>格式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代理一个目标对象</span></span><br><span class="line"><span class="comment">//target：目标对象</span></span><br><span class="line"><span class="comment">//handler：是一个普通对象，其中可以重写底层实现</span></span><br><span class="line"><span class="comment">//返回一个代理对象</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br></pre></td></tr></table></figure>

<p>handler 里面可以重写反射里面的所有方法</p>
<p>使用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;</span><br><span class="line">  set(target, propertyKey, value) &#123;</span><br><span class="line">    <span class="comment">//目标对象，属性名，属性值</span></span><br><span class="line">    target[propertyKey] = value;</span><br><span class="line">    <span class="comment">//代理时一般使用下面这种格式，更容易理解</span></span><br><span class="line">    <span class="built_in">Reflect</span>.set(target, propertyKey, value);</span><br><span class="line">  &#125;,</span><br><span class="line">  get(target, propertyKey) &#123;</span><br><span class="line">    <span class="comment">// 判断是否有这个关键字</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Reflect</span>.has(target, propertyKey)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, propertyKey);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  has(target, propertyKey) &#123;</span><br><span class="line">    <span class="comment">//判断是否含有某属性</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">proxy.a = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(proxy.a); <span class="comment">//10</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy, c); <span class="comment">//-1 通过代理读取c属性，代理运行get</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;a&quot;</span> <span class="keyword">in</span> proxy); <span class="comment">//false 通过代理判断是否含有a这个属性</span></span><br></pre></td></tr></table></figure>

<h2 id="应用：观察者模式"><a href="#应用：观察者模式" class="headerlink" title="应用：观察者模式"></a>应用：观察者模式</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个观察者</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observer</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> div = <span class="built_in">document</span>.getElementById(<span class="string">&quot;container&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">    set(target, prop, value) &#123;</span><br><span class="line">      <span class="built_in">Reflect</span>.set(target, prop, value);</span><br><span class="line">      render();</span><br><span class="line">    &#125;,</span><br><span class="line">    get(target, prop) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, prop);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">  render();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> html = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> prop <span class="keyword">of</span> <span class="built_in">Object</span>.keys(target)) &#123;</span><br><span class="line">      html += <span class="string">`</span></span><br><span class="line"><span class="string">                &lt;p&gt;&lt;span&gt;<span class="subst">$&#123;prop&#125;</span>：&lt;/span&gt;&lt;span&gt;<span class="subst">$&#123;target[prop]&#125;</span>&lt;/span&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="string">            `</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    div.innerHTML = html;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> obj = observer(target);</span><br></pre></td></tr></table></figure>

<h2 id="应用：偷懒的构造函数"><a href="#应用：偷懒的构造函数" class="headerlink" title="应用：偷懒的构造函数"></a>应用：偷懒的构造函数</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ConstructorProxy</span>(<span class="params">Class, ...propNames</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(Class, &#123;</span><br><span class="line">    construct(target, argumentsList) &#123;</span><br><span class="line">      <span class="keyword">const</span> obj = <span class="built_in">Reflect</span>.construct(target, argumentsList);</span><br><span class="line">      propNames.forEach(<span class="function">(<span class="params">name, i</span>) =&gt;</span> &#123;</span><br><span class="line">        obj[name] = argumentsList[i];</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> UserProxy = ConstructorProxy(User, <span class="string">&quot;firstName&quot;</span>, <span class="string">&quot;lastName&quot;</span>, <span class="string">&quot;age&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> UserProxy(<span class="string">&quot;袁&quot;</span>, <span class="string">&quot;进&quot;</span>, <span class="number">18</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Monster</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MonsterProxy = ConstructorProxy(</span><br><span class="line">  Monster,</span><br><span class="line">  <span class="string">&quot;attack&quot;</span>,</span><br><span class="line">  <span class="string">&quot;defence&quot;</span>,</span><br><span class="line">  <span class="string">&quot;hp&quot;</span>,</span><br><span class="line">  <span class="string">&quot;rate&quot;</span>,</span><br><span class="line">  <span class="string">&quot;name&quot;</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> MonsterProxy(<span class="number">10</span>, <span class="number">20</span>, <span class="number">100</span>, <span class="number">30</span>, <span class="string">&quot;怪物&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(m);</span><br></pre></td></tr></table></figure>

<h2 id="应用：可验证的参数函数"><a href="#应用：可验证的参数函数" class="headerlink" title="应用：可验证的参数函数"></a>应用：可验证的参数函数</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">validatorFunction</span>(<span class="params">func, ...types</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(func, &#123;</span><br><span class="line">    apply(target, thisArgument, argumentsList) &#123;</span><br><span class="line">      types.forEach(<span class="function">(<span class="params">t, i</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> arg = argumentsList[i];</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> arg !== t) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(</span><br><span class="line">            <span class="string">`第<span class="subst">$&#123;i + <span class="number">1</span>&#125;</span>个参数<span class="subst">$&#123;argumentsList[i]&#125;</span>不满足类型<span class="subst">$&#123;t&#125;</span>`</span></span><br><span class="line">          );</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Reflect</span>.apply(target, thisArgument, argumentsList);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sumProxy = validatorFunction(sum, <span class="string">&quot;number&quot;</span>, <span class="string">&quot;number&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(sumProxy(<span class="number">1</span>, <span class="number">2</span>));</span><br></pre></td></tr></table></figure>

<h1 id="增强的数组功能"><a href="#增强的数组功能" class="headerlink" title="增强的数组功能"></a>增强的数组功能</h1><h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><ul>
<li>Array.of(…args): 使用指定的数组项创建一个新数组<ul>
<li>和 Array(…args)是一样的，只是传一个参数时也是参数</li>
<li><code>const arr = new Array.of(1,2,3)</code></li>
<li>建议：除非初始化长度，否则建议使用[]或者 Array.of()</li>
</ul>
</li>
<li>Array.from(arg): 传入类数组或可迭代对象，创建一个新的数组</li>
</ul>
<h2 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h2><ul>
<li>find(callback): 用于查找满足条件的第一个元素<ul>
<li>一般查找一个元素时用 find，查找多个时用 filter</li>
</ul>
</li>
<li>findIndex(callback)：用于查找满足条件的第一个元素的下标<ul>
<li>indexOf()用来查找对象数组时，因为地址不一样，所以会出问题</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">&quot;a&quot;</span>,</span><br><span class="line">    id: <span class="number">1</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">&quot;b&quot;</span>,</span><br><span class="line">    id: <span class="number">2</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">&quot;c&quot;</span>,</span><br><span class="line">    id: <span class="number">3</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">//找到id为5的对象</span></span><br><span class="line"><span class="comment">//arr.find(item =&gt;&#123;</span></span><br><span class="line"><span class="comment">//    if(item.id === 5)&#123;</span></span><br><span class="line"><span class="comment">//        return true;</span></span><br><span class="line"><span class="comment">//    &#125; else &#123;</span></span><br><span class="line"><span class="comment">//        return false</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//&#125;)</span></span><br><span class="line"><span class="keyword">const</span> result = arr.find(<span class="function">(<span class="params">item</span>) =&gt;</span> item.id === <span class="number">3</span>);</span><br><span class="line"><span class="keyword">const</span> resultIndex = arr.findIndex(<span class="function">(<span class="params">item</span>) =&gt;</span> item.id === <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(result, resultIndex); <span class="comment">//obj 2 ,若不存在返回undefined</span></span><br></pre></td></tr></table></figure>

<ul>
<li>fill(data)：用指定的数据填充满数组所有的内容</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建了一个长度为100的数组，数组的每一项是&quot;abc&quot;</span></span><br><span class="line"><span class="keyword">const</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">100</span>);</span><br><span class="line">arr.fill(<span class="string">&quot;abc&quot;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>copyWithin(target, start?, end?): 在数组内部完成复制<ul>
<li>后两项代表可传可不传</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="comment">//从下标2开始，改变数组的数据，数据来自于下标0位置开始</span></span><br><span class="line">arr.copyWithin(<span class="number">2</span>); <span class="comment">// [1, 2, 1, 2, 3, 4]</span></span><br><span class="line">arr.copyWithin(<span class="number">2</span>, <span class="number">1</span>); <span class="comment">// [1, 2, 2, 3, 4, 5]</span></span><br><span class="line">arr.copyWithin(<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>); <span class="comment">// [1, 2, 2, 4, 5, 6]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br></pre></td></tr></table></figure>

<ul>
<li>includes(data)：判断数组中是否包含某个值，使用 Object.is 匹配</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">45</span>, <span class="number">21</span>, <span class="number">356</span>, <span class="number">66</span>, <span class="number">6</span>, <span class="literal">NaN</span>, <span class="number">723</span>, <span class="number">54</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr.indexOf(<span class="number">66</span>) &gt;= <span class="number">0</span>); <span class="comment">//拿的是下标，语义化不好</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.includes(<span class="number">66</span>)); <span class="comment">//返回布尔</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.includes(<span class="literal">NaN</span>)); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h2 id="类型化数组-扩展"><a href="#类型化数组-扩展" class="headerlink" title="类型化数组[扩展]"></a>类型化数组[扩展]</h2><h3 id="数字存储的前置知识"><a href="#数字存储的前置知识" class="headerlink" title="数字存储的前置知识"></a>数字存储的前置知识</h3><ol>
<li><p>计算机必须使用固定的位数来存储数字，无论存储的数字是大是小，在内存中占用的空间是固定的。</p>
</li>
<li><p>n 位的无符号整数能表示的数字是 2^n 个，取值范围是：0 ~ 2^n - 1</p>
</li>
<li><p>n 位的有符号整数能表示的数字是 2^n 个，取值范围是：-2^(n-1) ~ 2^(n-1) - 1</p>
</li>
<li><p>浮点数表示法可以用于表示整数和小数，目前分为两种标准：</p>
<ol>
<li>32 位浮点数：又称为单精度浮点数，它用 1 位表示符号，8 位表示阶码，23 位表示尾数</li>
<li>64 位浮点数：又称为双精度浮点数，它用 1 位表示符号，11 位表示阶码，52 位表示尾数</li>
</ol>
</li>
<li><p>JS 中的所有数字，均使用双精度浮点数保存</p>
</li>
</ol>
<h3 id="类型化数组"><a href="#类型化数组" class="headerlink" title="类型化数组"></a>类型化数组</h3><p>类型化数组：用于优化多个==数字==的存储</p>
<p>具体分为：</p>
<ul>
<li>Int8Array： 8 位有符号整数（-128 ~ 127）</li>
<li>Uint8Array： 8 位无符号整数（0 ~ 255）</li>
<li>Int16Array: …</li>
<li>Uint16Array: …</li>
<li>Int32Array: …</li>
<li>Uint32Array: …</li>
<li>Float32Array:</li>
<li>Float64Array</li>
</ul>
<ol>
<li>如何创建数组</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">new</span> 数组构造函数(长度)</span><br><span class="line"></span><br><span class="line">数组构造函数.of(元素...)</span><br><span class="line"></span><br><span class="line">数组构造函数.from(可迭代对象)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> 数组构造函数(其他类型化数组)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意：超出既定长度会出现问题</p>
<ol start="2">
<li>得到长度</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">数组.length; <span class="comment">//得到元素数量</span></span><br><span class="line">数组.byteLength; <span class="comment">//得到占用的字节数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = <span class="keyword">new</span> <span class="built_in">Int32Array</span>(<span class="number">10</span>);</span><br><span class="line"><span class="comment">// const arr = Uint8Array.of(12, 5, 6, 7);</span></span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br><span class="line"><span class="built_in">console</span>.log(arr.length);</span><br><span class="line"><span class="built_in">console</span>.log(arr.byteLength);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>其他的用法跟普通数组一致，但是：</li>
</ol>
<ul>
<li>不能增加和删除数据，==类型化数组的长度固定==</li>
<li>一些返回数组的方法，返回的数组是同类型化的新数组</li>
</ul>
<h2 id="ArrayBuffer-扩展"><a href="#ArrayBuffer-扩展" class="headerlink" title="ArrayBuffer[扩展]"></a>ArrayBuffer[扩展]</h2><p>ArrayBuffer：一个对象，用于存储一块固定内存大小的数据。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(字节数);</span><br></pre></td></tr></table></figure>

<p>可以通过属性<code>byteLength</code>得到字节数，可以通过方法<code>slice</code>得到新的 ArrayBuffer</p>
<p>创建了一个用于存储 10 个字节的内存空间</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bf = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bf2 = bf.slice(<span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(bf, bf2);</span><br></pre></td></tr></table></figure>

<h3 id="读写-ArrayBuffer"><a href="#读写-ArrayBuffer" class="headerlink" title="读写 ArrayBuffer"></a>读写 ArrayBuffer</h3><ol>
<li>使用 DataView</li>
</ol>
<p>通常会在需要混用多种存储格式时使用 DataView</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bf = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">const</span> view = <span class="keyword">new</span> <span class="built_in">DataView</span>(bf); <span class="comment">//ArrayBuffer，开始位置偏移量，操作数量(不可超过长度)</span></span><br><span class="line"><span class="built_in">console</span>.log(view);</span><br><span class="line"></span><br><span class="line">view.setInt16(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">写数据(偏移量, 长度);</span><br><span class="line">view.getInt8(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">读数据;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用类型化数组</li>
</ol>
<p>实际上，每一个类型化数组都对应一个 ArrayBuffer，如果没有手动指定 ArrayBuffer，类型化数组创建时，会新建一个 ArrayBuffer</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bf = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">10</span>); <span class="comment">//10个字节的内存</span></span><br><span class="line"><span class="keyword">const</span> arr = <span class="keyword">new</span> <span class="built_in">Int16Array</span>(bf);</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">2344</span>; <span class="comment">//操作了两个字节,如果是Int32Array，则 操作4个字节</span></span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br></pre></td></tr></table></figure>

<h2 id="制作黑白照片-扩展"><a href="#制作黑白照片-扩展" class="headerlink" title="制作黑白照片[扩展]"></a>制作黑白照片[扩展]</h2><ul>
<li>制作黑白照片</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div style=<span class="string">&quot;display: flex;&quot;</span>&gt;</span><br><span class="line">        &lt;img src=<span class="string">&quot;./img/liao.jpg&quot;</span> alt=<span class="string">&quot;&quot;</span>&gt;</span><br><span class="line">        &lt;button onclick=<span class="string">&quot;change()&quot;</span>&gt;转换&lt;/button&gt;</span><br><span class="line">        &lt;canvas width=<span class="string">&quot;100&quot;</span> height=<span class="string">&quot;117&quot;</span>&gt;&lt;/canvas&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 画布中的1个图像是由多个像素点组成，每个像素点拥有4个数据：红、绿、蓝、alpha</span></span><br><span class="line"><span class="comment">         * 把一个图像变成黑白，只需要将图像的每个像素点设置成为红绿蓝的平均数即可</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">change</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">const</span> img = <span class="built_in">document</span>.querySelector(<span class="string">&quot;img&quot;</span>);</span><br><span class="line">            <span class="keyword">const</span> cvs = <span class="built_in">document</span>.querySelector(<span class="string">&quot;canvas&quot;</span>);</span><br><span class="line">            <span class="keyword">const</span> ctx = cvs.getContext(<span class="string">&quot;2d&quot;</span>);</span><br><span class="line"></span><br><span class="line">            ctx.drawImage(img, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="comment">//得到画布某一个区域的图像信息</span></span><br><span class="line">            <span class="keyword">const</span> imageData = ctx.getImageData(<span class="number">0</span>, <span class="number">0</span>, img.width, img.height);</span><br><span class="line">            <span class="comment">//这里面的data数据用的是Uint8ClampedArray</span></span><br><span class="line">            <span class="comment">//为什么用Uint8呢？正好是0-255</span></span><br><span class="line">            <span class="comment">//和Uint8Array有什么区别？基本没区别，对画布进行了特殊处理</span></span><br><span class="line">            <span class="built_in">console</span>.log(imageData);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; imageData.data.length; i += <span class="number">4</span>) &#123;</span><br><span class="line">                <span class="comment">//循环一个像素点</span></span><br><span class="line">                <span class="keyword">const</span> r = imageData.data[i];</span><br><span class="line">                <span class="keyword">const</span> g = imageData.data[i + <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">const</span> b = imageData.data[i + <span class="number">2</span>];</span><br><span class="line">                <span class="keyword">const</span> avg = (r + g + b) / <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">                imageData.data[i] = imageData.data[i + <span class="number">1</span>] = imageData.data[i + <span class="number">2</span>] = avg;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将图像数据设置到画布</span></span><br><span class="line">            ctx.putImageData(imageData, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>ajax 请求一张图片<br>图片数据不是 json 格式，是一种二进制格式，用 blob()解析。</li>
</ul>
<p>blob()返回一个 blob 对象，返回一个文件信息（文件尺寸，类型）</p>
<p>blob.arrayBuffer()，可以得到一个 ArrayBuffer 数组，记录了图像信息</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> resp = <span class="keyword">await</span> fetch(<span class="string">&quot;./img/liao.jpg&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> blob = <span class="keyword">await</span> resp.blob();</span><br><span class="line">  <span class="keyword">const</span> bf = <span class="keyword">await</span> blob.arrayBuffer(); <span class="comment">//得到二进制信息</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> arr = <span class="keyword">new</span> <span class="built_in">Int8Array</span>(bf, <span class="number">3</span>, <span class="number">2</span>); <span class="comment">//处理二进制信息，可以有偏移量，长度</span></span><br><span class="line">  <span class="built_in">console</span>.log(arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag"># 笔记</a>
              <a href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag"># 前端</a>
              <a href="/tags/JavaScript/" rel="tag"># JavaScript</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2020/10/01/JavaScript%EF%BC%88%E4%B8%89%EF%BC%89BOM/" rel="prev" title="JavaScript（三）BOM">
                  <i class="fa fa-chevron-left"></i> JavaScript（三）BOM
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2020/10/01/HTML5%E8%AF%A6%E8%A7%A3/" rel="next" title="HTML5详解">
                  HTML5详解 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">黑砸是只猫</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">204k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">3:05</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.0/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  




  <script src="/js/local-search.js"></script>















  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>








  

  



  <script async src="/js/cursor/fireworks.js"></script>

</body>
</html>
